<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的博客</title>
  
  <subtitle>个人技术博客</subtitle>
  <link href="https://zcx4u.github.io/atom.xml" rel="self"/>
  
  <link href="https://zcx4u.github.io/"/>
  <updated>2025-03-18T06:58:26.070Z</updated>
  <id>https://zcx4u.github.io/</id>
  
  <author>
    <name>bruin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CTMediator 架构方案深度解析</title>
    <link href="https://zcx4u.github.io/2025/03/14/CTMediator%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>https://zcx4u.github.io/2025/03/14/CTMediator%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/</id>
    <published>2025-03-14T09:52:47.017Z</published>
    <updated>2025-03-18T06:58:26.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、架构背景深度剖析"><a href="#一、架构背景深度剖析" class="headerlink" title="一、架构背景深度剖析"></a>一、架构背景深度剖析</h1><h2 id="1-1-问题场景再现"><a href="#1-1-问题场景再现" class="headerlink" title="1.1 问题场景再现"></a>1.1 问题场景再现</h2><p><strong>典型痛点表现</strong>：</p><ul><li>编译时间随模块增加呈指数增长（N 模块编译耗时约 [T &#x3D; k*N^2]）</li><li>多团队协作时出现「修改冲突风暴」</li><li>基础模块迭代导致全量回归测试</li></ul><h2 id="1-2-设计决策矩阵"><a href="#1-2-设计决策矩阵" class="headerlink" title="1.2 设计决策矩阵"></a>1.2 设计决策矩阵</h2><table><thead><tr><th>方案类型</th><th>编译时耦合</th><th>运行时开销</th><th>可维护性</th><th>学习曲线</th></tr></thead><tbody><tr><td>直接引用</td><td>高</td><td>低</td><td>差</td><td>低</td></tr><tr><td>协议抽象</td><td>中</td><td>中</td><td>优</td><td>高</td></tr><tr><td>CTMediator</td><td>低</td><td>中</td><td>良</td><td>中</td></tr><tr><td>URL Router</td><td>低</td><td>高</td><td>良</td><td>低</td></tr></tbody></table><h1 id="二、技术实现详解"><a href="#二、技术实现详解" class="headerlink" title="二、技术实现详解"></a>二、技术实现详解</h1><h2 id="2-1-核心类结构"><a href="#2-1-核心类结构" class="headerlink" title="2.1 核心类结构"></a>2.1 核心类结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class CTMediator &#123;</span><br><span class="line">  - cachedTargets: NSMutableDictionary</span><br><span class="line">  + sharedInstance(): CTMediator</span><br><span class="line">  + performTarget(): id</span><br><span class="line">  + safePerformAction(): id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Target_XXX &#123;</span><br><span class="line">  + Action_YYY(): id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTMediator --&gt; Target_XXX : 动态调用</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h2 id="2-2-完整调用链路"><a href="#2-2-完整调用链路" class="headerlink" title="2.2 完整调用链路"></a>2.2 完整调用链路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 调用端示例（含安全校验）</span><br><span class="line">NSDictionary *params = @&#123;</span><br><span class="line">  @&quot;pageID&quot;: @(1024),</span><br><span class="line">  @&quot;authToken&quot;: @&quot;3a8d7f0e&quot;,</span><br><span class="line">  @&quot;callback&quot;: ^(BOOL success) &#123;</span><br><span class="line">      NSLog(@&quot;操作状态: %@&quot;, success ? @&quot;成功&quot; : @&quot;失败&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UIViewController *vc = [[CTMediator sharedInstance]</span><br><span class="line">    performTarget:@&quot;UserCenter&quot;  // 目标模块标识</span><br><span class="line">     action:@&quot;ProfilePage&quot;       // 功能单元标识</span><br><span class="line">     params:[params copy]       // 防御性拷贝</span><br><span class="line">     shouldCacheTarget:YES];    // 高频访问缓存</span><br><span class="line"></span><br><span class="line">// 异常处理流程</span><br><span class="line">if (![vc conformsToProtocol:@protocol(SafeViewProtocol)]) &#123;</span><br><span class="line">    [self trackException:@&#123;</span><br><span class="line">        @&quot;code&quot;: @(403),</span><br><span class="line">        @&quot;reason&quot;: @&quot;视图控制器协议不匹配&quot;</span><br><span class="line">    &#125;];</span><br><span class="line">    vc = [FallbackViewController new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-性能优化策略"><a href="#2-3-性能优化策略" class="headerlink" title="2.3 性能优化策略"></a>2.3 性能优化策略</h2><p><strong>缓存机制实现</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTMediatorCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> targetCache <span class="operator">=</span> [<span class="type">String</span>: <span class="type">NSObject</span>]()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cache</span>(<span class="params">target</span>: <span class="type">NSObject</span>, <span class="params">forKey</span> <span class="params">key</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> targetCache.count <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125; <span class="comment">// 防溢出</span></span><br><span class="line">        targetCache[key] <span class="operator">=</span> target</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">purgeExpired</span>() &#123;</span><br><span class="line">        targetCache.keys</span><br><span class="line">            .filter &#123; lastAccessTime(for: <span class="variable">$0</span>) <span class="operator">&lt;</span> .now<span class="operator">-</span><span class="number">3600</span> &#125;</span><br><span class="line">            .forEach &#123; targetCache.removeValue(forKey: <span class="variable">$0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、架构演进路线"><a href="#三、架构演进路线" class="headerlink" title="三、架构演进路线"></a>三、架构演进路线</h1><h2 id="3-1-当前应用场景"><a href="#3-1-当前应用场景" class="headerlink" title="3.1 当前应用场景"></a>3.1 当前应用场景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">  subgraph 基础层</span><br><span class="line">      CommonUtils --&gt;|反向调用| CTMediator</span><br><span class="line">  end</span><br><span class="line">  </span><br><span class="line">  subgraph 业务层</span><br><span class="line">      FeatureA --&gt;|跨模块调用| CTMediator</span><br><span class="line">      CTMediator --&gt;|动态路由| I18NModule</span><br><span class="line">  end</span><br><span class="line">  </span><br><span class="line">  subgraph 数据层</span><br><span class="line">      Analytics --&gt;|事件上报| CTMediator</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><h2 id="3-2-改造路线图"><a href="#3-2-改造路线图" class="headerlink" title="3.2 改造路线图"></a>3.2 改造路线图</h2><table><thead><tr><th>阶段</th><th>时间范围</th><th>重点任务</th><th>关键指标</th></tr></thead><tbody><tr><td>过渡期</td><td>2025 Q1-Q2</td><td>建立调用备案制度</td><td>调用文档覆盖率 ≥90%</td></tr><tr><td>迁移期</td><td>2025 Q3-Q4</td><td>核心模块接口改造</td><td>直接引用占比 ≤30%</td></tr><tr><td>稳定期</td><td>2026 Q1</td><td>全量静态校验实施</td><td>编译时检查覆盖率 100%</td></tr></tbody></table><h1 id="四、最佳实践指南"><a href="#四、最佳实践指南" class="headerlink" title="四、最佳实践指南"></a>四、最佳实践指南</h1><h2 id="4-1-安全调用模板"><a href="#4-1-安全调用模板" class="headerlink" title="4.1 安全调用模板"></a>4.1 安全调用模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SafeInvoker.h</span><br><span class="line">#define SAFE_CALL(target, action, paramsType) \</span><br><span class="line">__attribute__((overloadable)) \</span><br><span class="line">static inline id safeInvoke(NSString *target, NSString *action, paramsType params) &#123; \</span><br><span class="line">    if (![CTMediator validateTarget:target]) &#123; \</span><br><span class="line">        [NSException raise:@&quot;非法调用&quot; format:@&quot;未经注册的 Target: %@&quot;, target]; \</span><br><span class="line">    &#125; \</span><br><span class="line">    /* ... 参数校验逻辑 ... */ \</span><br><span class="line">    return [[CTMediator sharedInstance] performTarget:target action:action params:params]; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-监控指标配置"><a href="#4-2-监控指标配置" class="headerlink" title="4.2 监控指标配置"></a>4.2 监控指标配置</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;metrics&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;调用成功率&quot;</span><span class="punctuation">:</span> <span class="string">&quot;98.7%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;平均响应时间&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12ms&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;缓存命中率&quot;</span><span class="punctuation">:</span> <span class="string">&quot;82.3%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;异常类型分布&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;TargetNotFound&quot;</span><span class="punctuation">:</span> <span class="number">45</span>%<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ActionMissing&quot;</span><span class="punctuation">:</span> <span class="number">30</span>%<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ParamError&quot;</span><span class="punctuation">:</span> <span class="number">25</span>%</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="五、常见问题诊断"><a href="#五、常见问题诊断" class="headerlink" title="五、常见问题诊断"></a>五、常见问题诊断</h1><table><thead><tr><th>故障现象</th><th>排查步骤</th><th>修复方案</th></tr></thead><tbody><tr><td>调用返回 nil</td><td>1. 检查 Target 类前缀<code>&lt;br&gt;</code>2. 验证 Action 参数类型</td><td>添加 Class 前缀约定</td></tr><tr><td>参数传递丢失</td><td>1. 检查字典 key 大小写<code>&lt;br&gt;</code>2. 验证 NSJSONSerialization 兼容性</td><td>使用类型安全的参数包装器</td></tr><tr><td>内存持续增长</td><td>1. 检查 Target 缓存策略<code>&lt;br&gt;</code>2. 分析 ARC 引用关系</td><td>实现缓存自动回收机制</td></tr></tbody></table><blockquote><p><strong>架构师建议</strong>：在 Swift 主导的新项目中，建议采用 <code>Protocol-Oriented Dependency Injection</code> 模式逐步替代 CTMediator，同时保留其作为应急通信机制。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、架构背景深度剖析&quot;&gt;&lt;a href=&quot;#一、架构背景深度剖析&quot; class=&quot;headerlink&quot; title=&quot;一、架构背景深度剖析&quot;&gt;&lt;/a&gt;一、架构背景深度剖析&lt;/h1&gt;&lt;h2 id=&quot;1-1-问题场景再现&quot;&gt;&lt;a href=&quot;#1-1-问题场景再现&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>代码审查实战指南</title>
    <link href="https://zcx4u.github.io/2025/03/14/CodeReview%E6%8C%87%E5%8D%97/"/>
    <id>https://zcx4u.github.io/2025/03/14/CodeReview%E6%8C%87%E5%8D%97/</id>
    <published>2025-03-13T16:00:00.000Z</published>
    <updated>2025-03-18T06:57:21.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码审查实战指南"><a href="#代码审查实战指南" class="headerlink" title="代码审查实战指南"></a>代码审查实战指南</h1><h2 id="一、代码风格标准化"><a href="#一、代码风格标准化" class="headerlink" title="一、代码风格标准化"></a>一、代码风格标准化</h2><h3 id="1-1-命名规范"><a href="#1-1-命名规范" class="headerlink" title="1.1 命名规范"></a>1.1 命名规范</h3><ul><li>采用匈牙利命名法（如 <code>strUserName</code>）或现代语义命名（如 <code>userNameTextField</code>）</li><li>禁止使用 <code>tmp</code>&#x2F;<code>data</code>等无意义命名</li><li>类名采用大驼峰，方法名使用小驼峰</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的示例</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UserService</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)updateUserProfile:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="1-2-格式一致性"><a href="#1-2-格式一致性" class="headerlink" title="1.2 格式一致性"></a>1.2 格式一致性</h3><ul><li>统一缩进策略（4空格制或2空格制）</li><li>方法参数对齐标准：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)complexCalculationWithParam1:(<span class="built_in">NSInteger</span>)param1</span><br><span class="line">                             param2:(<span class="built_in">CGFloat</span>)param2</span><br><span class="line">                             param3:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="type">id</span>&gt; *)param3</span><br><span class="line">                         completion:(<span class="type">void</span>(^)(ResultType *result))completion;</span><br></pre></td></tr></table></figure><h2 id="二、冗余代码治理"><a href="#二、冗余代码治理" class="headerlink" title="二、冗余代码治理"></a>二、冗余代码治理</h2><h3 id="2-1-代码重复检测"><a href="#2-1-代码重复检测" class="headerlink" title="2.1 代码重复检测"></a>2.1 代码重复检测</h3><p>使用OCLint工具检测重复代码块：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disable-rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">LongLine</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">LongMethod</span></span><br><span class="line"><span class="attr">enable-rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">DuplicatedCode:</span></span><br><span class="line">      <span class="attr">threshold:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><h3 id="2-2-无效代码处理流程"><a href="#2-2-无效代码处理流程" class="headerlink" title="2.2 无效代码处理流程"></a>2.2 无效代码处理流程</h3><h2 id="三、业务逻辑验证"><a href="#三、业务逻辑验证" class="headerlink" title="三、业务逻辑验证"></a>三、业务逻辑验证</h2><h3 id="3-1-核心检查点矩阵"><a href="#3-1-核心检查点矩阵" class="headerlink" title="3.1 核心检查点矩阵"></a>3.1 核心检查点矩阵</h3><table><thead><tr><th>检查维度</th><th>正向案例验证</th><th>异常场景覆盖</th><th>性能边界测试</th></tr></thead><tbody><tr><td>支付流程</td><td>✓</td><td>✓</td><td>＞100TPS</td></tr><tr><td>库存扣减</td><td>✓</td><td>超卖防护</td><td>分布式锁</td></tr></tbody></table><h3 id="3-2-防御性编程模式"><a href="#3-2-防御性编程模式" class="headerlink" title="3.2 防御性编程模式"></a>3.2 防御性编程模式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用NSParameterAssert进行参数检查</span></span><br><span class="line"><span class="built_in">NSParameterAssert</span>(orderId.length &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (orderId.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *errorMsg = <span class="string">@&quot;订单ID不能为空&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, errorMsg);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、规范执行机制"><a href="#四、规范执行机制" class="headerlink" title="四、规范执行机制"></a>四、规范执行机制</h2><h3 id="4-1-自动化检查清单"><a href="#4-1-自动化检查清单" class="headerlink" title="4.1 自动化检查清单"></a>4.1 自动化检查清单</h3><ol><li>SonarQube质量门禁（覆盖率＞80%）</li><li>OCLint格式校验</li><li>OWASP依赖扫描</li><li>编译器警告零容忍</li></ol><h3 id="4-2-审查记录模板"><a href="#4-2-审查记录模板" class="headerlink" title="4.2 审查记录模板"></a>4.2 审查记录模板</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**审查项**</span>：用户服务模块  </span><br><span class="line"><span class="strong">**问题类型**</span>：  </span><br><span class="line"><span class="bullet">-</span> [ ] 代码风格  </span><br><span class="line"><span class="bullet">-</span> [x] 业务逻辑  </span><br><span class="line"><span class="strong">**改进建议**</span>：  </span><br><span class="line">建议使用NSDate替代CFAbsoluteTime  </span><br><span class="line"><span class="strong">**严重程度**</span>：⭐️⭐️</span><br></pre></td></tr></table></figure><h2 id="五、典型问题解答"><a href="#五、典型问题解答" class="headerlink" title="五、典型问题解答"></a>五、典型问题解答</h2><h3 id="Q1：如何处理紧急需求与代码规范的冲突？"><a href="#Q1：如何处理紧急需求与代码规范的冲突？" class="headerlink" title="Q1：如何处理紧急需求与代码规范的冲突？"></a>Q1：如何处理紧急需求与代码规范的冲突？</h3><p>建立 <code>紧急通道白名单</code>机制，需满足：</p><ol><li>提交风险评估报告</li><li>添加TODO注释标记</li><li>72小时内补全审查</li></ol><h3 id="Q2：跨团队代码审查如何协作？"><a href="#Q2：跨团队代码审查如何协作？" class="headerlink" title="Q2：跨团队代码审查如何协作？"></a>Q2：跨团队代码审查如何协作？</h3><p>推荐使用<a href="https://www.gerritcodereview.com/">Gerrit</a>的评审工作流：</p><ol><li>创建跨域评审组</li><li>设置权重评分机制</li><li>实施追踪看板</li></ol><hr><p><strong>延伸阅读</strong>：</p><ul><li><a href="https://google.github.io/eng-practices/review/">Google代码审查标准</a></li><li><a href="https://docs.microsoft.com/codereview-checklist">微软代码评审checklist</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代码审查实战指南&quot;&gt;&lt;a href=&quot;#代码审查实战指南&quot; class=&quot;headerlink&quot; title=&quot;代码审查实战指南&quot;&gt;&lt;/a&gt;代码审查实战指南&lt;/h1&gt;&lt;h2 id=&quot;一、代码风格标准化&quot;&gt;&lt;a href=&quot;#一、代码风格标准化&quot; class=&quot;he</summary>
      
    
    
    
    <category term="软件工程" scheme="https://zcx4u.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="代码审查" scheme="https://zcx4u.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/"/>
    
    <category term="最佳实践" scheme="https://zcx4u.github.io/tags/best-practices/"/>
    
    <category term="开发流程" scheme="https://zcx4u.github.io/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>客户端日志规范指南</title>
    <link href="https://zcx4u.github.io/2025/03/14/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"/>
    <id>https://zcx4u.github.io/2025/03/14/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/</id>
    <published>2025-03-13T16:00:00.000Z</published>
    <updated>2025-03-18T06:57:38.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、日志分类体系"><a href="#一、日志分类体系" class="headerlink" title="一、日志分类体系"></a>一、日志分类体系</h2><h3 id="1-1-核心分类矩阵"><a href="#1-1-核心分类矩阵" class="headerlink" title="1.1 核心分类矩阵"></a>1.1 核心分类矩阵</h3><h3 id="1-2-分类定义"><a href="#1-2-分类定义" class="headerlink" title="1.2 分类定义"></a>1.2 分类定义</h3><table><thead><tr><th>类型</th><th>记录内容</th><th>存储周期</th></tr></thead><tbody><tr><td>诊断日志</td><td>程序运行状态、异常堆栈</td><td>90天</td></tr><tr><td>统计日志</td><td>用户行为埋点、业务转化率</td><td>365天</td></tr><tr><td>审计日志</td><td>敏感操作记录、权限变更</td><td>永久</td></tr></tbody></table><h2 id="二、日志级别标准"><a href="#二、日志级别标准" class="headerlink" title="二、日志级别标准"></a>二、日志级别标准</h2><h3 id="2-1-五级日志对照表"><a href="#2-1-五级日志对照表" class="headerlink" title="2.1 五级日志对照表"></a>2.1 五级日志对照表</h3><table><thead><tr><th>级别</th><th>触发场景</th><th>采样率</th></tr></thead><tbody><tr><td>DEBUG</td><td>开发环境调试日志</td><td>100%</td></tr><tr><td>INFO</td><td>常规流程节点记录</td><td>30%</td></tr><tr><td>WARNING</td><td>可恢复的异常状态</td><td>100%</td></tr><tr><td>ERROR</td><td>影响主流程的异常</td><td>100%</td></tr><tr><td>FATAL</td><td>导致应用崩溃的致命错误</td><td>100%</td></tr></tbody></table><h3 id="2-2-级别使用示例"><a href="#2-2-级别使用示例" class="headerlink" title="2.2 级别使用示例"></a>2.2 级别使用示例</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键函数调用记录</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">didSelectItem</span>(<span class="params">at</span> <span class="params">index</span>: <span class="type">IndexPath</span>) &#123;</span><br><span class="line">    <span class="type">Logger</span>.info(<span class="string">&quot;用户点击单元格&quot;</span>, metadata: [<span class="string">&quot;section&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;row&quot;</span>: <span class="string">&quot;5&quot;</span>])</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">guard</span> isValidIndex(index) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Logger</span>.error(<span class="string">&quot;非法索引路径&quot;</span>, metadata: index.debugDescription)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、关键场景日志规范"><a href="#三、关键场景日志规范" class="headerlink" title="三、关键场景日志规范"></a>三、关键场景日志规范</h2><h3 id="3-1-业务流程监控"><a href="#3-1-业务流程监控" class="headerlink" title="3.1 业务流程监控"></a>3.1 业务流程监控</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">start</span><br><span class="line">:流程开始;</span><br><span class="line">:记录START日志;</span><br><span class="line">if (关键操作) then (成功)</span><br><span class="line">  :记录SUCCESS日志;</span><br><span class="line">else (失败)</span><br><span class="line">  :记录FAILURE日志;</span><br><span class="line">endif</span><br><span class="line">:流程结束;</span><br><span class="line">:记录END日志;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h3 id="3-2-异常处理规范"><a href="#3-2-异常处理规范" class="headerlink" title="3.2 异常处理规范"></a>3.2 异常处理规范</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E1003&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BUSINESS&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expected&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stack_trace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;device_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;os_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iOS 16.4.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WiFi&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="四、高级记录规范"><a href="#四、高级记录规范" class="headerlink" title="四、高级记录规范"></a>四、高级记录规范</h2><h3 id="4-1-耗时操作监控"><a href="#4-1-耗时操作监控" class="headerlink" title="4.1 耗时操作监控"></a>4.1 耗时操作监控</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleLargeFile</span><span class="params">(file: <span class="type">File</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> traceId = Logger.beginTrace(<span class="string">&quot;FILE_PROCESSING&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Logger.debug(<span class="string">&quot;开始处理文件&quot;</span>, metadata: file.metadata)</span><br><span class="line">        <span class="comment">// 实际处理逻辑</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Logger.endTrace(traceId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-环境信息记录"><a href="#4-2-环境信息记录" class="headerlink" title="4.2 环境信息记录"></a>4.2 环境信息记录</h3><table><thead><tr><th>信息维度</th><th>采集字段</th><th>隐私处理</th></tr></thead><tbody><tr><td>设备信息</td><td>型号、OS版本、分辨率</td><td>MD5哈希处理</td></tr><tr><td>网络环境</td><td>连接类型、信号强度、IP地址</td><td>脱敏处理</td></tr><tr><td>用户上下文</td><td>当前页面、登录状态、时区</td><td>加密存储</td></tr></tbody></table><hr><p><strong>最佳实践推荐</strong>：</p><ol><li>使用<a href="https://opentelemetry.io/">OpenTelemetry</a>实现标准化日志采集</li><li>通过<a href="https://grafana.com/oss/loki/">Grafana Loki</a>构建日志监控体系</li><li>采用<a href="https://www.splunk.com/">Splunk</a>进行日志分析与告警</li></ol><blockquote><p>文档版本：v2.3.1<br>更新日期：2025-03-14</p></blockquote>]]></content>
    
    
    <summary type="html">本文详细解析UMU客户端日志体系的三大维度分类、五级日志标准以及28个关键场景的日志打点规范</summary>
    
    
    
    <category term="工程实践" scheme="https://zcx4u.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="移动开发" scheme="https://zcx4u.github.io/tags/mobile-dev/"/>
    
    <category term="日志系统" scheme="https://zcx4u.github.io/tags/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="可观测性" scheme="https://zcx4u.github.io/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>iOS Crash类型总结</title>
    <link href="https://zcx4u.github.io/2025/03/12/iOSCrash%E7%B1%BB%E5%9E%8B/"/>
    <id>https://zcx4u.github.io/2025/03/12/iOSCrash%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-03-11T16:00:00.000Z</published>
    <updated>2025-03-12T11:51:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-Crash类型总结"><a href="#iOS-Crash类型总结" class="headerlink" title="iOS Crash类型总结"></a>iOS Crash类型总结</h1><p>iOS APP系统crash主要分两类：一类是Objective-C Exception，一类是Unix Signal Exception。下面详细介绍。</p><blockquote><p>崩溃日志路径：~&#x2F;Library&#x2F;Logs&#x2F;CrashReporter&#x2F;MobileDevice</p></blockquote><h2 id="一、Objective-C-Exception"><a href="#一、Objective-C-Exception" class="headerlink" title="一、Objective-C Exception"></a>一、Objective-C Exception</h2><p>例如NSDictionary加入nil、数组访问越界等。主要有如下类型：</p><h3 id="1-NSInvalidArgumentException"><a href="#1-NSInvalidArgumentException" class="headerlink" title="1. NSInvalidArgumentException"></a>1. NSInvalidArgumentException</h3><p>非法参数异常(NSInvalidArgumentException)是Objective-C代码最常出现的错误。平时在写代码时需要多加注意，加强对参数的检查，避免传入非法参数导致异常，其中尤以nil参数为甚。</p><p>主要场景包括：</p><h4 id="1-1-集合数据的参数传递"><a href="#1-1-集合数据的参数传递" class="headerlink" title="1.1 集合数据的参数传递"></a>1.1 集合数据的参数传递</h4><p>比如NSMutableArray、NSMutableDictionary的数据操作：</p><ul><li>NSDictionary不能删除nil的key</li><li>NSDictionary不能添加nil的对象</li><li>不能插入nil的对象</li><li>其他一些nil参数</li></ul><h4 id="1-2-其他API的使用"><a href="#1-2-其他API的使用" class="headerlink" title="1.2 其他API的使用"></a>1.2 其他API的使用</h4><p>APP一般都会有网络操作，免不了使用网络相关接口，比如NSURL的初始化，不能传入nil的http地址。</p><h4 id="1-3-未实现的方法"><a href="#1-3-未实现的方法" class="headerlink" title="1.3 未实现的方法"></a>1.3 未实现的方法</h4><ul><li>.h文件里函数名，却忘了修改.m文件里对应的函数名</li><li>使用第三方库时，没有添加”-ObjC” flag</li><li>MRC时，大部分情况下是因为对象被提前release了，在你心里不希望他release的情况下，指针还在，对象已经不在了</li></ul><h3 id="2-NSRangeException"><a href="#2-NSRangeException" class="headerlink" title="2. NSRangeException"></a>2. NSRangeException</h3><p>越界异常(NSRangeException)也是比较常出现的异常，有如下几种类型：</p><ol><li>数组最大下标处理错误<ul><li>比如数组长度count，index的下标范围[0, count-1]，在开发时，可能index的最大值超过数组的范围</li></ul></li><li>下标的值是其他变量赋值<ul><li>这样会有很大的不确定性，可能是一个很大的整数值</li></ul></li><li>使用空数组<ul><li>如果一个数组刚刚初始化，还是空的，就对它进行相关操作</li></ul></li></ol><blockquote><p>为了避免NSRangeException的发生，必须对传入的index参数进行合法性检查，是否在集合数据的个数范围内。</p></blockquote><h3 id="3-NSGenericException"><a href="#3-NSGenericException" class="headerlink" title="3. NSGenericException"></a>3. NSGenericException</h3><p>NSGenericException这个异常最容易出现在foreach操作中。在for-in循环中如果修改所遍历的数组，无论你是add或remove，都会出错。”for-in”的内部遍历使用了类似Iterator进行迭代遍历，一旦元素变动，之前的元素全部被失效。</p><blockquote><p>在foreach的循环当中，最好不要去进行元素的修改动作，若需要修改，循环改为for遍历，由于内部机制不同，不会产生修改后结果失效的问题。</p></blockquote><h3 id="4-NSInternalInconsistencyException"><a href="#4-NSInternalInconsistencyException" class="headerlink" title="4. NSInternalInconsistencyException"></a>4. NSInternalInconsistencyException</h3><p>不一致导致出现的异常，例如：</p><ul><li>NSDictionary当做NSMutableDictionary来使用，从他们内部的机理来说，就会产生一些错误</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *info = method <span class="keyword">return</span> to <span class="built_in">NSDictionary</span> type;</span><br><span class="line">[info setObject:<span class="string">@&quot;sxm&quot;</span> forKey:<span class="string">@&quot;name&quot;</span>];</span><br></pre></td></tr></table></figure><ul><li>xib界面使用或者约束设置不当</li></ul><h3 id="5-NSFileHandleOperationException"><a href="#5-NSFileHandleOperationException" class="headerlink" title="5. NSFileHandleOperationException"></a>5. NSFileHandleOperationException</h3><p>处理文件时的一些异常，最常见的还是存储空间不足的问题，比如应用频繁的保存文档，缓存资料或者处理比较大的数据。</p><blockquote><p>在文件处理里，需要考虑到手机存储空间的问题。</p></blockquote><h3 id="6-NSMallocException"><a href="#6-NSMallocException" class="headerlink" title="6. NSMallocException"></a>6. NSMallocException</h3><p>这也是内存不足的问题，无法分配足够的内存空间。</p><h3 id="7-其他常见Crash"><a href="#7-其他常见Crash" class="headerlink" title="7. 其他常见Crash"></a>7. 其他常见Crash</h3><ul><li>KVO相关Crash<ul><li>移除未注册的观察者</li><li>重复移除观察者</li><li>添加了观察者但是没有实现 <code>-observeValueForKeyPath:ofObject:change:context:</code>方法</li><li>添加移除keypath&#x3D;nil</li><li>添加移除observer&#x3D;nil</li></ul></li><li>unrecognized selector sent to instance（这种也经常是野指针问题）</li></ul><h2 id="二、Unix-Signal-Exception"><a href="#二、Unix-Signal-Exception" class="headerlink" title="二、Unix Signal Exception"></a>二、Unix Signal Exception</h2><h3 id="常见信号类型"><a href="#常见信号类型" class="headerlink" title="常见信号类型"></a>常见信号类型</h3><ol><li><p><strong>SIGHUP</strong></p><ul><li>本信号在用户终端连接(正常或非正常)结束时发出</li><li>通常是在终端的控制进程结束时，通知同一session内的各个作业</li></ul></li><li><p><strong>SIGINT</strong></p><ul><li>程序终止(interrupt)信号</li><li>在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程</li></ul></li><li><p><strong>SIGQUIT</strong></p><ul><li>类似SIGINT，但由QUIT字符(通常是Ctrl-)来控制</li><li>进程在因收到SIGQUIT退出时会产生core文件</li></ul></li><li><p><strong>SIGABRT</strong></p><ul><li>调用abort函数生成的信号</li></ul></li><li><p><strong>SIGBUS</strong></p><ul><li>非法地址，包括内存地址对齐(alignment)出错</li><li>与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的</li></ul></li><li><p><strong>SIGFPE</strong></p><ul><li>致命的算术运算错误信号</li><li>包括浮点运算错误、溢出及除数为0等</li></ul></li><li><p><strong>SIGKILL</strong></p><ul><li>用来立即结束程序的运行</li><li>本信号不能被阻塞、处理和忽略</li></ul></li><li><p><strong>SIGSEGV</strong></p><ul><li>试图访问未分配给自己的内存</li><li>试图往没有写权限的内存地址写数据</li></ul></li><li><p><strong>SIGPIPE</strong></p><ul><li>管道破裂</li><li>通常在进程间通信产生</li></ul></li></ol><h3 id="iOS中常见的系统信号"><a href="#iOS中常见的系统信号" class="headerlink" title="iOS中常见的系统信号"></a>iOS中常见的系统信号</h3><p>在iOS crash中主要是SIGKILL、SIGSEGV、SIGABRT、SIGTRAP，引起系统信号crash主要有内存泄露、野指针等。</p><h3 id="特殊类型Crash"><a href="#特殊类型Crash" class="headerlink" title="特殊类型Crash"></a>特殊类型Crash</h3><table><thead><tr><th>错误码</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>0x8badf00d</td><td>“ate bad food”</td><td>在启动、终止应用或响应系统事件花费过长时间</td></tr><tr><td>0xdeadfa11</td><td>“dead fall”</td><td>用户强制退出（系统无响应时，用户按电源开关和HOME）</td></tr><tr><td>0xbaaaaaad</td><td>-</td><td>用户按住Home键和音量键，获取当前内存状态，不代表崩溃</td></tr><tr><td>0xbad22222</td><td>-</td><td>VoIP应用因为恢复得太频繁导致crash</td></tr><tr><td>0xc00010ff</td><td>“cool off”</td><td>因为太烫了被干掉</td></tr><tr><td>0xdead10cc</td><td>“dead lock”</td><td>因为在后台时仍然占据系统资源（比如通讯录）被干掉</td></tr></tbody></table><h2 id="三、Crash解决方案"><a href="#三、Crash解决方案" class="headerlink" title="三、Crash解决方案"></a>三、Crash解决方案</h2><h3 id="1-Objective-C-Exception处理"><a href="#1-Objective-C-Exception处理" class="headerlink" title="1. Objective-C Exception处理"></a>1. Objective-C Exception处理</h3><p>NSInvalidArgumentException、NSRangeException这一类很好重现，能够复现定位就好解决。需要写代码的时候多做验证，也可以把一些验证写出category，统一使用。</p><p>例如数组访问安全封装：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)safeObjectAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="keyword">self</span>.count) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)safeAddObject:(<span class="type">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addObject:object];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码统一使用，可以避免一些问题。还可以在有异常的时候加入日志或者上报。</p><h3 id="2-信号类Crash处理"><a href="#2-信号类Crash处理" class="headerlink" title="2. 信号类Crash处理"></a>2. 信号类Crash处理</h3><ul><li>主要通过分析是否是系统crash，还是内存泄露、多线程问题等</li><li>内存泄露可以通过instrument定位，也可以在Xcode开启zombie选项定位</li><li>retain-cycle可以使用第三方工具检测</li></ul><h3 id="3-Crash上报机制"><a href="#3-Crash上报机制" class="headerlink" title="3. Crash上报机制"></a>3. Crash上报机制</h3><p>实际项目中通常会接入crash上报工具，如腾讯Bugly。这些上报原理是注册对应的处理handleUncaughtException和信号handle：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line"><span class="type">void</span> InstallUncaughtExceptionHandler(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;handleUncaughtException);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> handleUncaughtException(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *crashInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Exception name：%@\nException reason：%@\nException stack：%@&quot;</span>,</span><br><span class="line">                          [exception name], </span><br><span class="line">                          [exception reason], </span><br><span class="line">                          [exception callStackSymbols]];</span><br><span class="line">    [CrashReporter saveCrash:crashInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号监听</span></span><br><span class="line"><span class="type">void</span> InstallSignalHandler(<span class="type">void</span>) &#123;</span><br><span class="line">    signal(SIGHUP, handleSignalException);</span><br><span class="line">    signal(SIGINT, handleSignalException);</span><br><span class="line">    signal(SIGQUIT, handleSignalException);</span><br><span class="line">    signal(SIGABRT, handleSignalException);</span><br><span class="line">    signal(SIGILL, handleSignalException);</span><br><span class="line">    signal(SIGSEGV, handleSignalException);</span><br><span class="line">    signal(SIGFPE, handleSignalException);</span><br><span class="line">    signal(SIGBUS, handleSignalException);</span><br><span class="line">    signal(SIGPIPE, handleSignalException);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> handleSignalException(<span class="type">int</span> signal) &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *crashInfo = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">    [crashInfo appendString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;signal:%d\n&quot;</span>, signal]];</span><br><span class="line">    [crashInfo appendString:<span class="string">@&quot;Stack:\n&quot;</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="type">void</span> *callstack[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> frames = backtrace(callstack, <span class="number">128</span>);</span><br><span class="line">    <span class="type">char</span> **strs = backtrace_symbols(callstack, frames);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; frames; ++i) &#123;</span><br><span class="line">        [crashInfo appendFormat:<span class="string">@&quot;%s\n&quot;</span>, strs[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    [CrashReporter saveCrash:crashInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样crash的时候存储crash信息，然后再次启动对应上报。</p><blockquote><p>注意：还有一些激进的处理方法，hook系统对应函数不让app crash。但即便不crash，出了问题app体验也不好了，也可能用不了了。建议谨慎使用这种方案。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS-Crash类型总结&quot;&gt;&lt;a href=&quot;#iOS-Crash类型总结&quot; class=&quot;headerlink&quot; title=&quot;iOS Crash类型总结&quot;&gt;&lt;/a&gt;iOS Crash类型总结&lt;/h1&gt;&lt;p&gt;iOS APP系统crash主要分两类：一类是Obj</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/tags/ios/"/>
    
    <category term="调试" scheme="https://zcx4u.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="错误处理" scheme="https://zcx4u.github.io/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS文件系统编程指南</title>
    <link href="https://zcx4u.github.io/2025/03/12/iOS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>https://zcx4u.github.io/2025/03/12/iOS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</id>
    <published>2025-03-11T16:00:00.000Z</published>
    <updated>2025-03-12T11:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS文件系统编程指南"><a href="#iOS文件系统编程指南" class="headerlink" title="iOS文件系统编程指南"></a>iOS文件系统编程指南</h1><p><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/NaN">iOS文件系统编程指南</a></p><blockquote><p>文件系统处理数据文件、应用程序以及与操作系统本身关联的文件的持久存储。因此，文件系统是所有进程使用的基本资源之一。</p><p>APFS 是 macOS、iOS、watchOS 和 tvOS 中的默认文件系统。APFS 取代 HFS+ 作为 iOS 10.3 及更高版本以及 macOS High Sierra 及更高版本的默认文件系统。</p></blockquote><h2 id="关于-iOS-文件系统"><a href="#关于-iOS-文件系统" class="headerlink" title="关于 iOS 文件系统"></a>关于 iOS 文件系统</h2><p>iOS 文件系统面向独立运行的应用程序。为了保持系统简单，iOS 设备的用户无法直接访问文件系统，应用应遵循此约定。</p><img src="https://cdn.zcx.info/202303291747602.png" style="zoom:50%;" /><h2 id="iOS-标准目录：文件所在的位置"><a href="#iOS-标准目录：文件所在的位置" class="headerlink" title="iOS 标准目录：文件所在的位置"></a>iOS 标准目录：文件所在的位置</h2><table><thead><tr><th align="left">目录</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>AppName.app</code></td><td align="left">这是应用程序的捆绑包。此目录包含应用程序及其所有资源。您不能写入此目录。为防止篡改，捆绑目录在安装时进行了签名。写入此目录会更改签名并阻止您的应用程序启动。但是，您可以获得对存储在应用程序包中的任何资源的只读访问权限。此目录的内容未由 iTunes 或 iCloud 备份。但是，iTunes 会对从 App Store 购买的任何应用程序执行初始同步。</td></tr><tr><td align="left"><code>Documents/</code></td><td align="left">使用此目录存储用户生成的内容。该目录的内容可以通过文件共享提供给用户；因此，该目录应该只包含您可能希望向用户公开的文件。此目录的内容由 iTunes 和 iCloud 备份。</td></tr><tr><td align="left"><code>Documents/Inbox</code></td><td align="left">使用此目录可访问外部实体要求您的应用程序打开的文件。具体来说，Mail 程序将与您的应用相关联的电子邮件附件放在该目录中。文档交互控制器也可以在其中放置文件。您的应用程序可以读取和删除此目录中的文件，但不能创建新文件或写入现有文件。如果用户试图编辑此目录中的文件，您的应用程序必须在进行任何更改之前静默将其移出目录。此目录的内容由 iTunes 和 iCloud 备份。</td></tr><tr><td align="left"><code>Library/</code></td><td align="left">这是所有非用户数据文件的顶级目录。您通常将文件放在几个标准子目录之一中。iOS 应用通常使用<code>Application Support</code>和<code>Caches</code>子目录；但是，您可以创建自定义子目录。将<code>Library</code>子目录用于您不想向用户公开的任何文件。您的应用不应将这些目录用于用户数据文件。目录的内容<code>Library</code>（子目录除外<code>Caches</code>）由 iTunes 和 iCloud 备份。</td></tr><tr><td align="left"><code>tmp/</code></td><td align="left">使用此目录写入不需要在应用程序启动之间保留的临时文件。当不再需要时，您的应用程序应从该目录中删除文件；但是，当您的应用程序未运行时，系统可能会清除此目录。此目录的内容未由 iTunes 或 iCloud 备份。</td></tr></tbody></table><h2 id="APP-文件应该存放的位置"><a href="#APP-文件应该存放的位置" class="headerlink" title="APP 文件应该存放的位置"></a>APP 文件应该存放的位置</h2><p>为防止 iOS 设备上的同步和备份过程花费很长时间，请选择放置文件的位置。</p><p>存储大文件的应用程序会减慢备份到 iTunes 或 iCloud 的过程。</p><p>这些应用程序还会占用用户的大量可用存储空间，这可能会促使用户删除该应用程序或禁止将该应用程序的数据备份到 iCloud。</p><p>考虑到这一点，您应该根据以下准则存储应用程序数据：</p><ul><li>将用户数据放入<code>Documents/</code>. 用户数据通常包括您可能希望向用户公开的任何文件——您可能希望用户创建、导入、删除或编辑的任何文件。对于绘图应用程序，用户数据包括用户可能创建的任何图形文件。对于文本编辑器，它包括文本文件。视频和音频应用程序甚至可能包含用户下载以供稍后观看或收听的文件。</li><li>将应用程序创建的支持文件放在该<code>Library/Application support/</code>目录中。通常，此目录包含应用程序用来运行但应该对用户隐藏的文件。此目录还可以包含数据文件、配置文件、模板和从应用程序包加载的资源的修改版本。</li><li>请记住，默认情况下会备份<code>Documents/</code>和中的文件。您可以通过使用键<code>Application Support/</code>调用从备份中排除文件。任何可以重新创建或下载的文件都必须从备份中排除。这对于大型媒体文件尤为重要。如果您的应用程序下载视频或音频文件，请确保它们不包含在备份中。<code> -[NSURL setResourceValue:forKey:error:]``NSURLIsExcludedFromBackupKey</code></li><li>将临时数据放在<code>tmp/</code>目录中。临时数据包括您不需要长时间保留的任何数据。请记住在完成这些文件后将其删除，以免它们继续占用用户设备上的空间。当您的应用程序未运行时，系统会定期清除这些文件；因此，您不能指望这些文件在您的应用程序终止后仍然存在。</li><li>将数据缓存文件放在<code>Library/Caches/</code>目录中。缓存数据可用于需要比临时数据保留更长时间但不如支持文件那么长的任何数据。一般而言，应用程序不需要缓存数据即可正常运行，但可以使用缓存数据来提高性能。缓存数据的示例包括（但不限于）数据库缓存文件和暂时的可下载内容。请注意，<strong>系统可能会删除该<code>Caches/</code>目录以释放磁盘空间</strong>，因此您的应用必须能够根据需要重新创建或下载这些文件。</li></ul><h2 id="iCloud-文件储存容器"><a href="#iCloud-文件储存容器" class="headerlink" title="iCloud 文件储存容器"></a>iCloud 文件储存容器</h2><p>iCloud 为使用 iCloud 的应用程序提供了一个结构化的文件存储系统：</p><ul><li>应用程序有一个主要的 iCloud 容器目录，用于存储它们的本机文件。他们还可以访问在其应用程序授权中列出的辅助 iCloud 容器目录。</li><li>在每个容器目录中，文件被分为“文档”和数据。位于<code>Documents</code>子目录（或其子目录之一）中的每个文件或文件包都作为可以单独删除的单独文档呈现给用户（通过 macOS 和 iOS 中的 iCloud UI）。任何不在<code>Documents</code>其子目录中或其子目录之一的内容都被视为数据，并在 iCloud UI 中显示为单个条目。</li></ul><p>用户在应用程序的用户界面中创建和查看的文档（例如 Pages、Numbers 和 Keynote 中的文档浏览器）应存储在该<code>Documents</code>目录中。</p><p>另一个可能进入<code>Documents</code>目录的文件示例是保存的游戏，同样是因为它们是应用程序可能提供某种选择方法的东西。</p><p>应用程序不希望用户直接查看或修改的任何内容都应放在<code>Documents</code>目录之外。应用程序可以在容器目录中创建任何子目录，因此它们可以根据需要排列私有文件。</p><p>应用程序在 iCloud 容器目录中创建文件和目录的方式与它们创建本地文件和目录的方式完全相同。并且所有文件的属性都被保存，如果他们向文件添加扩展属性，这些属性也会被复制到 iCloud 和用户的其他设备上。</p><p>iCloud 容器还允许存储无需创建文档格式即可轻松访问的键值对。</p><h2 id="系统如何识别文件中的内容类型"><a href="#系统如何识别文件中的内容类型" class="headerlink" title="系统如何识别文件中的内容类型"></a>系统如何识别文件中的内容类型</h2><p>识别文件内容类型的主要技术有两种：</p><ul><li>统一类型标识符 (UTI)</li><li>文件扩展名</li></ul><p><em>统一类型标识符</em>是一个字符串，它唯一地标识被认为具有“类型”的一类实体。UTI 为所有应用程序和服务可以识别和依赖的数据提供一致的标识符。它们也比大多数其他技术更灵活，因为您可以使用它们来表示任何类型的数据，而不仅仅是文件和目录。UTI 的例子包括：</p><ul><li><code>public.text</code>— 标识文本数据的公共类型。</li><li><code>public.jpeg</code>— 标识 JPEG 图像数据的公共类型。</li><li><code>com.apple.bundle</code>— 标识捆绑包目录的 Apple 类型。</li><li><code>com.apple.application-bundle</code>— 标识捆绑应用程序的 Apple 类型。</li></ul><p>每当基于 UTI 的接口可用于指定文件类型时，您应该优先选择该接口而不是其他任何接口。</p><p>许多 macOS 界面允许您指定与您要使用的文件或目录相对应的 UTI。</p><p>例如，在“打开”面板中，您可以将 UTI 用作文件过滤器，并将用户选择的文件类型限制为您的应用可以处理的文件类型。</p><p>几个 AppKit 类，包括<code>NSDocument</code>、<code>NSPasteboard</code>和<code>NSImage</code>，都支持 UTI。在 iOS 中，UTI 仅用于指定粘贴板类型。</p><p>系统确定给定文件的 UTI 的一种方法是查看其文件扩展名。</p><p><em>文件扩展名</em>是附加到文件末尾的一串字符，并用句点与主文件名分隔。每个唯一的字符串标识一个特定类型的文件。</p><p>例如，<code>.strings</code>扩展名标识具有可本地化字符串数据的资源文件，而<code>.png</code>扩展名标识具有便携式网络图形格式的图像数据的文件。</p><blockquote><p>**注意：**由于句点字符在 macOS 和 iOS 文件名中是有效字符，因此只有文件名中最后一个句点之后的字符才被视为文件扩展名的一部分。最后一个句点左侧的所有内容都被视为文件名本身的一部分。</p></blockquote><p>如果您的应用程序定义了自定义文件格式，您应该在您的应用程序文件中注册这些格式和任何关联的文件扩展名<code>Info.plist</code>。</p><p>该<code>CFBundleDocumentTypes</code>密钥指定您的应用可识别并能够打开的文件格式。</p><p>任何自定义文件格式的条目都应包括文件扩展名和与文件内容对应的 UTI。</p><p>系统使用该信息将具有适当类型的文件定向到您的应用程序。</p><h2 id="文件、并发和线程安全"><a href="#文件、并发和线程安全" class="headerlink" title="文件、并发和线程安全"></a>文件、并发和线程安全</h2><p>由于与文件相关的操作涉及与硬盘的交互，因此与大多数其他操作相比速度较慢，因此 iOS 和 macOS 中的大多数与文件相关的界面在设计时都考虑到了并发性。一些技术将异步操作结合到它们的设计中，大多数其他技术可以从调度队列或辅助线程安全地执行。</p><table><thead><tr><th align="left">类&#x2F;技术</th><th align="left">笔记</th></tr></thead><tbody><tr><td align="left"><code>NSFileManager</code></td><td align="left"><code>NSFileManager</code>对于大多数任务，从多个后台线程同时使用默认对象是安全的。此规则的唯一例外是与文件管理器的委托交互的任务。将文件管理器对象与委托一起使用时，建议您创建该类的唯一实例<code>NSFileManager</code>并将委托与该实例一起使用。然后，您应该一次从一个线程使用您的唯一实例。</td></tr><tr><td align="left"><code>GCD</code></td><td align="left">GCD 本身可以安全地从任何线程使用。但是，您仍然有责任以线程安全的方式编写您的块。</td></tr><tr><td align="left"><code>NSFileHandle</code>, <code>NSData</code>, <code>Cocoa streams</code></td><td align="left">大多数用于读取和写入文件数据的 Foundation 对象都可以在任何单个线程中使用，但不应同时在多个线程中使用。</td></tr><tr><td align="left">Open and Save panels</td><td align="left">因为它们是用户界面的一部分，所以您应该始终从应用程序的主线程中显示和操作打开和保存面板。</td></tr><tr><td align="left">POSIX 线程</td><td align="left">用于操作文件的 POSIX 线程通常被设计为从任何线程安全地操作。有关详细信息，请参阅相应的手册页。</td></tr><tr><td align="left"><code>NSURL</code>和<code>NSString</code></td><td align="left">用于指定路径的不可变对象可以安全地从任何线程使用。因为它们是不可变的，所以您也可以同时从多个线程引用它们。当然，这些对象的可变版本一次只能在一个线程中使用。</td></tr><tr><td align="left"><code>NSEnumerator</code>及其子类</td><td align="left">枚举器对象可以安全地从任何单个线程使用，但不应同时从多个线程使用。</td></tr></tbody></table><p>即使您使用线程安全接口来操作文件，当多个线程或多个进程试图对同一个文件进行操作时，问题仍然会出现。</p><p>尽管有防止多个客户端同时修改文件的保护措施，但这些保护措施并不总是保证始终对文件进行独占访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS文件系统编程指南&quot;&gt;&lt;a href=&quot;#iOS文件系统编程指南&quot; class=&quot;headerlink&quot; title=&quot;iOS文件系统编程指南&quot;&gt;&lt;/a&gt;iOS文件系统编程指南&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.c</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/tags/ios/"/>
    
    <category term="多读文档" scheme="https://zcx4u.github.io/tags/%E5%A4%9A%E8%AF%BB%E6%96%87%E6%A1%A3/"/>
    
    <category term="知识点" scheme="https://zcx4u.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>AI作业背景模糊实现技术方案</title>
    <link href="https://zcx4u.github.io/2024/11/29/iOS%E8%83%8C%E6%99%AF%E6%A8%A1%E7%B3%8A%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    <id>https://zcx4u.github.io/2024/11/29/iOS%E8%83%8C%E6%99%AF%E6%A8%A1%E7%B3%8A%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</id>
    <published>2024-11-29T07:53:32.000Z</published>
    <updated>2025-03-17T08:03:26.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS背景模糊实现技术方案"><a href="#iOS背景模糊实现技术方案" class="headerlink" title="iOS背景模糊实现技术方案"></a>iOS背景模糊实现技术方案</h1><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>晖致日本提出很多代表在家里录制AI作业，希望可以将背景模糊，保护代表隐私。</p><p>类似于腾讯会议的背景虚化功能，录制视频作业 的时候将背景模糊化，只保留用户人像区域。</p><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p>业界对这个需求的实现方案基本一致。</p><p>首先录制过程中将视频帧做高斯模糊形成背景模糊中”背景”部分。</p><p>然后在实时的将每一帧图像中包含人像的部分“扣”出来形成一张黑白分明的灰度图（mask）。一般是人像区域为白色，非人像区域为黑色。</p><p>最后使用自定义三输入的滤镜，分别传入模糊后的背景视频帧+灰度mask图+原始视频帧，通过片元着色器对每一个像素点进行遴选。根据灰度图的颜色，白色取原始视频帧，黑色取模糊视频帧。</p><p>这样就形成了背景区域是模糊的，人像区域是正常的视频，达到要求。</p><p>在视频帧处理这方面我们采用项目中已经引入的GPUImage库来实现。</p><h3 id="人像分割"><a href="#人像分割" class="headerlink" title="人像分割"></a>人像分割</h3><p>这个抠图的技术我们称为人像分割，人像分割算法有很多种，常见的包括：基于颜色和纹理的方法、基于边缘检测的方法、基于深度学习的方法、基于图割的方法等。</p><p>目前这一步交由AI组伙伴提供基于TensorFlowLiteObjC的深度学习人像分割模型来实现。</p><h3 id="自研模型"><a href="#自研模型" class="headerlink" title="自研模型"></a>自研模型</h3><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><p>目前chaochao提供了2个模型。</p><p>128x128_fp32.tflite 支持输入128*128像素的图片</p><p>256x144_fp32.tflite 支持输入256*144像素的图片</p><p>核心识别代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;UGPortraitTFliteProcessor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UGPortraitTFliteProcessor</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) cv::Mat cachedMat; <span class="comment">// 缓存的一帧</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDictionary</span> *cachedOutput; <span class="comment">//缓存的一帧计算结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UGPortraitTFliteProcessor</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt; <span class="built_in">NSNumber</span> * &gt; *)getTensorShape &#123;</span><br><span class="line"><span class="built_in">CGSize</span> modelSize = <span class="keyword">self</span>.model.modelSize;</span><br><span class="line"><span class="built_in">NSNumber</span> *dimNum1 = [<span class="built_in">NSNumber</span> numberWithInt:modelSize.width];</span><br><span class="line"><span class="built_in">NSNumber</span> *dimNum2 = [<span class="built_in">NSNumber</span> numberWithInt:modelSize.height];</span><br><span class="line"><span class="built_in">NSArray</span>&lt; <span class="built_in">NSNumber</span> * &gt; *shape = @[ @<span class="number">1</span>, dimNum2, dimNum1, @<span class="number">3</span> ];</span><br><span class="line"><span class="keyword">return</span> shape;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (UGPortraitTFliteProcessor *)processor &#123;</span><br><span class="line"><span class="comment">// CGSize kTFliteModelSize = CGSizeMake(128, 128);</span></span><br><span class="line"><span class="built_in">CGSize</span> kTFliteModelSize = <span class="built_in">CGSizeMake</span>(<span class="number">256</span>, <span class="number">144</span>);</span><br><span class="line"><span class="built_in">NSBundle</span> *targetBundle = [<span class="built_in">NSBundle</span> bundleForClass:<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;UGPortraitTFliteProcessor&quot;</span>)];</span><br><span class="line"><span class="built_in">NSURL</span> *bundleUrl = [targetBundle URLForResource:<span class="string">@&quot;Detection&quot;</span> withExtension:<span class="string">@&quot;bundle&quot;</span>];</span><br><span class="line"><span class="built_in">NSBundle</span> *finalBundle = [<span class="built_in">NSBundle</span> bundleWithURL:bundleUrl];</span><br><span class="line"><span class="comment">// NSString *filePath = [finalBundle pathForResource:@&quot;128x128_fp32&quot; ofType:@&quot;tflite&quot;];</span></span><br><span class="line"><span class="built_in">NSString</span> *filePath = [finalBundle pathForResource:<span class="string">@&quot;256x144_fp32&quot;</span> ofType:<span class="string">@&quot;tflite&quot;</span>];</span><br><span class="line">UGTFliteModel *model = [UGTFliteModel modelWithPath:filePath size:kTFliteModelSize];</span><br><span class="line">UGPortraitTFliteProcessor *processor = [UGPortraitTFliteProcessor processorWithModel:model];</span><br><span class="line"><span class="keyword">return</span> processor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行推理</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)detectWithSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer orientation:(<span class="built_in">UIInterfaceOrientation</span>)orientation isMirror:(<span class="type">BOOL</span>)isMirror &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转成mat</span></span><br><span class="line">cv::Mat matOrigin = [UGTFliteUtil matFromCVPixelBuffer:<span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差值优化 如果两帧画面相差小于3% 则直接使用上一帧的结果(这里保持缓存的data和mat是成对的)</span></span><br><span class="line"><span class="keyword">if</span>([<span class="keyword">self</span> isCacheAvailable] &amp;&amp; [UGTFliteUtil isChangeMinimalWithCurrentFrame:matOrigin lastFrame:_cachedMat threshold:<span class="number">0.035</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.cachedOutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算原始size</span></span><br><span class="line"><span class="built_in">CGSize</span> sizeOrigin = orientation == <span class="built_in">UIInterfaceOrientationLandscapeRight</span> ? <span class="built_in">CGSizeMake</span>(matOrigin.cols, matOrigin.rows) : <span class="built_in">CGSizeMake</span>(matOrigin.rows, matOrigin.cols);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 镜像和orientation翻转</span></span><br><span class="line">cv::Mat matProcess = [UGTFliteUtil processMatWithOrientation:orientation isMirror:isMirror originMat:matOrigin];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放到模型接收的size， chaochao说这个模型不用等比缩放，可以拉伸变形进行推理，推理结果再反向拉伸获取即可</span></span><br><span class="line">cv::Mat mat;</span><br><span class="line">cv::resize(matProcess, mat, cv::Size(<span class="keyword">self</span>.model.modelSize.width, <span class="keyword">self</span>.model.modelSize.height));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意模型需求输入的是归一化二进制数据</span></span><br><span class="line"><span class="built_in">NSData</span> *imageData = [UGTFliteUtil normalizedFloat32ImageDataFromCVMat:mat]; <span class="comment">// 归一化处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型开始执行推理</span></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line">[<span class="keyword">self</span>.interpreter resizeInputTensorAtIndex:<span class="number">0</span> toShape:[<span class="keyword">self</span> getTensorShape] error:&amp;error];</span><br><span class="line">TFLTensor *inputTensor = [<span class="keyword">self</span>.interpreter inputTensorAtIndex:<span class="number">0</span> error:&amp;error];</span><br><span class="line">[inputTensor copyData:imageData error:&amp;error];</span><br><span class="line">[<span class="keyword">self</span>.interpreter invokeWithError:&amp;error];</span><br><span class="line">TFLTensor *outputTensor = [<span class="keyword">self</span>.interpreter outputTensorAtIndex:<span class="number">0</span> error:&amp;error];</span><br><span class="line"><span class="built_in">NSData</span> *outputData = [outputTensor dataWithError:&amp;error];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续解析数据</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *resultDict = [<span class="keyword">self</span> detectWithTensorOutputData:outputData imageSize:sizeOrigin];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Error++: %@&quot;</span>, error);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">self</span>.cachedOutput = resultDict;</span><br><span class="line"><span class="keyword">self</span>.cachedMat = matOrigin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resultDict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 解析推理数据</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)detectWithTensorOutputData:(<span class="built_in">NSData</span> *)outputData imageSize:(<span class="built_in">CGSize</span>)imageSize &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算像素总数</span></span><br><span class="line"><span class="type">int</span> inputWidth = <span class="keyword">self</span>.model.modelSize.width;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> inputHeight = <span class="keyword">self</span>.model.modelSize.height;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num_pixels = inputHeight * inputWidth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意OpenCV 里面Mat的初始化是 高 * 宽 * 通道数</span></span><br><span class="line">cv::Mat out_mask(inputHeight, inputWidth, CV_8UC1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> *output = (<span class="keyword">const</span> <span class="type">float</span> *)outputData.bytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历每个像素并填充 out_mask 这个计算有问题的 实际是会有不同概率分布的数据 不是非0即1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_pixels; i++) &#123;</span><br><span class="line">out_mask.data[i] = (output[<span class="number">2</span> * i + <span class="number">1</span>] &gt; <span class="number">0.1</span>f) ? <span class="number">255</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 腐蚀 这个优化改为交给GPUImage处理 不再使用cv</span></span><br><span class="line"><span class="comment">// cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));</span></span><br><span class="line"><span class="comment">// cv::erode(outputMat, outputMat, element);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯模糊 进行边缘优化 这个优化改为交给GPUImage处理 不再使用cv</span></span><br><span class="line"><span class="comment">// cv::GaussianBlur(out_mask, out_mask, cv::Size(3, 3), 0, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mask图再放大</span></span><br><span class="line">cv::Mat outputMat;</span><br><span class="line">cv::resize(out_mask, outputMat, cv::Size(imageSize.width, imageSize.height));</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIImage</span> *outputImage = [UGTFliteUtil imageFromCVMat:outputMat];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> @&#123;<span class="string">@&quot;image&quot;</span>:outputImage, <span class="string">@&quot;imageWidth&quot;</span>:@(imageSize.width),<span class="string">@&quot;imageHeight&quot;</span>:@(imageSize.height)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isCacheAvailable &#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">self</span>.cachedMat.empty() &amp;&amp; <span class="keyword">self</span>.cachedOutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>核心渲染代码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 背景模糊滤镜组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;GPUImage.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;GPUImageThreeInputFilter.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;UGImageBackgroundBlurFilter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> kUGImagePortraitMaskBlendFragmentShaderString = SHADER_STRING</span><br><span class="line">(</span><br><span class="line">precision highp <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line">varying highp vec2 textureCoordinate;</span><br><span class="line">varying highp vec2 textureCoordinate2;</span><br><span class="line">varying highp vec2 textureCoordinate3;</span><br><span class="line"></span><br><span class="line">uniform sampler2D inputImageTexture;</span><br><span class="line">uniform sampler2D inputImageTexture2;</span><br><span class="line">uniform sampler2D inputImageTexture3;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);</span><br><span class="line">vec4 blurredColor = texture2D(inputImageTexture2, textureCoordinate2);</span><br><span class="line">vec4 maskColor = texture2D(inputImageTexture3, textureCoordinate3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预乘Alpha</span></span><br><span class="line">baseColor.rgb *= baseColor.a;</span><br><span class="line">blurredColor.rgb *= blurredColor.a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 maskColor 的灰度值计算混合的透明度通道</span></span><br><span class="line"><span class="type">float</span> maskValue = dot(maskColor.rgb, vec3(<span class="number">0.299</span>, <span class="number">0.587</span>, <span class="number">0.114</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平滑处理边界像素值</span></span><br><span class="line"><span class="type">float</span> smoothMaskValue = smoothstep(<span class="number">0.0</span>, <span class="number">1.0</span>, maskValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合颜色</span></span><br><span class="line">vec4 mixedColor = mix(blurredColor, baseColor, smoothMaskValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除预乘Alpha</span></span><br><span class="line"><span class="keyword">if</span> (mixedColor.a &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">mixedColor.rgb /= mixedColor.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gl_FragColor = mixedColor;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UGImagePortraitMaskBlendFilter</span> : <span class="title">GPUImageThreeInputFilter</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UGImagePortraitMaskBlendFilter</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="variable language_">super</span> initWithFragmentShaderFromString:kUGImagePortraitMaskBlendFragmentShaderString];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="comment">// 初始化滤镜</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UGImageBackgroundBlurFilter</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) GPUImageGaussianBlurFilter *blurFilter;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) UGImagePortraitMaskBlendFilter *blendInputFilter;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UGImageBackgroundBlurFilter</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line"><span class="comment">// 初始化高斯模糊滤镜</span></span><br><span class="line"><span class="keyword">self</span>.blurFilter = [[GPUImageGaussianBlurFilter alloc] init];</span><br><span class="line"><span class="keyword">self</span>.blurFilter.blurRadiusInPixels = <span class="number">31</span>;</span><br><span class="line">[<span class="keyword">self</span> addFilter:<span class="keyword">self</span>.blurFilter];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化混合三输入滤镜</span></span><br><span class="line"><span class="keyword">self</span>.blendInputFilter = [[UGImagePortraitMaskBlendFilter alloc] init];</span><br><span class="line">[<span class="keyword">self</span> addFilter:<span class="keyword">self</span>.blendInputFilter];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置滤镜链</span></span><br><span class="line">[<span class="keyword">self</span>.blurFilter addTarget:<span class="keyword">self</span>.blendInputFilter atTextureLocation:<span class="number">1</span>];</span><br><span class="line">[<span class="keyword">self</span> setInitialFilters:@[<span class="keyword">self</span>.blurFilter, <span class="keyword">self</span>.blendInputFilter]];</span><br><span class="line">[<span class="keyword">self</span> setTerminalFilter:<span class="keyword">self</span>.blendInputFilter];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setMaskImage:(<span class="built_in">UIImage</span> *)maskImage &#123;</span><br><span class="line"><span class="comment">// 腐蚀 + 高斯模糊进行边缘优化</span></span><br><span class="line">GPUImagePicture *maskImageSource = [[GPUImagePicture alloc] initWithImage:maskImage];</span><br><span class="line">GPUImageErosionFilter *erosionFilter = [[GPUImageErosionFilter alloc] initWithRadius:<span class="number">3</span>];</span><br><span class="line">GPUImageGaussianBlurFilter *blurFilter = [[GPUImageGaussianBlurFilter alloc] init];</span><br><span class="line">blurFilter.blurRadiusInPixels = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">[maskImageSource addTarget:erosionFilter];</span><br><span class="line">[erosionFilter addTarget:blurFilter];</span><br><span class="line">[blurFilter addTarget:<span class="keyword">self</span>.blendInputFilter atTextureLocation:<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">[erosionFilter useNextFrameForImageCapture];</span><br><span class="line">[blurFilter useNextFrameForImageCapture];</span><br><span class="line">[maskImageSource processImage];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="端侧优化"><a href="#端侧优化" class="headerlink" title="端侧优化"></a>端侧优化</h4><p>在实现的过程中发现一些问题，从APP侧做了一些优化。</p><h5 id="边缘优化"><a href="#边缘优化" class="headerlink" title="边缘优化"></a>边缘优化</h5><p>模型计算出来的mask图像的黑白分界比较明显（像素点非1即0），视觉效果上在背景和人像的分界处有较清晰的边界落差。</p><p>针对这个问题我们在使用推理出来的mask进入片元着色器遴选像素之前先过了一次7个像素的高斯模糊滤镜，将mask图的边缘的锋利区域抹平。</p><p>边缘高斯模糊后分界不再过于明显，人像周围会存在一圈透明和半透明交织的光圈。</p><p>光圈的半径大小取决于模型推理出来的mask图的尺寸，掩码图越大越精细，光圈越小越贴近真实的人像。（和小图片放大会变马赛克同样原理）</p><h5 id="边缘腐蚀"><a href="#边缘腐蚀" class="headerlink" title="边缘腐蚀"></a>边缘腐蚀</h5><p>经过边缘优化人像区域分界点弱化后发现人像周围的透明光圈会漏出一些背景信息。</p><p>为了降低漏出的背景信息，我们在高斯模糊之前对掩码图做了一次3像素的腐蚀，将人像区域向内收缩。</p><h5 id="插值优化"><a href="#插值优化" class="headerlink" title="插值优化"></a>插值优化</h5><p>结合我们的AI作业的录制场景，APP端对两帧之间变化不超过96.5%的不再执行推理，可以一定程度上提高录制的帧率。</p><p>该阈值经过一些测试得出，其效果为别的部位和背景不变，仅面部口型发生变化，其两帧之间的差距小于3.5%。</p><h5 id="帧缓存"><a href="#帧缓存" class="headerlink" title="帧缓存"></a>帧缓存</h5><p>推理模型存在报错的可能，每一帧推理成功完成后都会缓存该推理结果。</p><p>如果当前帧推理报错则会使用上一帧的结果，避免出现模糊失效暴露完整背景信息的情况。</p><h4 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h4><p><strong>向内腐蚀导致人像边缘缺失</strong></p><p>手指区域有时候会出现识别误差导致手指区域比较细小，因为向内腐蚀而出现手指被腐蚀掉的问题。</p><p><strong>帧率低</strong></p><p>端上录制的同时做了过多滤镜方面的工作，同时处理背景模糊和人脸美颜，性能较低。</p><p>不开背景模糊能跑满30pfs，开了背景模糊会降低到10-15fps。</p><p><strong>模型识别精度不足</strong></p><p>识别精度难以达到产品预期。当前模型尺寸较小，如果换高精度模型会进一步降低帧率，视频会卡。</p><h3 id="Vision-模型"><a href="#Vision-模型" class="headerlink" title="Vision 模型"></a>Vision 模型</h3><p>Vision 是 Apple 在 WWDC 2017 推出的图像识别框架。Vision库里本身就已经自带了很多训练好的Core ML模型，人脸识别、条形码检测等等功能。</p><p>如果你要实现的功能刚好是Vision库本身就能实现的，那么你直接使用Vision库自带的一些类和方法就行，但是如果想要更强大的功能，那么还是需要结合其它Core ML模型。</p><p>Apple 官方也提供了人像分割的模型VNGeneratePersonSegmentationRequest，需要iOS 15.0 以上系统可以使用该API。</p><h4 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">15.0</span>, *)) &#123;</span><br><span class="line">CVPixelBufferRef pixelBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer);</span><br><span class="line"><span class="keyword">if</span> (!pixelBuffer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VNGeneratePersonSegmentationRequest *request = [[VNGeneratePersonSegmentationRequest alloc] init];</span><br><span class="line"><span class="comment">// 决定使用高质量的mask还是高速度的mask</span></span><br><span class="line">request.qualityLevel = VNGeneratePersonSegmentationRequestQualityLevelAccurate;</span><br><span class="line">request.outputPixelFormat = kCVPixelFormatType_OneComponent8;</span><br><span class="line"><span class="comment">// 推理产生mask</span></span><br><span class="line">VNImageRequestHandler *requestHandler = [[VNImageRequestHandler alloc] initWithCVPixelBuffer:pixelBuffer options:@&#123;&#125;];</span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">[requestHandler performRequests:@[request] error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Failed to perform segmentation request: %@&quot;</span>, error);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VNPixelBufferObservation *mask = (VNPixelBufferObservation *)request.results.firstObject;</span><br><span class="line"><span class="keyword">if</span> (mask) &#123;</span><br><span class="line"><span class="built_in">CIImage</span> *ciImage = [<span class="built_in">CIImage</span> imageWithCVPixelBuffer:mask.pixelBuffer];</span><br><span class="line"><span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> context];</span><br><span class="line"><span class="built_in">CGImageRef</span> cgImage = [context createCGImage:ciImage fromRect:ciImage.extent];</span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:cgImage];</span><br><span class="line"><span class="built_in">CGImageRelease</span>(cgImage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">self</span>.getDevicePostion == <span class="built_in">AVCaptureDevicePositionFront</span>) &#123;</span><br><span class="line">image = [<span class="keyword">self</span> flipImageVertically:image];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行渲染</span></span><br><span class="line">[<span class="keyword">self</span>.filter setBlurBackgroundMaskImage:image];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;VNGeneratePersonSegmentationRequest is not available on this iOS version.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们项目支持到iOS 10.0 所以使用原生模型是有局限性的。</p><p>另外如果使用高精度模型VNGeneratePersonSegmentationRequestQualityLevelAccurate，其运行速度也比较慢。</p><p>如果使用精度和速度相平衡的模型则其识别效果未经过产品验证无法确定是否达到需求。</p><h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><h3 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h3><p>AI考虑提升模型运算效率和推理精度，由AI团队调研和研发。</p><h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><p>根据模型推理精度来决定是否移除掉腐蚀逻辑，保证人像区域完整。</p><p>检测多个滤镜链合并时候的效率，根据结果决定是否需要分离美颜和背景模糊滤镜。</p><p>使用帧采样做mask基准，尽量减少模型推理次数。</p><p>采样多个模型，根据帧率动态降级。</p><h3 id="采用iOS-Vision-推理框架-工程化优化"><a href="#采用iOS-Vision-推理框架-工程化优化" class="headerlink" title="采用iOS Vision 推理框架 工程化优化"></a>采用iOS Vision 推理框架 工程化优化</h3><p>采用 VNGeneratePersonSegmentationRequestQualityLevelBalanced 档位的人像分割模型，效果可以接受。</p><p>测试机 iOS 15.2 iPhone 11</p><p>2024-11-29 15:53:32.273863+0800 [5274:3232793] 开始推理 1732866812.273805</p><p>2024-11-29 15:53:32.300939+0800 [5274:3232793] 推理完成 1732866812.300908</p><p>2024-11-29 15:53:32.309572+0800 [5274:3232793] 转图片完成 1732866812.309538</p><p>人像分割推理用时 27.1 ms  转图片用时 8.5 ms</p><p>当前FPS 为 15 每一帧视频用时 66.67ms</p><p>人像分割大概需要在原始耗时的基础上增加35 ms</p><p>不开人像分割可以达到设置的最佳帧率 30 FPS。</p><p>排查其他用时详情：</p><p>2024-11-29 16:54:07.306245+0800 [5358:3254717] 开始应用滤镜 1732870447.306170</p><p>2024-11-29 16:54:07.310206+0800 [5358:3254717] 应用滤镜完成 1732870447.310165</p><p>合成图像及边缘优化的滤镜用时 4ms 优化空间较小</p><p>主要优化方向还是在人像分割推理上</p><p>采用差值优化，帧相似度小于某个值才进行检测</p><p>差值计算带来额外的性能消耗，如果计算出来需要检测，则检测用时需要追加差值计算的时间消耗，如果计算出来不需要检测，就节省了一次推理时间。</p><p>如果差值计算消耗数量级远远小于人像分割推理 则效果比较明显。</p><p>2024-11-29 18:01:49.232560+0800 [5457:3292643] 开始计算差值 1732874509.232429</p><p>2024-11-29 18:01:49.237739+0800 [5457:3292643] 完成计算差值 1732874509.237706</p><p>计算差值需要 5ms</p><p>在差值2.5%的基准上，如果人像动作幅度较小则帧率提升到20-25左右。</p><p>插值基准越大，则帧率提升越明显，但是对人像分割的效果会有负面影响（<strong>有残影</strong>）。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/Jason_Lee155/article/details/121216691">OpenGL ES几个概念-顶点着色器、片元着色器、EG</a></p><p><a href="https://learnopengl-cn.github.io/">OpenGL学习教程</a></p><p><a href="https://www.nxrte.com/jishu/38561.html">人像分割技术有哪些？</a></p><p><a href="https://cloud.tencent.com/developer/article/1077019">Vision 图像识别框架</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS背景模糊实现技术方案&quot;&gt;&lt;a href=&quot;#iOS背景模糊实现技术方案&quot; class=&quot;headerlink&quot; title=&quot;iOS背景模糊实现技术方案&quot;&gt;&lt;/a&gt;iOS背景模糊实现技术方案&lt;/h1&gt;&lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot;</summary>
      
    
    
    
    <category term="技术分享" scheme="https://zcx4u.github.io/categories/tech-sharing/"/>
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/tags/ios/"/>
    
    <category term="图像处理" scheme="https://zcx4u.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="AI" scheme="https://zcx4u.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>iOS端 ASR优化</title>
    <link href="https://zcx4u.github.io/2024/05/20/iOS%E7%AB%AF%20ASR%E4%BC%98%E5%8C%96/"/>
    <id>https://zcx4u.github.io/2024/05/20/iOS%E7%AB%AF%20ASR%E4%BC%98%E5%8C%96/</id>
    <published>2024-05-19T16:00:00.000Z</published>
    <updated>2025-03-18T07:16:59.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS端-ASR优化"><a href="#iOS端-ASR优化" class="headerlink" title="iOS端 ASR优化"></a>iOS端 ASR优化</h1><h1 id="ASR-Automatic-Speech-Recognition"><a href="#ASR-Automatic-Speech-Recognition" class="headerlink" title="ASR(Automatic Speech Recognition)"></a>ASR(Automatic Speech Recognition)</h1><p>ASR是一种将语音信号转换为文本的技术，它可以帮助人们更方便地与计算机进行交互。我们的AI作业小节在录制过程中会同步调用ASR服务商实时将用户录制的语音转成为文字，在录制完成后根据ASR结果计算流畅度、语速评分，在上传作业的时候将ASR结果同时上传到服务端进行AI分析。</p><p>可见AI作业的流畅度维度评分、语速维度评分和AI分析报告中的关键词分析、口头禅分析、停顿分析都是建立在获得准确的ASR结果上的。所以构建一个准确可靠的语音识别服务是AI作业小节的基本要求，也是AI作业小节的分析准确度和用户满意度的关键。</p><h1 id="ASR-存在的问题"><a href="#ASR-存在的问题" class="headerlink" title="ASR 存在的问题"></a>ASR 存在的问题</h1><h2 id="热词-词库问题"><a href="#热词-词库问题" class="headerlink" title="热词&#x2F;词库问题"></a>热词&#x2F;词库问题</h2><p>ASR服务需要手工校准一些生僻专业词语的发音或同音词识别，这也就意味着需要ASR服务商提供词库&#x2F;热词功能，同时对不同的用户&#x2F;企业甚至每一次ASR识别过程都可能需要不同的热词。</p><p><strong>解决方案:</strong></p><p>针对CN、CO、COM&#x2F;TW&#x2F;IO 这三个环境平台，调研支持热词的服务商并测试效果。CN 采用了阿里听悟，CO采用了AmiVoice，COM&#x2F;TW&#x2F;IO 会采用微软。</p><h2 id="Socket连接稳定性问题"><a href="#Socket连接稳定性问题" class="headerlink" title="Socket连接稳定性问题"></a>Socket连接稳定性问题</h2><p><strong>并发控制</strong></p><p>目前采用的几家服务商对实时语音识别的技术方案都是使用Socket将录制采集的音频数据推流到厂商的服务端进行实时识别。每家厂商对并发数控制都是不同的，如果新的Socket请求达到最大并发数量会无法连接到服务商。（这个问题可以通过联系服务商提高并发数量上限来解决，但是并不能无限提高）。</p><p><strong>网络波动</strong></p><p>端上发起的Socket连接的稳定性是不可靠的容易受到短时通讯质量波动影响导致超时断连。</p><p><strong>断线重连？</strong></p><p>由于流畅度以及停顿分析强依赖ASR返回的断句结果和Word偏移时间，断连之后重连的断句结果中的起始时间重置为0从而导致停顿分析和流畅度打分不准。并且服务商有并发数控制，重连也不一定能连上。</p><p>如果不考虑并发控制直接重连，本地维护录制的绝对时间，仅依赖ASR结果中的相对时间去拼接完整时间轴也是有问题的。因为ASR结果中存在整句和单词的断句，这个断句依赖连续的音频输入。如果服务断开连接后我们本地存储音频数据，重连后再次进行识别，这样拿到的结果的断句一定是错误的（一定会有物理中断的特征断句）。</p><p>所以Google Voice v1的识别一直存在一个问题，Google v1（iOS）目前会每60s中断重连一次，即使用户在此时间点无停顿，其识别结果也会在每个60s处都有一个断句。非连续的数据一定会出现异常的停顿，对结果影响非常大会导致流畅度分析不可用。后续会针对COM&#x2F;TW&#x2F;IO站点切换微软语音识别来解决这个问题。</p><p><strong>断连时用户无感知，直接影响提交作业主流程</strong></p><p>目前ASR发生了断连或不可用问题用户是较难感知的（只有文字识别是否显示的区别），并且直接影响此次录制的流畅度和语速评分（无数据会显示一团迷雾）。如果讲师开启了提交作业最低分限制会直接导致该次录制无法提交，用户回到“上传视频作业”流程比较远，可能会间接导致该次录制作废，业务主流程卡死，十分影响用户体验。</p><p><strong>解决方案</strong></p><p>考虑通过增加一些兜底的交互将出现ASR连接错误的作业从实时录制流程快速导向到上传流程。使用服务端异步分析为端上实时连接做一次兜底（用户如果对当次录制的作业比较满意可以选择直接提交到服务端走上传流程，如果不满意可能会自行重录）。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="支持热词功能"><a href="#支持热词功能" class="headerlink" title="支持热词功能"></a>支持热词功能</h2><p>中文：听悟 支持临时热词列表</p><p>日文：Ami 支持临时热词列表和热词词库</p><p>英文及其他：微软 支持临时热词</p><p>当前支持以企业为维度配置热词列表，在服务端维护</p><p>未来可以支持以作业为维度配置热词列表</p><h2 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h2><p>在往期的基础上丰富了日志上报。</p><p>在常规的各个服务商Socket或者SDK的关键生命周期（初始化、开始识别、停止识别等）和返回错误信息的关键节点增加kibana日志上报。</p><p>增加一个30s为周期的心跳日志，记录识别到的稳态结果文本长度，表示ASR服务仍然在正常运行。</p><h2 id="错误降级"><a href="#错误降级" class="headerlink" title="错误降级"></a>错误降级</h2><p>如上方断线的解决方案，增加检测到ASR报错时增加服务端兜底机制。</p><h2 id="支持切换站点和语言使用不同ASR服务"><a href="#支持切换站点和语言使用不同ASR服务" class="headerlink" title="支持切换站点和语言使用不同ASR服务"></a>支持切换站点和语言使用不同ASR服务</h2><p>切换语言：</p><p>目前的技术方案已经支持根据不同站点的阿波罗配置下的根据语言下发ASR服务平台类型，APP根据对应的类型启动ASR服务。</p><p>切换站点：</p><p>当前iOS项目中ASR服务按照包来区分，每个站点引入的SDK是不同的。</p><p>CN包 阿里，AMi</p><p>CO包 AMi ，Google， 微软</p><p>COM AMi ，Google ，微软</p><p>有些SDK因为合规问题不可以接入特定包  711 只有Google ASR</p><p>UASR、腾讯、AMI、微软  这四个ASR服务支持切换站点 根据对应站点下发的类型即可调起对应的服务</p><p>在CN包还保留了阿里ASR兜底，别的包使用微软ASR兜底</p><p>如果下发的ASR服务在当前包是缺失的则会使用兜底</p><p>iOS 会在2024.10 尝试将不同站点用到的ASR SDK 全部引入当前包中，实现切换站点就可以切换服务的功能。（安卓已经合并到一个包中。）</p><p>风险点在于新引入腾讯ASRSDK 加 引入多个SDK会使包体积增大，</p><p>合并前 打包 CN Debug 模式下 219MB</p><p>合并后打包 CN Debug 模式 219Mb</p><p>基本无影响</p><h2 id="日志设计"><a href="#日志设计" class="headerlink" title="日志设计"></a>日志设计</h2><p>ASR服务提升可观测性，在以下生命周期进行日志监测。</p><p>所有ASR的日志都以 <strong>UMUASRService</strong> 为key，在kibana搜索这个key过滤ASR问题。</p><p>准备阶段：</p><p>获取ASR配置失败时会上报 refreshASRGlobalConfig fail</p><p>启动服务：</p><p>buildASRService的时候打一次 携带服务端下发的平台类型</p><p>初始化服务失败会打一次日志，不同Service 根据SDK初始化方式打的时机不同</p><p>buildASRService完成后打一次，携带APP实际采用的ASR类型（根据类名区分）</p><p>服务进行中：</p><p>正常场景→ 在收到稳态识别结果后每30s 上报一次ASR服务心跳日志，携带当次识别结果的文本长度。增加心跳的目的是监控ASR服务是否正常持续运行</p><p>异常场景→ 收到ASR服务商SDK、Server回调的错误上报错误代码和信息日志</p><p>服务结束：</p><p>打一次结束日志</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS端-ASR优化&quot;&gt;&lt;a href=&quot;#iOS端-ASR优化&quot; class=&quot;headerlink&quot; title=&quot;iOS端 ASR优化&quot;&gt;&lt;/a&gt;iOS端 ASR优化&lt;/h1&gt;&lt;h1 id=&quot;ASR-Automatic-Speech-Recognition&quot;</summary>
      
    
    
    
    <category term="iOS开发" scheme="https://zcx4u.github.io/categories/ios-development/"/>
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/tags/ios/"/>
    
    <category term="性能优化" scheme="https://zcx4u.github.io/tags/performance/"/>
    
    <category term="架构设计" scheme="https://zcx4u.github.io/tags/architecture/"/>
    
    <category term="asr" scheme="https://zcx4u.github.io/tags/asr/"/>
    
    <category term="语音识别" scheme="https://zcx4u.github.io/tags/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT使用技巧手册</title>
    <link href="https://zcx4u.github.io/2024/01/15/ChatGPT%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%89%8B%E5%86%8C/"/>
    <id>https://zcx4u.github.io/2024/01/15/ChatGPT%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%89%8B%E5%86%8C/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2025-03-18T06:58:12.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ChatGPT使用技巧手册"><a href="#ChatGPT使用技巧手册" class="headerlink" title="ChatGPT使用技巧手册"></a>ChatGPT使用技巧手册</h1><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E6%A0%B8%E5%BF%83%E6%8A%80%E5%B7%A7">核心技巧</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E9%87%8D%E6%9E%84">代码优化与重构</a></li><li><a href="#%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86">多语言处理</a></li><li><a href="#%E5%BC%80%E5%8F%91%E8%BE%85%E5%8A%A9">开发辅助</a></li><li><a href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%80%82%E9%85%8D">跨平台适配</a></li><li><a href="#%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8">扩展应用</a></li></ul><hr><h2 id="核心技巧"><a href="#核心技巧" class="headerlink" title="核心技巧"></a>核心技巧</h2><h3 id="Prompt生成方法论"><a href="#Prompt生成方法论" class="headerlink" title="Prompt生成方法论"></a>Prompt生成方法论</h3><ol><li><p><strong>多Prompt生成</strong></p><ul><li>通过生成多个prompt迭代优化输出质量</li><li>示例流程：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成初始Prompt → 评估结果 → 生成改进Prompt → 最终优化</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>角色扮演</strong></p><ul><li>作为超级语言解释器（处理复杂语义）</li><li>作为提示词训练器（生成领域专用Prompt）</li></ul></li><li><p><strong>格式规范</strong></p><ul><li>强制JSON&#x2F;YAML结构化输出</li><li>表格化数据呈现</li></ul></li></ol><hr><h2 id="代码优化与重构"><a href="#代码优化与重构" class="headerlink" title="代码优化与重构"></a>代码优化与重构</h2><h3 id="10大即时代码重构技巧"><a href="#10大即时代码重构技巧" class="headerlink" title="10大即时代码重构技巧"></a>10大即时代码重构技巧</h3><table><thead><tr><th>优化方向</th><th>典型操作</th><th>适用场景</th></tr></thead><tbody><tr><td>性能优化</td><td>算法复杂度分析</td><td>循环结构</td></tr><tr><td>兼容性</td><td>多语言语法适配</td><td>跨平台项目</td></tr><tr><td>可维护性</td><td>模块化拆分</td><td>大型工程</td></tr></tbody></table><p><strong>重构步骤示例：</strong></p><ol><li>使用最新库版本替换过时代码</li><li>将ArrayList改为ConcurrentHashMap（数据结构优化）</li><li>添加try-with-resources错误处理</li></ol><hr><h2 id="多语言处理"><a href="#多语言处理" class="headerlink" title="多语言处理"></a>多语言处理</h2><h3 id="多语种翻译工作流"><a href="#多语种翻译工作流" class="headerlink" title="多语种翻译工作流"></a>多语种翻译工作流</h3><p><strong>关键注意事项：</strong></p><ul><li>使用 <code>LANG_CODE</code>作为字典key</li><li>保留原始文本占位符（如 <code>&#123;0&#125;</code>）</li><li>优先处理数字&#x2F;日期格式</li></ul><hr><h2 id="开发辅助"><a href="#开发辅助" class="headerlink" title="开发辅助"></a>开发辅助</h2><h3 id="测试驱动开发（TDD）"><a href="#测试驱动开发（TDD）" class="headerlink" title="测试驱动开发（TDD）"></a>测试驱动开发（TDD）</h3><ol><li><p><strong>UT生成</strong></p><ul><li>输入：方法签名 + 边界条件</li><li>输出：JUnit&#x2F;TestNG测试套件</li><li>覆盖率分析建议</li></ul></li><li><p><strong>Mock数据生成</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;##number(1,100)&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;##name.fullName&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="跨平台适配"><a href="#跨平台适配" class="headerlink" title="跨平台适配"></a>跨平台适配</h2><h3 id="iOS布局转换"><a href="#iOS布局转换" class="headerlink" title="iOS布局转换"></a>iOS布局转换</h3><p><strong>Objective-C框架迁移流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 原始Frame布局</span><br><span class="line">CGRectMake(10, 20, 30, 40);</span><br><span class="line"></span><br><span class="line">// Masonry转换后</span><br><span class="line">make.top.equalTo(20);</span><br><span class="line">make.left.equalTo(10);</span><br><span class="line">make.width.equalTo(30);</span><br><span class="line">make.height.equalTo(40);</span><br></pre></td></tr></table></figure><p><strong>优化建议：</strong></p><ul><li>将布局逻辑拆分为 <code>setupConstraints</code>方法</li><li>使用 <code>MAS_SHORTHAND</code>简化语法</li></ul><hr><h2 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a>扩展应用</h2><h3 id="Figma-ChatGPT协作"><a href="#Figma-ChatGPT协作" class="headerlink" title="Figma+ChatGPT协作"></a>Figma+ChatGPT协作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">frame Figma设计稿 &#123;</span><br><span class="line">  component 图层结构</span><br><span class="line">  component 样式参数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frame ChatGPT &#123;</span><br><span class="line">  component 设计规范解析</span><br><span class="line">  component 代码生成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Figma设计稿 --&gt; ChatGPT : 导出设计规范</span><br><span class="line">ChatGPT --&gt; 前端工程 : 生成组件代码</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="实用资源"><a href="#实用资源" class="headerlink" title="实用资源"></a>实用资源</h3><ul><li><a href="https://www.aishort.top/?tags=code">Prompt精选库</a></li><li>Recharts数据可视化库</li><li>Lucide React图标集</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ChatGPT使用技巧手册&quot;&gt;&lt;a href=&quot;#ChatGPT使用技巧手册&quot; class=&quot;headerlink&quot; title=&quot;ChatGPT使用技巧手册&quot;&gt;&lt;/a&gt;ChatGPT使用技巧手册&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录</summary>
      
    
    
    
    <category term="技术" scheme="https://zcx4u.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="AIGC" scheme="https://zcx4u.github.io/tags/AIGC/"/>
    
    <category term="ChatGPT" scheme="https://zcx4u.github.io/tags/ChatGPT/"/>
    
    <category term="开发工具" scheme="https://zcx4u.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 开发者技术路线图（2025 年）</title>
    <link href="https://zcx4u.github.io/2024/01/01/%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%9B%BE/"/>
    <id>https://zcx4u.github.io/2024/01/01/%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%9B%BE/</id>
    <published>2023-12-31T16:00:00.000Z</published>
    <updated>2025-03-18T03:29:36.537Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理了iOS开发者所需掌握的核心技能和学习路径，帮助开发者规划职业发展。</p><hr><h2 id="🌟-基础能力"><a href="#🌟-基础能力" class="headerlink" title="🌟 基础能力"></a>🌟 基础能力</h2><h3 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1. 编程语言"></a>1. 编程语言</h3><ul><li><strong>Swift</strong><ul><li>掌握语法基础（变量、控制流、函数、闭包）</li><li>深入理解 <code>Optional</code>、泛型、协议、<code>async/await</code></li><li>学习 Swift Concurrency（<code>Task</code>、<code>Actor</code>、<code>Sendable</code>）</li></ul></li><li><strong>Objective-C（可选）</strong><ul><li>理解与 Swift 的混编机制</li><li>阅读遗留代码库的兼容性</li></ul></li></ul><h3 id="2-开发工具"><a href="#2-开发工具" class="headerlink" title="2. 开发工具"></a>2. 开发工具</h3><ul><li><strong>Xcode</strong><ul><li>熟练使用 Interface Builder、Storyboard&#x2F;XIB</li><li>掌握 LLDB 调试、Instruments 性能分析</li><li>熟悉 Swift Package Manager（SPM）依赖管理</li></ul></li><li><strong>终端工具</strong><ul><li>基础 Shell 命令（<code>xcodebuild</code>、<code>xcrun</code>）</li><li>Fastlane 自动化（构建、测试、发布）</li></ul></li></ul><hr><h2 id="🎨-UI-UX-开发"><a href="#🎨-UI-UX-开发" class="headerlink" title="🎨 UI&#x2F;UX 开发"></a>🎨 UI&#x2F;UX 开发</h2><h3 id="1-原生框架"><a href="#1-原生框架" class="headerlink" title="1. 原生框架"></a>1. 原生框架</h3><ul><li><strong>UIKit</strong><ul><li>Auto Layout 与自适应布局</li><li>核心组件（<code>UITableView</code>、<code>UICollectionView</code>）</li><li>自定义视图与动画（<code>CALayer</code>、<code>UIViewPropertyAnimator</code>）</li></ul></li><li><strong>SwiftUI</strong><ul><li>声明式语法与数据绑定（<code>@State</code>、<code>@Binding</code>）</li><li>复杂布局（<code>Grid</code>、<code>LazyVStack</code>）</li><li>跨平台适配（iOS&#x2F;macOS&#x2F;watchOS）</li></ul></li></ul><h3 id="2-设计规范"><a href="#2-设计规范" class="headerlink" title="2. 设计规范"></a>2. 设计规范</h3><ul><li><strong>Human Interface Guidelines</strong><ul><li>遵循 Apple 设计原则（交互、图标、动效）</li><li>适配不同设备尺寸（iPhone&#x2F;iPad&#x2F;折叠屏）</li><li>无障碍支持（VoiceOver、动态字体）</li></ul></li></ul><hr><h2 id="🔗-网络与数据"><a href="#🔗-网络与数据" class="headerlink" title="🔗 网络与数据"></a>🔗 网络与数据</h2><h3 id="1-网络请求"><a href="#1-网络请求" class="headerlink" title="1. 网络请求"></a>1. 网络请求</h3><ul><li><strong>URLSession</strong><ul><li>实现 RESTful API 调用（GET&#x2F;POST&#x2F;DELETE）</li><li>处理后台下载&#x2F;上传任务</li><li>优化缓存策略（<code>URLCache</code>、<code>NSURLCache</code>）</li></ul></li><li><strong>Alamofire（第三方库）</strong><ul><li>封装网络层（拦截器、请求重试）</li><li>结合 Combine&#x2F;Swift Concurrency</li></ul></li></ul><h3 id="2-数据存储"><a href="#2-数据存储" class="headerlink" title="2. 数据存储"></a>2. 数据存储</h3><ul><li><strong>Core Data</strong><ul><li>数据模型设计与版本迁移</li><li>性能优化（批量操作、预取）</li></ul></li><li><strong>SwiftData（推荐）</strong><ul><li>声明式数据管理（<code>@Model</code> 宏）</li><li>与 SwiftUI 深度集成</li></ul></li><li><strong>Realm&#x2F;GRDB（可选）</strong><ul><li>替代数据库方案对比</li></ul></li></ul><hr><h2 id="⚡-性能优化"><a href="#⚡-性能优化" class="headerlink" title="⚡ 性能优化"></a>⚡ 性能优化</h2><h3 id="1-关键指标"><a href="#1-关键指标" class="headerlink" title="1. 关键指标"></a>1. 关键指标</h3><ul><li><strong>启动时间优化</strong><ul><li>冷启动&#x2F;热启动分析</li><li>减少动态库加载（<code>dyld</code> 优化）</li></ul></li><li><strong>内存管理</strong><ul><li>检测循环引用（<code>weak</code>、<code>unowned</code>）</li><li>使用 Memory Graph Debugger</li></ul></li><li><strong>渲染性能</strong><ul><li>解决掉帧问题（<code>CADisplayLink</code> 监测）</li><li>离屏渲染优化（<code>cornerRadius</code> 替代方案）</li></ul></li></ul><h3 id="2-工具链"><a href="#2-工具链" class="headerlink" title="2. 工具链"></a>2. 工具链</h3><ul><li><strong>Instruments</strong><ul><li>Time Profiler 定位 CPU 瓶颈</li><li>Allocations 分析内存泄漏</li></ul></li><li><strong>Xcode Metrics</strong><ul><li>监控线上用户性能数据（电池、卡顿率）</li></ul></li></ul><hr><h2 id="🧪-测试与调试"><a href="#🧪-测试与调试" class="headerlink" title="🧪 测试与调试"></a>🧪 测试与调试</h2><h3 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1. 单元测试"></a>1. 单元测试</h3><ul><li><strong>XCTest 框架</strong><ul><li>编写可维护的测试用例</li><li>覆盖率分析（Xcode Coverage）</li></ul></li><li><strong>Snapshot Testing（第三方）</strong><ul><li>验证 UI 一致性（iOSSnapshotTestCase）</li></ul></li></ul><h3 id="2-调试技巧"><a href="#2-调试技巧" class="headerlink" title="2. 调试技巧"></a>2. 调试技巧</h3><ul><li><strong>断点高级用法</strong><ul><li>条件断点、符号断点</li><li>LLDB 命令（<code>po</code>、<code>expression</code>）</li></ul></li><li><strong>Proxyman&#x2F;Charles</strong><ul><li>抓包分析与 Mock 数据</li></ul></li></ul><hr><h2 id="🏗️-架构设计"><a href="#🏗️-架构设计" class="headerlink" title="🏗️ 架构设计"></a>🏗️ 架构设计</h2><h3 id="1-主流模式"><a href="#1-主流模式" class="headerlink" title="1. 主流模式"></a>1. 主流模式</h3><ul><li><strong>MVVM</strong><ul><li>结合 Combine&#x2F;Swift Concurrency</li><li>双向数据绑定（<code>@Published</code>）</li></ul></li><li><strong>VIPER（复杂场景）</strong><ul><li>模块化拆分（Router&#x2F;Interactor）</li></ul></li><li><strong>TCA（The Composable Architecture）</strong><ul><li>状态管理（<code>Reducer</code>、<code>Store</code>）</li></ul></li></ul><h3 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h3><ul><li><strong>SOLID 原则</strong><ul><li>单一职责、依赖倒置</li></ul></li><li><strong>DI（依赖注入）</strong><ul><li>使用 Swinject&#x2F;Factory 框架</li></ul></li></ul><hr><h2 id="🌐-跨平台技术"><a href="#🌐-跨平台技术" class="headerlink" title="🌐 跨平台技术"></a>🌐 跨平台技术</h2><h3 id="1-混合开发"><a href="#1-混合开发" class="headerlink" title="1. 混合开发"></a>1. 混合开发</h3><ul><li><strong>Flutter（推荐）</strong><ul><li>使用 Dart 构建跨端 UI</li><li>与原生模块通信（Platform Channel）</li></ul></li><li><strong>React Native（可选）</strong><ul><li>JavaScript 桥接原生能力</li></ul></li></ul><h3 id="2-苹果生态扩展"><a href="#2-苹果生态扩展" class="headerlink" title="2. 苹果生态扩展"></a>2. 苹果生态扩展</h3><ul><li><strong>watchOS&#x2F;tvOS</strong><ul><li>开发配套应用（HealthKit&#x2F;HomeKit）</li></ul></li><li><strong>CarPlay</strong><ul><li>车载系统适配指南</li></ul></li></ul><hr><h2 id="🚀-进阶领域"><a href="#🚀-进阶领域" class="headerlink" title="🚀 进阶领域"></a>🚀 进阶领域</h2><h3 id="1-新技术"><a href="#1-新技术" class="headerlink" title="1. 新技术"></a>1. 新技术</h3><ul><li><strong>AR&#x2F;VR</strong><ul><li>使用 ARKit 开发沉浸式体验</li></ul></li><li><strong>机器学习</strong><ul><li>Core ML 模型集成（图像分类、NLP）</li></ul></li><li><strong>Swift 编译器插件</strong><ul><li>自定义宏（<code>@freestanding</code>、<code>@attached</code>）</li></ul></li></ul><h3 id="2-工程化"><a href="#2-工程化" class="headerlink" title="2. 工程化"></a>2. 工程化</h3><ul><li><strong>CI&#x2F;CD</strong><ul><li>GitHub Actions&#x2F;Bitrise 流水线搭建</li><li>TestFlight 分发与管理</li></ul></li><li><strong>App Store 上架</strong><ul><li>审核避坑指南（隐私政策、元数据）</li></ul></li></ul><hr><h2 id="📚-持续学习"><a href="#📚-持续学习" class="headerlink" title="📚 持续学习"></a>📚 持续学习</h2><h3 id="1-资源推荐"><a href="#1-资源推荐" class="headerlink" title="1. 资源推荐"></a>1. 资源推荐</h3><ul><li><strong>官方文档</strong><ul><li><a href="https://developer.apple.com/">Apple Developer</a></li><li>WWDC 视频（年度新技术解析）</li></ul></li><li><strong>书籍</strong><ul><li>《Swift 进阶》</li><li>《Combine 异步编程》</li></ul></li><li><strong>社区</strong><ul><li>Swift 论坛、iOS Dev Weekly</li></ul></li></ul><h3 id="2-实践建议"><a href="#2-实践建议" class="headerlink" title="2. 实践建议"></a>2. 实践建议</h3><ul><li><strong>开源贡献</strong><ul><li>Alamofire&#x2F;SwiftUI 源码阅读</li></ul></li><li><strong>个人项目</strong><ul><li>开发完整上架应用（从 0 到 1 闭环）</li></ul></li></ul><hr><blockquote><p><strong>提示</strong>：技术路线需根据个人目标动态调整，建议每半年复盘一次技能树 🎯</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文整理了iOS开发者所需掌握的核心技能和学习路径，帮助开发者规划职业发展。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🌟-基础能力&quot;&gt;&lt;a href=&quot;#🌟-基础能力&quot; class=&quot;headerlink&quot; title=&quot;🌟 基础能力&quot;&gt;&lt;/a&gt;🌟 基础能力&lt;/h2&gt;&lt;h</summary>
      
    
    
    
    <category term="技术" scheme="https://zcx4u.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/tags/ios/"/>
    
    <category term="职业发展" scheme="https://zcx4u.github.io/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
    <category term="学习路径" scheme="https://zcx4u.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>常见算法考题列表（2025 年整理）</title>
    <link href="https://zcx4u.github.io/2024/01/01/%E7%AE%97%E6%B3%95/"/>
    <id>https://zcx4u.github.io/2024/01/01/%E7%AE%97%E6%B3%95/</id>
    <published>2023-12-31T16:00:00.000Z</published>
    <updated>2025-03-18T03:29:36.539Z</updated>
    
    <content type="html"><![CDATA[<hr><p>本文整理了常见的算法面试题目，包括数据结构、基础算法和高级算法等多个方面的典型题目。</p><hr><h2 id="📚-数据结构与基础算法"><a href="#📚-数据结构与基础算法" class="headerlink" title="📚 数据结构与基础算法"></a>📚 <strong>数据结构与基础算法</strong></h2><h3 id="1-数组与链表"><a href="#1-数组与链表" class="headerlink" title="1. 数组与链表"></a>1. <strong>数组与链表</strong></h3><ul><li><strong>两数之和</strong>题目：在数组中找出和为 <code>target</code> 的两个元素的下标。考察点：哈希表、空间换时间优化:cite[3]:cite[7]</li><li><strong>合并两个有序链表</strong>题目：将两个升序链表合并为一个新链表。考察点：指针操作、递归&#x2F;迭代实现:cite[3]:cite[7]</li><li><strong>反转链表</strong><br>题目：将单链表反转（迭代或递归实现）。<br>考察点：指针操作、递归思维:cite[2]:cite[7]</li></ul><h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. <strong>字符串</strong></h3><ul><li><strong>最长回文子串</strong>题目：找到字符串中的最长回文子串。考察点：中心扩散法、动态规划:cite[2]:cite[7]</li><li><strong>第一个不重复的字符</strong>题目：找到字符串中第一个只出现一次的字符的下标。考察点：哈希表统计频率:cite[7]</li><li><strong>版本号排序</strong><br>题目：将版本号数组按从大到小排序（如 <code>[&#39;10.2.1&#39;, &#39;0.402.1&#39;]</code>）。<br>考察点：字符串分割、多级比较:cite[7]</li></ul><h3 id="3-树与图"><a href="#3-树与图" class="headerlink" title="3. 树与图"></a>3. <strong>树与图</strong></h3><ul><li><strong>对称二叉树</strong>题目：判断二叉树是否镜像对称。考察点：递归遍历、层序遍历:cite[3]:cite[7]</li><li><strong>二叉树的中序遍历</strong>题目：实现非递归中序遍历。考察点：栈的应用、Morris 遍历:cite[2]:cite[7]</li><li><strong>克隆图</strong><br>题目：深度拷贝无向连通图。<br>考察点：DFS&#x2F;BFS、哈希表记录已访问节点:cite[3]</li></ul><hr><h2 id="⚙️-高级算法与优化"><a href="#⚙️-高级算法与优化" class="headerlink" title="⚙️ 高级算法与优化"></a>⚙️ <strong>高级算法与优化</strong></h2><h3 id="1-排序与搜索"><a href="#1-排序与搜索" class="headerlink" title="1. 排序与搜索"></a>1. <strong>排序与搜索</strong></h3><ul><li><strong>快速排序</strong>题目：实现快速排序并分析时间复杂度。考察点：分治思想、基准选择优化:cite[1]:cite[7]</li><li><strong>二分查找</strong>题目：在有序数组中查找目标值的位置。考察点：边界条件处理、循环不变量:cite[1]:cite[7]</li><li><strong>第 K 个最大元素</strong><br>题目：在未排序数组中找到第 K 大的元素。<br>考察点：快速选择算法、堆排序:cite[3]</li></ul><h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. <strong>动态规划</strong></h3><ul><li><strong>最长递增子序列</strong>题目：求数组中最长严格递增子序列的长度。考察点：状态转移方程、二分优化:cite[3]:cite[7]</li><li><strong>背包问题</strong>题目：0-1 背包问题的动态规划解法。考察点：二维 DP 表、空间压缩:cite[4]:cite[8]</li><li><strong>编辑距离</strong><br>题目：计算将字符串 A 转换为 B 的最小操作次数（增&#x2F;删&#x2F;改）。<br>考察点：二维 DP、状态转移方程:cite[7]</li></ul><h3 id="3-贪心与回溯"><a href="#3-贪心与回溯" class="headerlink" title="3. 贪心与回溯"></a>3. <strong>贪心与回溯</strong></h3><ul><li><strong>跳跃游戏</strong>题目：判断能否从数组起点跳到终点（每步最大跳跃长度为 <code>nums[i]</code>）。考察点：贪心策略、最大覆盖范围:cite[7]</li><li><strong>全排列</strong>题目：生成数组的所有排列组合。考察点：回溯算法、剪枝优化:cite[7]</li><li><strong>组合总和</strong><br>题目：找出数组中所有和为 <code>target</code> 的组合（元素可重复使用）。<br>考察点：回溯、去重技巧:cite[7]</li></ul><hr><h2 id="🧩-系统设计与场景题"><a href="#🧩-系统设计与场景题" class="headerlink" title="🧩 系统设计与场景题"></a>🧩 <strong>系统设计与场景题</strong></h2><h3 id="1-数据结构设计"><a href="#1-数据结构设计" class="headerlink" title="1. 数据结构设计"></a>1. <strong>数据结构设计</strong></h3><ul><li><strong>LRU 缓存</strong>题目：设计基于 LRU 策略的缓存，支持 <code>get</code> 和 <code>put</code> 操作。考察点：哈希表 + 双向链表:cite[2]:cite[7]</li><li><strong>最小栈</strong><br>题目：实现一个支持 <code>push</code>、<code>pop</code>、<code>top</code> 及 <code>getMin</code> 的栈。<br>考察点：辅助栈或差值存储:cite[3]</li></ul><h3 id="2-场景问题"><a href="#2-场景问题" class="headerlink" title="2. 场景问题"></a>2. <strong>场景问题</strong></h3><ul><li><strong>会议室安排</strong>题目：给定多个会议时间区间，判断能否全部安排。考察点：区间排序、重叠检测:cite[7]</li><li><strong>接雨水</strong><br>题目：计算柱子高度数组能接多少雨水。<br>考察点：双指针、动态规划或单调栈:cite[7]</li></ul><hr><h2 id="📈-复杂度与优化"><a href="#📈-复杂度与优化" class="headerlink" title="📈 复杂度与优化"></a>📈 <strong>复杂度与优化</strong></h2><ul><li><strong>时间复杂度分析</strong>常见阶：O(1)、O(n)、O(n²)、O(nlogn) 等，需结合代码解释:cite[4]:cite[8]</li><li><strong>空间复杂度优化</strong><br>例如：原地排序、滚动数组、位运算压缩状态:cite[4]:cite[7]</li></ul><hr><blockquote><p><strong>提示</strong>：以上题目覆盖了算法面试 80% 的高频考点，建议结合 LeetCode 或《剑指 Offer》进行针对性练习。<br><strong>完整题目与代码实现</strong>可参考：<a href="https://blog.csdn.net/Ed7zgeE9X/article/details/132288312">CSDN 算法题整理</a>:cite[7] | <a href="https://leetcode.com/">力扣题库</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;本文整理了常见的算法面试题目，包括数据结构、基础算法和高级算法等多个方面的典型题目。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;📚-数据结构与基础算法&quot;&gt;&lt;a href=&quot;#📚-数据结构与基础算法&quot; class=&quot;headerlink&quot; title=&quot;📚 数据结构与</summary>
      
    
    
    
    <category term="技术" scheme="https://zcx4u.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://zcx4u.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="面试" scheme="https://zcx4u.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="数据结构" scheme="https://zcx4u.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>iOS 面试高频问题总结（2025 最新版）</title>
    <link href="https://zcx4u.github.io/2024/01/01/%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/"/>
    <id>https://zcx4u.github.io/2024/01/01/%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/</id>
    <published>2023-12-31T16:00:00.000Z</published>
    <updated>2025-03-18T03:29:36.541Z</updated>
    
    <content type="html"><![CDATA[<hr><p>本文总结了iOS开发面试中的高频问题，涵盖语言基础、框架应用、性能优化等多个方面。</p><hr><h2 id="🎯-语言基础（Swift）"><a href="#🎯-语言基础（Swift）" class="headerlink" title="🎯 语言基础（Swift）"></a>🎯 语言基础（Swift）</h2><ol><li><p><strong>值类型 vs 引用类型</strong></p><ul><li>结构体&#x2F;枚举与类的本质区别？</li><li>如何选择 <code>struct</code> 和 <code>class</code> 的使用场景？</li></ul></li><li><p><strong>协议与泛型</strong></p><ul><li><code>associatedtype</code> 的作用是什么？</li><li>如何实现类型擦除（Type Erasure）？</li></ul></li><li><p><strong>内存管理</strong></p><ul><li>解释 <code>weak</code>、<code>unowned</code>、<code>strong</code> 的区别</li><li>如何检测和解决循环引用问题？</li></ul></li><li><p><strong>Swift Concurrency</strong></p><ul><li><code>async/await</code> 与 Combine 框架的适用场景对比</li><li><code>Sendable</code> 协议的作用与实现要求</li></ul></li></ol><hr><h2 id="🖥️-iOS-框架"><a href="#🖥️-iOS-框架" class="headerlink" title="🖥️ iOS 框架"></a>🖥️ iOS 框架</h2><h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h3><ol><li><p><strong>生命周期</strong></p><ul><li><code>viewDidLoad</code> 和 <code>viewWillAppear</code> 的区别</li><li>如何正确管理视图控制器的内存？</li></ul></li><li><p><strong>布局与渲染</strong></p><ul><li>Auto Layout 性能优化技巧</li><li>解释 <code>drawRect</code> 与 <code>layoutSubviews</code> 的调用时机</li></ul></li><li><p><strong>响应链与手势</strong></p><ul><li>描述 iOS 事件传递机制（Hit-Testing）</li><li>如何实现自定义手势识别器？</li></ul></li></ol><h3 id="SwiftUI"><a href="#SwiftUI" class="headerlink" title="SwiftUI"></a>SwiftUI</h3><ol><li><p><strong>状态管理</strong></p><ul><li><code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code> 的区别</li><li>如何实现跨视图状态共享？</li></ul></li><li><p><strong>性能优化</strong></p><ul><li><code>LazyVStack</code> 与 <code>VStack</code> 的性能差异</li><li>如何避免 SwiftUI 视图的无效重绘？</li></ul></li></ol><hr><h2 id="💡-设计模式与架构"><a href="#💡-设计模式与架构" class="headerlink" title="💡 设计模式与架构"></a>💡 设计模式与架构</h2><ol><li><p><strong>MVVM 实现</strong></p><ul><li>如何设计双向数据绑定（结合 Combine&#x2F;Swift Concurrency）？</li><li>ViewModel 与 Service 层的职责划分</li></ul></li><li><p><strong>依赖注入</strong></p><ul><li>手动依赖注入 vs 框架（如 Swinject）的优劣</li><li>如何在单元测试中应用 DI？</li></ul></li><li><p><strong>模块化设计</strong></p><ul><li>如何解耦巨型单体工程？</li><li>动态化方案（二进制化&#x2F;插件化）的实现思路</li></ul></li></ol><hr><h2 id="⚙️-性能优化"><a href="#⚙️-性能优化" class="headerlink" title="⚙️ 性能优化"></a>⚙️ 性能优化</h2><ol><li><p><strong>启动优化</strong></p><ul><li>冷启动阶段各进程的加载顺序</li><li>如何减少动态库加载时间？</li></ul></li><li><p><strong>内存优化</strong></p><ul><li>使用 Instruments 定位内存泄漏的步骤</li><li><code>NSCache</code> 与 <code>URLCache</code> 的最佳实践</li></ul></li><li><p><strong>渲染性能</strong></p><ul><li>如何检测和解决掉帧问题？</li><li>离屏渲染的常见场景与优化方案</li></ul></li></ol><hr><h2 id="🌐-网络与存储"><a href="#🌐-网络与存储" class="headerlink" title="🌐 网络与存储"></a>🌐 网络与存储</h2><ol><li><p><strong>HTTP&#x2F;2 与 QUIC</strong></p><ul><li>对比 HTTP&#x2F;1.1 的核心改进点</li><li>iOS 如何支持 QUIC 协议？</li></ul></li><li><p><strong>数据持久化</strong></p><ul><li>Core Data 与 SwiftData 的架构差异</li><li>多线程环境下 Realm 的使用注意事项</li></ul></li><li><p><strong>安全机制</strong></p><ul><li>如何防止中间人攻击（MITM）？</li><li>Keychain 数据存储的加密原理</li></ul></li></ol><hr><h2 id="🔄-多线程与并发"><a href="#🔄-多线程与并发" class="headerlink" title="🔄 多线程与并发"></a>🔄 多线程与并发</h2><ol><li><p><strong>GCD 高级用法</strong></p><ul><li><code>dispatch_barrier_async</code> 的应用场景</li><li>如何创建可取消的 DispatchWorkItem？</li></ul></li><li><p><strong>OperationQueue</strong></p><ul><li>如何实现任务依赖与优先级控制？</li><li>对比 GCD 的优劣</li></ul></li><li><p><strong>Actor 模型</strong></p><ul><li>Swift Actor 如何保证线程安全？</li><li><code>nonisolated</code> 关键字的用途</li></ul></li></ol><hr><h2 id="🧪-测试与调试"><a href="#🧪-测试与调试" class="headerlink" title="🧪 测试与调试"></a>🧪 测试与调试</h2><ol><li><p><strong>单元测试</strong></p><ul><li>如何对异步代码进行测试？</li><li>依赖注入在测试中的应用</li></ul></li><li><p><strong>UI 自动化</strong></p><ul><li>XCUITest 的核心组件与使用限制</li><li>如何实现跨语言自动化测试（Appium）</li></ul></li><li><p><strong>Crash 分析</strong></p><ul><li>符号化崩溃日志的完整流程</li><li>如何捕获并上报野指针异常？</li></ul></li></ol><hr><h2 id="🧠-系统设计题"><a href="#🧠-系统设计题" class="headerlink" title="🧠 系统设计题"></a>🧠 系统设计题</h2><ol><li><p><strong>架构设计</strong></p><ul><li>设计一个支持 LRU 缓存的图片加载库</li><li>实现一个支持断点续传的下载管理器</li></ul></li><li><p><strong>场景方案</strong></p><ul><li>如何保证弱网环境下消息的可靠传输？</li><li>设计一个即时通讯应用的消息同步机制</li></ul></li></ol><hr><h2 id="💻-算法与数据结构"><a href="#💻-算法与数据结构" class="headerlink" title="💻 算法与数据结构"></a>💻 算法与数据结构</h2><ol><li><p><strong>高频算法</strong></p><ul><li>链表反转（迭代&#x2F;递归）</li><li>二叉树层序遍历</li><li>最长无重复子串</li></ul></li><li><p><strong>优化思维</strong></p><ul><li>两数之和的多种解法对比（哈希表&#x2F;双指针）</li><li>动态规划解决背包问题</li></ul></li></ol><hr><blockquote><p><strong>提示</strong>：每个问题建议延伸思考：</p><ul><li>该技术点的底层原理（如 Runtime 机制）</li><li>实际项目中的实践案例</li><li>不同方案的优缺点对比</li></ul></blockquote><p><strong>注</strong>：结合最新 iOS 19 特性（如 Vision Pro 开发）准备差异化答案 🚀</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;本文总结了iOS开发面试中的高频问题，涵盖语言基础、框架应用、性能优化等多个方面。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;🎯-语言基础（Swift）&quot;&gt;&lt;a href=&quot;#🎯-语言基础（Swift）&quot; class=&quot;headerlink&quot; title=&quot;🎯 语言</summary>
      
    
    
    
    <category term="技术" scheme="https://zcx4u.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/tags/ios/"/>
    
    <category term="知识点" scheme="https://zcx4u.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    <category term="面试" scheme="https://zcx4u.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>iOS签名机制</title>
    <link href="https://zcx4u.github.io/2022/11/05/iOS%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/"/>
    <id>https://zcx4u.github.io/2022/11/05/iOS%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</id>
    <published>2022-11-04T16:00:00.000Z</published>
    <updated>2025-03-12T11:44:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS签名机制"><a href="#iOS签名机制" class="headerlink" title="iOS签名机制"></a>iOS签名机制</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在iOS开发中，配置证书总是一件繁琐的工作，网上的教程有很多，基本都是手把手的教操作，但是如果不了解为什么要配置这些东西，对配置流程就不会有深刻的印象。</p><p>配置证书最大的作用就是保证安全性，安全性主要表现在以下的几个方面：</p><p>1.保证苹果手机下载的App是从<strong>苹果官网认证</strong>的途径下载</p><p>2.保证App在苹果官方注册过的设备上运行</p><p>3.保证App在特定的设备中运行（开发需要）</p><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p>苹果采用的是<strong>数字签名</strong>进行加密，它是基于<strong>非对称加密算法和摘要算法</strong>实现的，和对称加密算法不同的是**，**对称加密通过同一份密钥加密和解密数据，而非对称加密有两个密钥，分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密；用私钥加密的数据，要用公钥才能解密。这里的非对称加密就是我们熟知的RSA，想要深入理解的童鞋可以自主了解。</p><p>为了更好的理解非对称加密的好处，我举一个场景例子：A要发送邮件给B，这个过程中要确保在传输中邮件内容没有被篡改，也就是只有B可以查看邮件的内容；还要确保这个邮件是A发送过来的，不是其他人发送的。我们用非对称加密的方式来处理：首先存A和B各有一对公私钥，A持有他自己的私钥和B的公钥，B持有A的公钥和B的私钥，公钥一般是给别人的，私钥在自己手里。A先用B的公钥给邮件加密，这样这个邮件只能被B的私钥解开，保证在传输过程中不会被篡改；A用自己的私钥将邮件加密，B要用A的公钥将邮件解密，来确保这是A发送过来的。这就是双向验证。</p><h2 id="基于iOS开发的签名机制"><a href="#基于iOS开发的签名机制" class="headerlink" title="基于iOS开发的签名机制"></a>基于iOS开发的签名机制</h2><h3 id="从App-Store安装App"><a href="#从App-Store安装App" class="headerlink" title="从App Store安装App"></a>从App Store安装App</h3><p>这个签名的方式相对简单，只需要验证App是从AppStore上下载的即可。苹果官方生成一对公私钥，在苹果设备上内置一个公钥，私钥由后台保管，我们上传App到AppStore时，苹果后台用私钥对App进行签名，设备在在App包后，用内置公钥验证签名。</p><p>思考：每个设备和苹果后台都有对应的一对公私钥还是只有一对公私钥，每个设备的公钥都是一样的，如果是前者，给App用私钥加密的时候是什么时候？</p><p><strong>结论：所有苹果设备上的公钥都是一样的。</strong></p><h3 id="其他方式安装App"><a href="#其他方式安装App" class="headerlink" title="其他方式安装App"></a>其他方式安装App</h3><ul><li>通过Xcode将App运行在设备上，调试用</li><li>企业内部分发，可以直接安装企业证书签名后的App</li><li>AD-Hoc相当于企业分发的限制版，限制安装设备数量</li></ul><p>以上几种场景就比较复杂了，我们需要确保这个App包的来源是苹果官方认证的，还要指定设备信息（不能随便的苹果设备都可以运行）。在了解这些场景的签名过程之前我们先思考一些问题：</p><p>1.App包不能上传到App Store上进行私钥加密了，需要通过其他介质间接验证；</p><p>2.iPhone上只有一个公钥可用，如何验证这么多信息；</p><p>3.如何限制设备、权限等额外信息。</p><p>我们需要除了App包以外的信息来进行验证，就是各种加密之后的文件，所以我们需要配置很多的证书。</p><h3 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h3><p>1.在mac上生成一对公私钥，公钥M，私钥M，苹果后台和苹果设备有一对公私钥，公钥A，私钥A。</p><p>2.将公钥M上传到苹果后台，用苹果后台的私钥A签名公钥M得到了公钥M的签名，代称hashM(私A)，hashM(私A)和公钥M组成的数据称为<strong>证书</strong>。（证书携带苹果官方认证信息，需要和App到达设备上）</p><p>3.开发完成后，用私钥M对App进行签名，同时将证书一起打包进App中，安装到手机。</p><p>4.安装时，iOS系统获得证书，用公钥A验证hashM(私A），得到的信息和证书中的公钥是否一致。</p><p><strong>以上的流程可以完成验证App是否经过了苹果官方认可的需求，没有解决滥用的问题。<strong>这里的滥用问题包括任何App都可以用这个证书在任何设备上安装运行，这是不允许的。我们可以把这些限制信息如AppID、设备ID等和证书</strong>再用私钥A进行加密</strong>，在最后的iOS系统验证的时候就可以判断这些限制数据是否符合要求。可以理解为又进行了一次加密。得到的数据就是我们知道的<strong>Provisioning file</strong>，Provisioning file里面就包含了证书和以上提到的额外信息，以及所有信息的签名。</p><p>在编译一个App后，用本地的的私钥M对这个App进行签名，同时把Provisioning file文件打包到App中，文件名为embeded.mobileprovision，把App安装到手机上。以上的过程就是加密的过程，看起来加密了很多层，让我们来梳理一下：</p><p><img src="https://cdn.zcx.info/1553500434698-48c63da0-2fac-490f-9b24-a5944fb17ae8.png"></p><h2 id="配置证书简要流程"><a href="#配置证书简要流程" class="headerlink" title="配置证书简要流程"></a>配置证书简要流程</h2><h3 id="请求根证书"><a href="#请求根证书" class="headerlink" title="请求根证书"></a>请求根证书</h3><p>在mac上生成一对公私钥，并将公钥上传到苹果后台，用苹果后台的私钥加密mac公钥，得到证书</p><p>CSR生成一对公私钥，私钥始终在Mac OS的Keychain Access中，用于签名（CodeSign）对外发布的App，公钥一般随着证书（随Provisioning Profile，随App）散布出去，对App签名进行校验认证。用户要保护好本地Keychain中的private key。</p><p>创建CSR文件：打开钥匙串-&gt;证书助理-&gt;从证书颁发机构请求证书。注：CRS文件是Cerificate Signing Request的英文缩写，即证书请求文件，<strong>CerificateSigningRequest就是本地公钥，.p12就是本地私钥，可以导入其他电脑，同时其他电脑也应该安装下载下来的证书。所以这一步团队开发人员很少操作。</strong></p><h3 id="添加设备"><a href="#添加设备" class="headerlink" title="添加设备"></a>添加设备</h3><p>苹果严格限制了真机调试的设备，如果需要真机调试需要在<a href="https://developer.apple.com/account/resources/devices/list">开发者后台</a>添加测试机的UDID</p><p><img src="https://cdn.zcx.info/202302211647247.png"></p><h3 id="新增描述文件"><a href="#新增描述文件" class="headerlink" title="新增描述文件"></a>新增描述文件</h3><p>描述文件(Provisioning Profile)是一个记录了你这个App的功能和权限的证书。</p><p>一般会用到以下三种：</p><p><strong>develop:调试证书，包含调试信息，安装时需要证书已加入设备UDID或者越狱设备才能安装。</strong></p><p><strong>distribution：正式证书，屏蔽了调试信息，发布到AppStore所用。</strong></p><p><strong>ad-hoc：测试证书，需要给别人测试用到，允许用户从第三方下载应用，如蒲公英。</strong></p><h2 id="刷新证书及描述文件"><a href="#刷新证书及描述文件" class="headerlink" title="刷新证书及描述文件"></a>刷新证书及描述文件</h2><p>一般在重新请求根证书之后需要更新所有的描述文件内的根证书配置。</p><p>根证书和证书对应的私钥都需要有人进行维护(或者使用fastlane维护)，在团队新增成员、设备时需发放到对应的机器中的钥匙串内，否则无法进行构建和上传IPA。</p><p>描述文件更新后需要在Xcode的User设置中找到开发者刷新一下Profile，或者到Profile的保存文件夹内清空重新下载，以避免描述文件更新不及时问题导致CI&#x2F;CD构建失败。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS签名机制&quot;&gt;&lt;a href=&quot;#iOS签名机制&quot; class=&quot;headerlink&quot; title=&quot;iOS签名机制&quot;&gt;&lt;/a&gt;iOS签名机制&lt;/h1&gt;&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="学习笔记" scheme="https://zcx4u.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 从入门到放弃</title>
    <link href="https://zcx4u.github.io/2022/07/06/SwiftUI/"/>
    <id>https://zcx4u.github.io/2022/07/06/SwiftUI/</id>
    <published>2022-07-05T16:00:00.000Z</published>
    <updated>2025-03-13T09:54:06.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.zcx.info/e6c9d24ely1h4461xrrg2j211906rjrv.jpg" alt="SWiftUITitleImage"></p><h2 id="什么是SwiftUI"><a href="#什么是SwiftUI" class="headerlink" title="什么是SwiftUI"></a>什么是SwiftUI</h2><p>SwiftUI 于 2019 年度 WWDC 全球开发者大会上发布，它是基于 Swift 建立的声明式UI框架。</p><p>该框架可以用于 watchOS、tvOS、macOS、iOS 等平台的应用开发，等于说统一了苹果生态圈的开发工具。</p><blockquote><p>SwiftUI provides views, controls, and layout structures for declaring your app’s user interface. The framework provides event handlers for delivering taps, gestures, and other types of input to your app, and tools to manage the flow of data from your app’s models down to the views and controls that users will see and interact with.</p></blockquote><h2 id="SwiftUI-Hello-World"><a href="#SwiftUI-Hello-World" class="headerlink" title="SwiftUI Hello World"></a>SwiftUI Hello World</h2><p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">创建新项目并预览画布</a></p><p>和平时创建新项目流程基本一致。只需要选择Swift UI Interface即可。</p><p><img src="https://cdn.zcx.info/e6c9d24ely1h36ny2yym8j213002fmx4.jpg" alt="2"></p><p>工程初始化创建完毕后可以看到文件结构如下：</p><p><img src="https://cdn.zcx.info/e6c9d24ely1h36o3x0gvgj207h04lglm.jpg" alt="3"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="title class_">SwiftUIClient</span></span><br><span class="line">│   ├── <span class="title class_">Assets</span>.xcassets /<span class="regexp">/ 素材文件夹</span></span><br><span class="line"><span class="regexp">│   │   ├── AccentColor.colorset</span></span><br><span class="line"><span class="regexp">│   │   │   └── Contents.json</span></span><br><span class="line"><span class="regexp">│   │   ├── AppIcon.appiconset</span></span><br><span class="line"><span class="regexp">│   │   │   └── Contents.json</span></span><br><span class="line"><span class="regexp">│   │   └── Contents.json</span></span><br><span class="line"><span class="regexp">│   ├── ContentView.swift /</span><span class="regexp">/ 默认view</span></span><br><span class="line"><span class="regexp">│   ├── Preview Content</span></span><br><span class="line"><span class="regexp">│   │   └── Preview Assets.xcassets</span></span><br><span class="line"><span class="regexp">│   │       └── Contents.json</span></span><br><span class="line"><span class="regexp">│   └── SwiftUIClientApp.swift /</span><span class="regexp">/ APP入口文件</span></span><br><span class="line"><span class="regexp">└── SwiftUIClient.xcodeproj </span></span><br><span class="line"><span class="regexp">    ├── project.pbxproj</span></span><br><span class="line"><span class="regexp">    └── xcuserdata</span></span><br><span class="line"><span class="regexp">        └── pxcm-0101-01-0246.xcuserdatad</span></span><br><span class="line"><span class="regexp">            └── xcschemes</span></span><br><span class="line"><span class="regexp">                └── xcschememanagement.plist</span></span><br></pre></td></tr></table></figure><h2 id="main"><a href="#main" class="headerlink" title="@main"></a>@main</h2><p>找到APP入口文件<code>SwiftUIClientApp.swift</code>中的<code>@main</code>标记<br>根据经验APP会从@main入口启动开始执行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SwiftUIClientApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">ContentView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会遇到三个新的结构: App, Scene, WindowGroup</p><h3 id="App-Protocol"><a href="#App-Protocol" class="headerlink" title="App Protocol"></a>App Protocol</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">14.0</span>, <span class="keyword">macOS</span> <span class="number">11.0</span>, <span class="keyword">tvOS</span> <span class="number">14.0</span>, <span class="keyword">watchOS</span> <span class="number">7.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">App</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过声明符合<code>App</code>协议的结构来创建应用程序。实现所需的<a href="https://developer.apple.com/documentation/swiftui/app/body-swift.property"><code>body</code></a>计算属性来定义应用程序的内容。</p><p>在结构声明之前加上<a href="https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#ID626">@main</a>属性，表明您的自定义<code>App</code>协议符合者提供了应用程序的入口点。<a href="https://developer.apple.com/documentation/swiftui/app/main()"><code>main()</code></a>该协议提供了系统调用以启动您的应用程序的方法的默认实现。在所有应用程序文件中只可以有一个入口点。</p><p>可以简单理解为APP的外壳&#x2F;容器</p><h3 id="Scene-Protocol"><a href="#Scene-Protocol" class="headerlink" title="Scene Protocol"></a>Scene Protocol</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">14.0</span>, <span class="keyword">macOS</span> <span class="number">11.0</span>, <span class="keyword">tvOS</span> <span class="number">14.0</span>, <span class="keyword">watchOS</span> <span class="number">7.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Scene</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以<a href="https://developer.apple.com/documentation/swiftui/app"><code>App</code></a>通过组合一个或多个符合<code>Scene</code>应用程序中协议的实例来创建<a href="https://developer.apple.com/documentation/swiftui/app/body-swift.property"><code>body</code></a>. 您可以使用 SwiftUI 提供的内置场景，例如，以及您从其他场景中组合的自定义场景。要创建自定义场景，请声明符合协议的类型。实现所需的计算属性并为您的自定义场景提供内容：<a href="https://developer.apple.com/documentation/swiftui/windowgroup"><code>WindowGroup</code></a><code>Scene</code><a href="https://developer.apple.com/documentation/swiftui/scene/body-swift.property"><code>body</code></a></p><p>场景是视图（View）层次结构的容器。通过在App实例的body中组合一个或多个符合Scene协议的实例来呈现具体程序。</p><ul><li>生命周期由系统管理</li><li>系统会根据运行平台的不同而调整场景的展示行为（比如相同的代码在iOS和macOS下的呈现不同，或者某些场景仅能运行于特定的平台）</li><li>SwiftUI2.0提供了几个预置的场景，用户也可以自己编写符合Scene协议的场景。上述代码中便是使用的一个预置场景WindowGroup</li></ul><p>可以简单理解为多窗口模式下的某一个窗口(iPad&#x2F;Mac)</p><h3 id="WindowGroup-Struct"><a href="#WindowGroup-Struct" class="headerlink" title="WindowGroup Struct"></a>WindowGroup Struct</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">14.0</span>, <span class="keyword">macOS</span> <span class="number">11.0</span>, <span class="keyword">tvOS</span> <span class="number">14.0</span>, <span class="keyword">watchOS</span> <span class="number">7.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">WindowGroup</span>&lt;<span class="type">Content</span>&gt; : <span class="type">Scene</span> <span class="keyword">where</span> <span class="type">Content</span> : <span class="type">View</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的Scene，可以呈现一组结构相同的窗口。使用该场景，我们无需在代码上做修改，只需要在项目中设定是否支持多窗口，系统将会按照运行平台的特性自动管理。</p><p>如果在一个WindowGroup里加入多个View,呈现状态有点类似VStack。从上到下依排列</p><p>在一个Scene中加入多个WindowGroup，只有最前面的可以被显示。</p><h2 id="View-Protocol-和常用控件"><a href="#View-Protocol-和常用控件" class="headerlink" title="View Protocol 和常用控件"></a>View Protocol 和常用控件</h2><p>SwiftUI使用过程中可以明显感觉到整个APP都是使用一系列View互相嵌套&#x2F;堆叠而成的。</p><p>View 协议是整个UI界面的基础,提供配置界面的各个部分。</p><blockquote><p>A type that represents part of your app’s user interface and provides modifiers that you use to configure views.</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;我是一个设置了蓝底白字行间距5内边距5边框3的Text控件&quot;</span>)</span><br><span class="line">.lineLimit(<span class="number">2</span>)<span class="comment">// 最大2行</span></span><br><span class="line">.font(.largeTitle) <span class="comment">// 字体</span></span><br><span class="line">.foregroundColor(.white)<span class="comment">// 字体颜色</span></span><br><span class="line">.background(.blue) <span class="comment">// 背景颜色</span></span><br><span class="line">.lineSpacing(<span class="number">5</span>) <span class="comment">// 行间距</span></span><br><span class="line">.padding(.all, <span class="number">5</span>) <span class="comment">// 文字和空间间的内边距</span></span><br><span class="line">.border(.blue, width: <span class="number">3</span>)<span class="comment">// 边框</span></span><br><span class="line">.rotationEffect(<span class="type">Angle</span>(degrees: <span class="number">50</span>)) <span class="comment">// 旋转</span></span><br></pre></td></tr></table></figure><p>简单且强大的文本控件,类似于UILabel.可以支持很短的代码设置所需属性</p><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3i0g7vwrdj214w0mjacl.jpg"></image></pre></details><h4 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span>(<span class="string">&quot;输入框&quot;</span>, text: <span class="variable">$value</span>)</span><br><span class="line">.textFieldStyle(.roundedBorder)</span><br><span class="line">.keyboardType(.alphabet)</span><br></pre></td></tr></table></figure><p>相当于UIKit中的UITextField的单行文本输入框.支持banging一个@state修饰的string变量。</p><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3i5s1lrouj214r0mejuw.jpg"></image></pre></details><h4 id="SecureField"><a href="#SecureField" class="headerlink" title="SecureField"></a>SecureField</h4><p>密码输入框,用法和普通的输入框一致</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecureField</span>(<span class="string">&quot;密码输入&quot;</span>, text: <span class="variable">$value</span>)</span><br><span class="line">.textFieldStyle(.roundedBorder)</span><br><span class="line">.keyboardType(.alphabet)</span><br><span class="line">.accentColor(.red)</span><br></pre></td></tr></table></figure><h4 id="TextEditor"><a href="#TextEditor" class="headerlink" title="TextEditor"></a>TextEditor</h4><p>类似UITextView,多行输入文本</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextEditor</span>(text: <span class="variable">$value</span>)</span><br><span class="line">.keyboardType(.default)</span><br><span class="line">.multilineTextAlignment(.leading)</span><br><span class="line">.accentColor(.red)</span><br><span class="line">.foregroundColor(.black)</span><br><span class="line">.background(.gray.opacity(<span class="number">0.3</span>))</span><br><span class="line">.lineSpacing(<span class="number">5</span>)</span><br><span class="line">.frame(maxHeight: <span class="number">500</span>)</span><br><span class="line">.textInputAutocapitalization(.words)</span><br><span class="line">.disableAutocorrection(<span class="literal">true</span> )</span><br><span class="line">.onChange(of: value) &#123; newValue <span class="keyword">in</span></span><br><span class="line">    textCount <span class="operator">=</span> newValue.count <span class="comment">// 输入文本变化监听器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3i8b01bi2j214q0mg437.jpg"></image></pre></details><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><h4 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带边框style的button</span></span><br><span class="line"><span class="type">Button</span>(<span class="string">&quot;不应用边框的按钮样式&quot;</span>)&#123;&#125;.buttonStyle(<span class="type">BorderlessButtonStyle</span>()).padding()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过自定义PrimitiveButtonStyle类来实现一些自定义的button</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PriButton</span>: <span class="title class_ inherited__">PrimitiveButtonStyle</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Body</span> <span class="operator">=</span> <span class="type">Button</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeBody</span>(<span class="params">configuration</span>: <span class="type">Configuration</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        configuration.trigger()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        <span class="type">Button</span>(configuration)</span><br><span class="line">            .background(<span class="type">Color</span>.orange)</span><br><span class="line">            .clipShape(<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">25.0</span>, style: .continuous))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接使用label参数设置自定义view</span></span><br><span class="line"><span class="type">Button</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;click&quot;</span>) <span class="comment">// 事件block</span></span><br><span class="line">&#125; label: &#123;</span><br><span class="line">   <span class="comment">//这里可以放自定义view</span></span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;star&quot;</span>).offset(x: <span class="operator">-</span><span class="number">10</span>, y: <span class="number">0</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;带图标的按钮&quot;</span>)</span><br><span class="line">&#125;.padding()</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3i0k7u9qvj213d0mj42p.jpg"></image></pre></details><h4 id="Menu-PullDownButton"><a href="#Menu-PullDownButton" class="headerlink" title="Menu(PullDownButton)"></a>Menu(<em>PullDownButton</em>)</h4><p>点击弹出选择菜单,可以加在toolbar上或者其他地方,本体是一个Button,也可以是自定义View.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Menu</span>(<span class="string">&quot;menu&quot;</span>) &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Duplicate&quot;</span>, action: duplicate)</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Rename&quot;</span>, action: rename)</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Delete…&quot;</span>, action: delete)</span><br><span class="line">    <span class="type">Menu</span>(<span class="string">&quot;Copy&quot;</span>) &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Copy&quot;</span>, action: <span class="keyword">copy</span>)</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Copy Formatted&quot;</span>, action: copyFormatted)</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Copy Library Path&quot;</span>, action: copyPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.menuStyle(.borderlessButton)</span><br><span class="line"></span><br><span class="line"><span class="type">Menu</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Open in Preview&quot;</span>, action: openInPreview)</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Save as PDF&quot;</span>, action: saveAsPDF)</span><br><span class="line">&#125; label: &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;document&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;PDF&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3i91gt97aj214s0mgn15.jpg"></image></pre></details><h4 id="EditButton"><a href="#EditButton" class="headerlink" title="EditButton"></a>EditButton</h4><p>支持改变整个环境变量中的editMode字段,开启编辑状态后一些系统控件会自动触发状态变化。例如支持删除或者排序的List中的ForEach列表在开启editmode后会显示出List的编辑功能。</p><p>当然,你也可以创建一些支持编辑模式的View,同时也可以监听环境中的editMode。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Environment</span>(\.editMode) <span class="keyword">var</span> editMode</span><br></pre></td></tr></table></figure><p>经常会和toolbar功能共用,在导航条右上角支持编辑模式。</p><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3j3vq77r8j214l0md793.jpg"></image></pre></details><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="List-Section-ForEach"><a href="#List-Section-ForEach" class="headerlink" title="List, Section, ForEach"></a>List, Section, ForEach</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>&#123;</span><br><span class="line">  <span class="type">Section</span>(<span class="string">&quot;水果列表&quot;</span>) &#123;</span><br><span class="line">      <span class="type">ForEach</span>(fruits, id: \.<span class="keyword">self</span>) &#123; fruit <span class="keyword">in</span></span><br><span class="line">          <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(fruit)</span>&quot;</span>)</span><br><span class="line">      &#125;.onMove &#123; indexSet, index <span class="keyword">in</span></span><br><span class="line">          fruits.move(fromOffsets: indexSet, toOffset: index)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="operator">!</span>balls.isEmpty &#123;</span><br><span class="line">      <span class="type">Section</span>(<span class="string">&quot;球类列表&quot;</span>) &#123;</span><br><span class="line">          <span class="type">ForEach</span>(balls, id: \.<span class="keyword">self</span>) &#123; ball <span class="keyword">in</span></span><br><span class="line">              <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(ball)</span>&quot;</span>)</span><br><span class="line">          &#125;.onDelete &#123; indexSet <span class="keyword">in</span></span><br><span class="line">              balls.remove(atOffsets: indexSet)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List类似UIKit中的UITableView,常与ForEach语句一起使用。不像UIKit中繁琐的代理和数据源模式,List是字面含义的View列表,手动将每个VIew排列起来即可。</p><p>当然List也可以直接装填数据源进行列表展示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span>)&#123; i <span class="keyword">in</span></span><br><span class="line">  <span class="type">Text</span>(<span class="string">&quot;id:<span class="subst">\(id)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Section则可理解为UITableView中的SectionHeader和Footer在SwiftUI中的实现.List和Section联合使用可以实现常用的多Section的tableview。</p><p>ForEach语句需求传入的数据拥有唯一标识,针对数组可以直接使用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForEach</span>(array.indices, id: \.<span class="keyword">self</span>)&#123; index <span class="keyword">in</span></span><br><span class="line"> <span class="comment">//some view</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3j3sni4zjj214s0mhtbz.jpg"></image></pre></details><h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>Group用于集合多个视图，对 Group 设置的属性，将作用于每个子视图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Group</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.foregroundColor(.blue)</span><br><span class="line">.font(.caption)</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3rnl7bryaj213o0metbb.jpg"></image></pre></details><h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>Form是SwiftUI的基础控件，如果我们需要显示产品配置、选项、用户输入时，使用Form可以快速搭建出各类表单。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Form</span> &#123;</span><br><span class="line">    <span class="type">Section</span> &#123;</span><br><span class="line">        <span class="type">HStack</span>&#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;star.fill&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;输入的内容:<span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TextField</span>(<span class="string">&quot;输入框的placeholder&quot;</span>, text: <span class="variable">$value</span>)</span><br><span class="line">            .textFieldStyle(.roundedBorder)</span><br><span class="line">            .keyboardType(.alphabet)</span><br><span class="line">            .accentColor(.red)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;一个简单的Form写法,如果我们需要显示产品配置、选项、用户输入时，使用Form可以快速搭建出各类表单,会自动增加内边距&quot;</span>)</span><br><span class="line">            .font(.caption)</span><br><span class="line">            .foregroundColor(.gray)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Section</span>(<span class="string">&quot;另一组内容&quot;</span>) &#123;</span><br><span class="line">        <span class="type">HStack</span>&#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;star&quot;</span>)</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;一个右对齐的文案&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3jl3sied0j214q0mb0w3.jpg"></image></pre></details><h4 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h4><p>在有限空间放较多内容的容器View</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScrollView</span>(.vertical, showsIndicators: <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="type">ForEach</span>(list, id:\.<span class="keyword">self</span>) &#123; item <span class="keyword">in</span></span><br><span class="line">        <span class="type">Text</span>(item).padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3jbr3uhfej214s0mfjy1.jpg"></image></pre></details><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h4 id="VStack-HStack"><a href="#VStack-HStack" class="headerlink" title="VStack,HStack"></a>VStack,HStack</h4><p>VStack类似UIStackView,属于布局修饰符,其中包裹的view会按照一定的规则进行垂直方向的自动布局。</p><p>同理HStack会在水平方向自动布局,二者可叠加嵌套。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;垂直方向左对齐&quot;</span>).border(.blue, width: <span class="number">1</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;设置的两个label&quot;</span>).border(.blue, width: <span class="number">1</span>)</span><br><span class="line">    <span class="type">HStack</span>(alignment: .center, spacing: <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;嵌套一个水平方向的HStack&quot;</span>).border(.blue, width: <span class="number">1</span>)</span><br><span class="line">        <span class="type">Spacer</span>()</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;的两个label&quot;</span>).border(.blue, width: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3uoh36i9gj213v0n1418.jpg"></image></pre></details><h4 id="ZStack"><a href="#ZStack" class="headerlink" title="ZStack"></a>ZStack</h4><p>ZStack的布局方式类似于UIKit中的View父子层级,但是SwiftUI中较少提及父子层级关系,SwiftUI中认为每个View都是独立的View,仅仅是布局方式的不同。</p><p>例如在UIKit中在一个View内部增加几个小View会用到addSubview方法来添加子View,但是在SwiftUI中会使用ZStack布局方式来进行View堆叠。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZStack</span>(alignment: .center) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font></summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3uorpdw9qj213s0mtn0l.jpg"></image></pre></details><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><h4 id="TabView"><a href="#TabView" class="headerlink" title="TabView"></a>TabView</h4><p>类似UIKit中的UITabbar承担tab切换的功能</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TabType</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> featureList</span><br><span class="line">    <span class="keyword">case</span> other</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">  <span class="comment">//FeatureListHomeView是这个tabbar的root层级的view</span></span><br><span class="line">  <span class="type">FeatureListHomeView</span>().tabItem(&#123;</span><br><span class="line">      <span class="type">Label</span>(<span class="string">&quot;列表&quot;</span>, systemImage: <span class="string">&quot;list.bullet&quot;</span>)<span class="comment">// tabItem来进行展示内容</span></span><br><span class="line">  &#125;).tag(<span class="type">TabType</span>.featureList) <span class="comment">// .tag来标志映射</span></span><br><span class="line"></span><br><span class="line">  <span class="type">CustomViews</span>().tabItem(&#123;</span><br><span class="line">      <span class="type">Label</span>(<span class="string">&quot;自定义&quot;</span>, systemImage: <span class="string">&quot;star&quot;</span>)</span><br><span class="line">  &#125;).tag(<span class="type">TabType</span>.other)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3jkd4vkktj214o0men09.jpg"></image></pre></details><h4 id="NavigationView-NavigationLink"><a href="#NavigationView-NavigationLink" class="headerlink" title="NavigationView, NavigationLink"></a>NavigationView, NavigationLink</h4><p>类似UINavigationViewController,负责导航栈的管理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">ForEach</span>(feature.demoFeatures.featureSections, id: \.<span class="keyword">self</span>) &#123; sec <span class="keyword">in</span></span><br><span class="line">        <span class="type">Section</span>(sec.featureSectionName) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(sec.featureList, id: \.<span class="keyword">self</span>) &#123; item <span class="keyword">in</span></span><br><span class="line">                <span class="type">NavigationLink</span> &#123;</span><br><span class="line">                    getDestinationViews(featureItem: item)</span><br><span class="line">                &#125; label: &#123;</span><br><span class="line">                    <span class="type">DemoRowView</span>(title: item.featureName, subTitle: item.featureDesc)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.onDelete &#123; offset <span class="keyword">in</span></span><br><span class="line">                deleteRow(offset: offset, from: sec)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.listStyle(.in<span class="keyword">set</span>)</span><br><span class="line">.navigationTitle(<span class="string">&quot;控件列表&quot;</span>)</span><br></pre></td></tr></table></figure><p>一般配合NavigationLink来进行点击跳转.类似的,导航栈跳转后续的页面共用同一个导航栈。可以通过navigationTitle方法设置导航栈的标题,通过navigationBarTitleDisplayMode方法设置导航标题的展示形式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">.navigationTitle(<span class="string">&quot;NavigationView&quot;</span>)</span><br><span class="line">.navigationBarTitleDisplayMode(.inline)<span class="comment">// 只在顶部标题区域显示</span></span><br><span class="line">.navigationBarTitleDisplayMode(.large)<span class="comment">// 会在当前页面顶部显示一个较大的标题</span></span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3n25qldn7j214q0mg0va.jpg"></image></pre></details><h4 id="Modal"><a href="#Modal" class="headerlink" title="Modal"></a>Modal</h4><p>模态弹出是经常使用的一种弹出信息页面的模式。</p><p>SwiftUI给VIew增加的.sheet的扩展,给定一个绑定的值,当这个值发生变化的时候(true),触发模态框的事件。</p><p>UIKit中的Present VIewController不同的style,有半弹窗和全屏present</p><p>同理,SwiftUI给VIew增加了.fullScreenCover的扩展,给定一个绑定的值,当这个值发生变化的时候(true),触发全屏模态框的事件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Form</span>&#123;</span><br><span class="line">  <span class="type">Button</span>(<span class="string">&quot;Modal New View&quot;</span>) &#123;</span><br><span class="line">      isPresented.toggle()</span><br><span class="line">  &#125;.sheet(isPresented: <span class="variable">$isPresented</span>, onDismiss: &#123;</span><br><span class="line">      <span class="comment">// dismiss</span></span><br><span class="line">  &#125;) &#123;</span><br><span class="line">      <span class="type">ImageDemo</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Button</span>(<span class="string">&quot;FullScreenCover New View&quot;</span>) &#123;</span><br><span class="line">      fullScreenCover.toggle()</span><br><span class="line">  &#125;.fullScreenCover(isPresented: <span class="variable">$fullScreenCover</span>) &#123;</span><br><span class="line">      <span class="type">TextEditorDemo</span>(value: <span class="string">&quot;FullScreenCover&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3pdafcupzj213e0mgwgx.jpg"></image></pre></details><h4 id="Popover"><a href="#Popover" class="headerlink" title="Popover"></a>Popover</h4><p>Popover在不同的设备上展示会出现差异,在iOS上是模态弹出一个新页面,在iPad或Mac上弹出一个气泡框。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;Popover New View&quot;</span>) &#123;</span><br><span class="line">    popover.toggle()</span><br><span class="line">&#125;.popover(isPresented: <span class="variable">$popover</span>) &#123;</span><br><span class="line">   <span class="type">Text</span>(<span class="string">&quot;在iphone上显示为模态框弹出页面,在ipad上显示为点击气泡弹窗&quot;</span>)</span><br><span class="line">        .padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3ro8fw598j21380fatah.jpg"></image></pre></details><h3 id="Pickers"><a href="#Pickers" class="headerlink" title="Pickers"></a>Pickers</h3><h4 id="Picker"><a href="#Picker" class="headerlink" title="Picker"></a>Picker</h4><p>可以自定义数据的选择器</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Picker</span>(selection: <span class="variable">$selectIndex</span>) &#123;</span><br><span class="line">  <span class="type">ForEach</span>(fruits, id: \.<span class="keyword">self</span>) &#123; fruit <span class="keyword">in</span></span><br><span class="line">      <span class="type">Text</span>(fruit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; label: &#123;</span><br><span class="line">  <span class="type">Text</span>(<span class="string">&quot;Picker&quot;</span>)</span><br><span class="line">&#125;.pickerStyle(.wheel) <span class="comment">// 使用此方法切换选择风格</span></span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3n2vebx0zj214s0mijv7.jpg"></image></pre></details><h4 id="DatePicker"><a href="#DatePicker" class="headerlink" title="DatePicker"></a>DatePicker</h4><p>系统内置的时间选择器</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">&quot;选择日期&quot;</span>, selection: <span class="variable">$selectDate</span>, displayedComponents: .date)</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3nr7v7zu9j214p0mdjvb.jpg"></image></pre></details><h4 id="Toggle"><a href="#Toggle" class="headerlink" title="Toggle"></a>Toggle</h4><p>类似于UISwitch,用于开关选择</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Toggle</span>(<span class="string">&quot;开关&quot;</span>, isOn: <span class="variable">$open</span>)</span><br><span class="line">.onChange(of: <span class="keyword">open</span>) &#123; newValue <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;切换了开关状态&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3o0cr0v3mj214q0mdmz8.jpg"></image></pre></details><h4 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h4><p>Slider相当于UIKit中的UISlider，通过移动滑杆实现指定区域和间隔的数值的选择。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Slider</span>(value: <span class="variable">$opacity</span>, in: <span class="number">0.1</span> <span class="operator">...</span> <span class="number">1.0</span>, step: <span class="number">0.05</span>).accentColor(.red)</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3p7s7u4plj214v0mf0vu.jpg"></image></pre></details><h4 id="Stepper"><a href="#Stepper" class="headerlink" title="Stepper"></a>Stepper</h4><p>步进选择器</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Stepper</span>(<span class="string">&quot;有限的选择数量&quot;</span>, value: <span class="variable">$value</span>, in: <span class="operator">-</span><span class="number">1</span> <span class="operator">...</span> <span class="number">5</span>, step: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3p82b0ae5j214r0mhace.jpg"></image></pre></details><h3 id="Alerts"><a href="#Alerts" class="headerlink" title="Alerts"></a>Alerts</h3><h4 id="Alert"><a href="#Alert" class="headerlink" title="Alert"></a>Alert</h4><p>AlertView将被废弃,被.alert方法替代</p><p>swiftUI给VIew增加了.alert的扩展,给定一个绑定的值,当这个值发生变化的时候(true),触发Alert的事件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.alert(<span class="string">&quot;Alert Title&quot;</span>, isPresented: <span class="variable">$isPresented1</span>, actions: &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;OK&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// button点击事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, message: &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;一个选择项的Alert&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当action中的button数量不同时会自动切换alert的显示格式</p><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3pcgv2l0dj213s0mgjuh.jpg"></image></pre></details><h4 id="ActionSheet"><a href="#ActionSheet" class="headerlink" title="ActionSheet"></a>ActionSheet</h4><p>ActionSheet将被废弃,被.confirmationDialog替代</p><p>SwiftUI给VIew增加了.confirmationDialog的扩展,给定一个绑定的值,当这个值发生变化的时候(true),触发ActionSheet的事件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.confirmationDialog(<span class="string">&quot;选择你需要的选项&quot;</span>, isPresented: <span class="variable">$isPresented</span>) &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Update&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// choose update</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Delete&quot;</span>, role: .destructive) &#123;</span><br><span class="line">        <span class="comment">// choose delete</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Cancel&quot;</span>, role:  .cancel) &#123;</span><br><span class="line">        <span class="comment">// choose cancel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24egy1h3pctoaj0pj213k0mfaco.jpg"></image></pre></details><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>Image,类似于UIImageView,相对于UIimageview,Image控件可以更加简单的设置圆角,边框,阴影等属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(<span class="string">&quot;stmarylake&quot;</span>)</span><br><span class="line">.resizable() <span class="comment">// 必须先设置可以重设尺寸才可以改变图片原始尺寸</span></span><br><span class="line">.frame(width: <span class="number">100</span>, height: <span class="number">100</span>, alignment: .center)</span><br><span class="line">.clipShape(<span class="type">Rectangle</span>()) <span class="comment">// 边缘切割</span></span><br><span class="line">.overlay(<span class="type">Rectangle</span>().stroke(.white, lineWidth: <span class="number">4</span>), alignment: .bottom)<span class="comment">// 覆盖一个等大小的方块增加4的宽度的stroke用来做边框</span></span><br><span class="line">.shadow(radius: <span class="number">10</span>)<span class="comment">// 阴影</span></span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3jk79vi59j214p0mf76j.jpg"></image></pre></details><h3 id="WebImage"><a href="#WebImage" class="headerlink" title="WebImage"></a>WebImage</h3><p>SwiftUI中的VIew控件可以控制其生命周期,在onAppear的时候进行URL图片下载,下载成功后替换image即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(uiImage: baseImage)</span><br><span class="line">.resizable()</span><br><span class="line">.frame(height: <span class="number">200</span>)</span><br><span class="line">.aspectRatio(contentMode: .fit)</span><br><span class="line">.onAppear &#123;</span><br><span class="line">    downloadImageWithURL(url: url)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">downloadImageWithURL</span>(<span class="params">url</span>: <span class="type">String</span>?) &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> urlStr <span class="operator">=</span> url, <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: urlStr) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="type">SwiftUIDemoHelper</span>.defult.downLoadImageWithURL(url: url) &#123; receivedSize, totalSize <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">let</span> progress <span class="operator">=</span> <span class="type">Float</span>(receivedSize) <span class="operator">/</span> <span class="type">Float</span>(totalSize)</span><br><span class="line">      downloadTaskProgress <span class="operator">=</span> progress</span><br><span class="line">  &#125; completion: &#123; res <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">switch</span> res &#123;</span><br><span class="line">      <span class="keyword">case</span> .success(<span class="keyword">let</span> img):</span><br><span class="line">          baseImage <span class="operator">=</span> img</span><br><span class="line">          downloadTaskProgress <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> .failure(<span class="keyword">_</span>):</span><br><span class="line">          downloadError <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3uxv5n357j213q0natdv.jpg"></image></pre></details><p>当然可以使用kf图片库来进行网络图片的下载和缓存管理。</p><details><summary><font color=gray>点击查看长时间下载的加载效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3uxr4o7zbg20oo1hcx6p.gif" height = 400></image></pre></details><h3 id="Webview"><a href="#Webview" class="headerlink" title="Webview"></a>Webview</h3><p>SwiftUI没有再封装一套新的Webview容器,直接桥接WKWebView即可。</p><p>如何和UIKit进行桥接参考后续桥接部分。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> WebKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WebviewDemo</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> url: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> pageTitle: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Webview&quot;</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">       <span class="type">SWWkWebview</span>(url: <span class="variable">$url</span>, pageTitle: <span class="variable">$pageTitle</span>)</span><br><span class="line">            .navigationTitle(pageTitle)</span><br><span class="line">            .navigationBarTitleDisplayMode(.inline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SWWkWebview</span>: <span class="title class_ inherited__">UIViewRepresentable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">UIViewType</span> <span class="operator">=</span> <span class="type">WKWebView</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> url: <span class="type">String</span></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> pageTitle: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeUIView</span>(<span class="params">context</span>: <span class="type">Context</span>) -&gt; <span class="type">WKWebView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> <span class="type">WKWebView</span>()</span><br><span class="line">        view.navigationDelegate <span class="operator">=</span> context.coordinator</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: url) &#123;</span><br><span class="line">            view.load(<span class="type">URLRequest</span>(url: url))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUIView</span>(<span class="keyword">_</span> <span class="params">uiView</span>: <span class="type">WKWebView</span>, <span class="params">context</span>: <span class="type">Context</span>) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeCoordinator</span>() -&gt; <span class="type">Coordinator</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val <span class="operator">=</span>  <span class="type">Coordinator</span>()</span><br><span class="line">        val.updateTitle <span class="operator">=</span> &#123; title <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.pageTitle <span class="operator">=</span> title</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Coordinator</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">var</span> updateTitle: ((<span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">didFinish</span> <span class="params">navigation</span>: <span class="type">WKNavigation</span>!) &#123;</span><br><span class="line">            webView.evaluateJavaScript(<span class="string">&quot;document.title&quot;</span>) &#123; (result, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> title: <span class="type">String</span> <span class="operator">=</span> <span class="type">String</span>(describing: result <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="keyword">self</span>.updateTitle<span class="operator">?</span>(title)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3uqhsiluvj213m0nc42w.jpg"></image></pre></details><hr><h2 id="桥接UIKit"><a href="#桥接UIKit" class="headerlink" title="桥接UIKit"></a>桥接UIKit</h2><p>SwiftUI可以自由的和当前项目中的framework协作，不论你是UIKit还是APPKit或者是WatchKit。这里我们简单说下如何桥接UIKit。</p><h3 id="UIViewRepresentable"><a href="#UIViewRepresentable" class="headerlink" title="UIViewRepresentable"></a>UIViewRepresentable</h3><p>有一些View还未被SwiftUI原生实现，需要从UIKit中桥接而来，例如前面的<a href="#Webview">WebviewDemo</a>。当然一些自己封装的View或者三方库View均可桥接到SwiftUI中展示。当我们需要在SwiftUI使用UIKit中的View时，我们需要创建一个实现了UIViewRepresentable协议的结构体作为我们的桥接View。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">UIViewRepresentable</span> : <span class="title class_ inherited__">View</span> <span class="keyword">where</span> <span class="title class_ inherited__">Self</span>.<span class="title class_ inherited__">Body</span> == <span class="title class_ inherited__">Never</span> &#123;</span><br><span class="line">    <span class="comment">/// 首先需要确定你要桥接的View的类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">UIViewType</span> : <span class="type">UIView</span></span><br><span class="line">    <span class="comment">/// 必须实现的协议，系统在初始化结构体的时候会初始化你的View</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeUIView</span>(<span class="params">context</span>: <span class="keyword">Self</span>.<span class="type">Context</span>) -&gt; <span class="keyword">Self</span>.<span class="type">UIViewType</span></span><br><span class="line">    <span class="comment">/// 必须实现的协议，SwiftUI更新的时候会调用此方法让你的View同步更新</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUIView</span>(<span class="keyword">_</span> <span class="params">uiView</span>: <span class="keyword">Self</span>.<span class="type">UIViewType</span>, <span class="params">context</span>: <span class="keyword">Self</span>.<span class="type">Context</span>)</span><br><span class="line">    <span class="comment">/// 非必须实现的协议，相当于 UIView 的 deinit 方法，可以在其中做一些诸如删除通知 observer，停止 timer 等清理工作</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">dismantleUIView</span>(<span class="keyword">_</span> <span class="params">uiView</span>: <span class="keyword">Self</span>.<span class="type">UIViewType</span>, <span class="params">coordinator</span>: <span class="keyword">Self</span>.<span class="type">Coordinator</span>)</span><br><span class="line">    <span class="comment">/// 协调器，当前结构体从UIKit中获取数据的途径，一般用来实现UIKit View 的代理</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Coordinator</span> <span class="operator">=</span> <span class="type">Void</span></span><br><span class="line">    <span class="comment">/// 创建一个协调器，用来连接SwiftUI和UIKit，makeUIView之前就会调用</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeCoordinator</span>() -&gt; <span class="keyword">Self</span>.<span class="type">Coordinator</span></span><br><span class="line">    <span class="comment">/// 存储一些数据的上下文</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Context</span> <span class="operator">=</span> <span class="type">UIViewRepresentableContext</span>&lt;<span class="keyword">Self</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桥接过程的生命周期为：</p><p><img src="https://cdn.zcx.info/e6c9d24ely1h3x76m90gnj20b80buglq.jpg" alt="4"></p><p>其中updateUIView方法会随着View的刷新调用多次。</p><h3 id="UIViewControllerRepresentable"><a href="#UIViewControllerRepresentable" class="headerlink" title="UIViewControllerRepresentable"></a>UIViewControllerRepresentable</h3><p>类似于桥接UIView，SwiftUI也给出了桥接UIViewController的方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">UIViewControllerRepresentable</span> : <span class="title class_ inherited__">View</span> <span class="keyword">where</span> <span class="title class_ inherited__">Self</span>.<span class="title class_ inherited__">Body</span> == <span class="title class_ inherited__">Never</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">UIViewControllerType</span> : <span class="type">UIViewController</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeUIViewController</span>(<span class="params">context</span>: <span class="keyword">Self</span>.<span class="type">Context</span>) -&gt; <span class="keyword">Self</span>.<span class="type">UIViewControllerType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUIViewController</span>(<span class="keyword">_</span> <span class="params">uiViewController</span>: <span class="keyword">Self</span>.<span class="type">UIViewControllerType</span>, <span class="params">context</span>: <span class="keyword">Self</span>.<span class="type">Context</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeCoordinator</span>() -&gt; <span class="keyword">Self</span>.<span class="type">Coordinator</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Context</span> <span class="operator">=</span> <span class="type">UIViewControllerRepresentableContext</span>&lt;<span class="keyword">Self</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从实现上来看桥接View和ViewController都是同一种实现方式，都借助了生成一个协调器Coordinator来连接二者。</p><hr><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>SwiftUI的设计理念是，所有数据<strong>有且仅有一个</strong>数据源。物理内存中仅仅保存一份数据,其余地方均引用其指针地址。</p><h3 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h3><p>SwiftUI中大量使用结构体<code>Struct</code>,结构体中的变量一般是不能修改的,但是在View层级中会随着用户操作或者其他条件触发数据的变化,这个时候我们该如何让数据变化的同时界面跟随刷新变化呢。</p><p>如果视图需要存储它可以修改的数据，请使用<a href="https://developer.apple.com/documentation/swiftui/state"><code>State</code></a>属性包装器声明一个变量。</p><p>例如我们在开关Demo中使用了用<code>@State</code>包裹着的<code>open</code>属性,当触发开关onchange方法的时候会直接改变open属性的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ToggleDemo</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">open</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Form</span>&#123;</span><br><span class="line">            <span class="type">Toggle</span>(<span class="string">&quot;开关&quot;</span>, isOn: <span class="variable">$open</span>)</span><br><span class="line">                .onChange(of: <span class="keyword">open</span>) &#123; newValue <span class="keyword">in</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;切换了开关状态&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;开关状态: <span class="subst">\(<span class="keyword">open</span>.description)</span>&quot;</span>)</span><br><span class="line">        &#125;.navigationTitle(<span class="string">&quot;Toggle&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通俗的理解为struct内的属性都是不可变的,但是当你的View的body想要监听某个属性的时候可以给这个属性增加@State修饰符,这样的话就可以在struct内部直接修改此变量而不再使用mutating,同时当此变量发生改变的时候会触发View的重载和刷新。</p><p>在State单词的语境下理解这个修饰符会更容易–状态变量。实质为当结构体中的属性发生了改变,Swift会创建一个新的Struct来替换原来的Struct。而@State 能够发现这种变化，并自动重新加载视图。</p><p>SwiftUI在别的存储位置专门存放使用@State修饰的变量,来绕过结构体的限制。</p><p>注意,这种用法破坏了常识中的结构体的规则,@State 是专门为存储在一个结构体中的简单属性而设计的,所以尽量将使用@State修饰的变量设置为私有的(private)。</p><p>值得一提的是SwiftUI支持在任何线程安全地修改@State修饰的变量。</p><h3 id="Binding"><a href="#Binding" class="headerlink" title="@Binding"></a>@Binding</h3><p>由上一节的@State我们可以做到数据源变化的时候刷新View,当然有时候会出现一些相反的场景,比如一些View的操作变化产生了新的数据需要回传给另一个View显示,例如之前的WebviewDemo中桥接Wkwebview的SWWkWebview类。</p><p>在Wkwebview的WKNavigationDelegate代理中发现Webview加载完毕之后执行JS代码来获取页面的标题,然后反向传递到上层页面的导航条上显示。</p><p>这种情况适合使用@Binding修饰符来修饰属性让SwiftUI知晓这里需要使用指针传递,而非值传递(Swift中的struct内属性赋值默认是值传递)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WebviewDemo</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> url: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;https://www.36kr.com&quot;</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> pageTitle: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Webview&quot;</span> <span class="comment">// 默认的标题,状态变量</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">       <span class="type">SWWkWebview</span>(url: <span class="variable">$url</span>, pageTitle: <span class="variable">$pageTitle</span>)<span class="comment">// 注意@Binding的属性需要使用$符号来传递指针值</span></span><br><span class="line">            .navigationTitle(pageTitle)<span class="comment">// pageTitle改变时会更新导航栏标题</span></span><br><span class="line">            .navigationBarTitleDisplayMode(.inline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SWWkWebview</span>: <span class="title class_ inherited__">UIViewRepresentable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">UIViewType</span> <span class="operator">=</span> <span class="type">WKWebView</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// @Binding修饰的属性,说明这个属性需要指针传递,不能使用值传递</span></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> url: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 指针传递才能够做到不增加别的操作就能直接改变外部环境的属性值</span></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> pageTitle: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeUIView</span>(<span class="params">context</span>: <span class="type">Context</span>) -&gt; <span class="type">WKWebView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> <span class="type">WKWebView</span>()</span><br><span class="line">        view.navigationDelegate <span class="operator">=</span> context.coordinator</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: url) &#123;</span><br><span class="line">            view.load(<span class="type">URLRequest</span>(url: url))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUIView</span>(<span class="keyword">_</span> <span class="params">uiView</span>: <span class="type">WKWebView</span>, <span class="params">context</span>: <span class="type">Context</span>) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeCoordinator</span>() -&gt; <span class="type">Coordinator</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val <span class="operator">=</span>  <span class="type">Coordinator</span>()</span><br><span class="line">        val.updateTitle <span class="operator">=</span> &#123; title <span class="keyword">in</span></span><br><span class="line">            <span class="comment">//这里更新pageTitle指针指向的属性的值</span></span><br><span class="line">            <span class="keyword">self</span>.pageTitle <span class="operator">=</span> title</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Coordinator</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">var</span> updateTitle: ((<span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">didFinish</span> <span class="params">navigation</span>: <span class="type">WKNavigation</span>!) &#123;</span><br><span class="line">            webView.evaluateJavaScript(<span class="string">&quot;document.title&quot;</span>) &#123; (result, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> title: <span class="type">String</span> <span class="operator">=</span> <span class="type">String</span>(describing: result <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="comment">// 这里每次加载页面都获取页面的标题,然后执行block进行SWWkWebview结构体的更新</span></span><br><span class="line">                <span class="keyword">self</span>.updateTitle<span class="operator">?</span>(title)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然@Binding的链接是双向的,不仅可以从下向上修改数据,在上层View修改的下层View绑定的数据属性的时候,下层View也会受到影响。</p><p>可以看到数据流向图:</p><p><img src="https://docs-assets.developer.apple.com/published/d98251c2fac9fc4f6843be1e4836cb93/Managing-User-Interface-State-1@2x.png" alt="基本数据流向"></p><p>首先我们在上层View中存在一个@State修饰的状态变量,上层View会观察此变量的变化随之刷新界面,相应刷新的View可能是另外一个下层VIew,不过这个并不影响既定的刷新规则。这种数据流向为单向绑定。</p><p>其次我们可以把状态变量的指针传递给下层@Binding修饰的属性变量,当任何一方修改此属性的时候都会触发观察者更新全部的View。这种数据流向为双向绑定。</p><p>从上图可以观察到,当使用@State属性来修饰的时候可以认为此属性为值的真实来源,当使用@Binding修饰属性的时候可以认为此属性为真实值的指针。</p><p>类似的当看到带有State单词的修饰符时都可以认为当前属性为值的真实来源，且当前View是这个属性的原始持有者。</p><h3 id="ObservableObject、-Published、-StateObject"><a href="#ObservableObject、-Published、-StateObject" class="headerlink" title="@ObservableObject、@Published、@StateObject"></a>@ObservableObject、@Published、@StateObject</h3><p>虽然Swift中推荐使用Struct,但是Class的使用还是不可缺少的一环。相比于结构体的值传递,class默认进行的就是指针传递。那么指针传递的Class是否就自动获得了类似于@State和@Binding的功能呢?</p><p>答案是NO</p><p>SwiftUI中并不会因为你传递进来的是一个类变量就默认自动刷新显示。想要达到这样的效果必须使当前类满足ObservableObject协议。</p><p>ObservableObject字面意思,可观察对象。在类中可以添加@Published修饰符来告诉SwiftUI这个类中的这个属性可以发布订阅。</p><p>例如我们现在有一个可以显示用户信息的文本可一个点击一下增加一岁的按钮：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;Apple&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomViews</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> user <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span>&#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户名:<span class="subst">\(user.name)</span>&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户年龄:<span class="subst">\(user.age)</span>岁&quot;</span>)</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;一年过去了&quot;</span>) &#123;</span><br><span class="line">                    user.age <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;一年后的年龄:<span class="subst">\(user.age)</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;自定义view组件&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3w250asb2j213u0mqwgy.jpg"></image></pre></details><p>可以看到我们点了很多次按钮,内存中的age字段已经变成了25,界面上却依旧显示为原始的值,这是因为User类是不可观察的,所以当User中的字段发生改变的时候不能触发页面的刷新.</p><p>现在我们为User类增加可观察属性</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;Apple&quot;</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomViews</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="comment">// 以前使用@ObservableObject的时候有user属性被异常释放的风险,改为使用@StateObject修饰符</span></span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> user <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span>&#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户名:<span class="subst">\(user.name)</span>&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户年龄:<span class="subst">\(user.age)</span>岁&quot;</span>)</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;一年过去了&quot;</span>) &#123;</span><br><span class="line">                    user.age <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;一年后的年龄:<span class="subst">\(user.age)</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;自定义view组件&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary><font color=gray>点击查看运行效果</font> </summary>  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3w27hniv2j213o0luad5.jpg"></image></pre></details><p>可以看到随着我们的点击增加user的age字段值,界面上显示的年龄文字也随之增加.</p><p>当然你需要给可观察的对象增加**@StateObject**修饰符</p><p><strong>为什么不使用@ObservedObject修饰符呢?</strong></p><ol><li><p>这将确保 User 实例在视图更新时不会被破坏。以前可能已经使用 @ObservedObject 来获得相同的结果，但这是有风险的。有时 @ObservedObject 可能会意外释放它正在存储的对象，因为它不是设计为最终的真相来源目的，但 @StateObject 就不会发生这种情况，因此应该改用它。</p></li><li><p>@StateObject 和 @ObservedObject 之间有一个重要的区别，即<strong>所有权</strong>，哪个视图创建了对象，哪个视图只是在监视它。规则是这样的：首先创建对象的视图必须使用**@StateObject**，告诉 SwiftUI 它是数据的所有者并负责保持它的活动，所有其它视图都必须使用 <strong>@ObservedObject</strong> 来告诉 SwiftUI，它们想要观察对象的变化但不直接拥有它。即每个对象应该只使用一次 @StateObject，它应该在负责创建对象的任何视图中，共享对象的所有其它视图都应使用@ObservedObject。</p></li></ol><p><strong>思考1: 我们能对Class使用@State修饰吗?</strong></p><p>可以,只不过使用@State修饰的时候只有当前值发生变化的时候才会触发View变化,当被修饰的是Class类型的变量时,类内容的属性改变并不能改变当前类的值(指针).所以必须触发类的当前值改变的时候才能和观察者产生一样的效果.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;Apple&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomViews</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> user <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span>&#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户名:<span class="subst">\(user.name)</span>&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户年龄:<span class="subst">\(user.age)</span>岁&quot;</span>)</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;一年过去了&quot;</span>) &#123;</span><br><span class="line">                  <span class="comment">// 直接生成新的类,或者做类的深拷贝后改变age数值</span></span><br><span class="line">                    <span class="keyword">let</span> userB <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line">                    userB.name <span class="operator">=</span> user.name</span><br><span class="line">                    userB.age <span class="operator">=</span> user.age <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">                    user <span class="operator">=</span> userB</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;自定义view组件&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考2: 我们可以对结构体使用@StateObject吗?</strong></p><p>很遗憾不能, 因为@StateObject修饰符必须要求属性满足ObservableObject协议,而非class类型不能遵循协议.</p><h3 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="@EnvironmentObject"></a>@EnvironmentObject</h3><p>思考一种场景，如果您有视图 A，并且视图 A 有一些视图 E 想要的数据，使用@ObservedObject 视图 A 需要将对象交给视图 B，视图 B 将把它交给视图 C，然后是视图 D，最后是视图 E，所有中间视图都需要发送对象，即使它们实际上并没有需要它。</p><p>这个时候我们可以使用@EnvironmentObject ，视图 A 可以创建一个对象并将其放入环境中；然后，其中的任何视图都可以随时通过请求访问该环境对象，而不必显式传递它，这样会使我们的代码更简单。</p><p>例如之前的Demo种的列表数据:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SwiftUIDemoApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> features <span class="operator">=</span> <span class="type">FeatureInfoModel</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">DemoHomeView</span>().environmentObject(features)<span class="comment">//这里向环境变量中添加了一个FeatureInfoModel</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FeatureListHomeView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> feature: <span class="type">FeatureInfoModel</span> <span class="comment">//这个view从环境变量中获取了FeatureInfoModel</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">      <span class="type">NavigationView</span>&#123;</span><br><span class="line">          <span class="type">List</span> &#123;</span><br><span class="line">              <span class="type">ForEach</span>(feature.demoFeatures.featureSections, id: \.<span class="keyword">self</span>) &#123; sec <span class="keyword">in</span></span><br><span class="line">                  <span class="type">Section</span>(sec.featureSectionName) &#123;</span><br><span class="line">                      <span class="type">ForEach</span>(sec.featureList, id: \.<span class="keyword">self</span>) &#123; item <span class="keyword">in</span></span><br><span class="line">                          <span class="type">NavigationLink</span> &#123;</span><br><span class="line">                              getDestinationViews(featureItem: item)</span><br><span class="line">                          &#125; label: &#123;</span><br><span class="line">                              <span class="type">DemoRowView</span>(title: item.featureName, subTitle: item.featureDesc)</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;.onDelete &#123; offset <span class="keyword">in</span></span><br><span class="line">                          deleteRow(offset: offset, from: sec)</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;.listStyle(.in<span class="keyword">set</span>)</span><br><span class="line">          .navigationTitle(<span class="string">&quot;基础控件&quot;</span>)</span><br><span class="line">          .navigationBarTitleDisplayMode(.large)</span><br><span class="line">          .toolbar&#123;</span><br><span class="line">              <span class="type">EditButton</span>()</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显DemoHomeView和FeatureListHomeView中间间隔了一些其他View，类似于全局变量可以直接读取使用。</p><p>通常EnvironmentObject用于整个应用程序中一些View都依赖和共享的数据，因为所有的视图都指向同一个模型，当被修饰的属性发生变化时，所有的视图都会立即更新，排除了应用程序的不同部分出现不同步的风险。</p><h2 id="应用程序行为控制"><a href="#应用程序行为控制" class="headerlink" title="应用程序行为控制"></a>应用程序行为控制</h2><h3 id="UIApplicationDelegate"><a href="#UIApplicationDelegate" class="headerlink" title="UIApplicationDelegate"></a>UIApplicationDelegate</h3><p>作为一个完整的APP，开发者应该可以控制APP的完整生命周期，这个时候我们需要一个<a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate"><code>UIApplicationDelegate</code></a>类型的对象来承载App生命周期内各种行为的相应。</p><p>但是创建SwiftUI项目的时候Xcode并没有给我们默认创建Applegate.swift文件。</p><p>如果我们需要实现UIApplicationDelegate方法，我们需要手动创建Applegate.swift文件，并且让我们的Applegate类遵循NSObject协议和UIApplicationDelegate协议，然后实现我们需要的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">APPDelegate</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">UIApplicationDelegate</span>, <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>,</span><br><span class="line">                     <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="type">UIApplication</span>.<span class="params">LaunchOptionsKey</span> : <span class="keyword">Any</span>]<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;didFinishLaunchingWithOptions&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// SwiftUI中一些方法不能触发</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">applicationDidReceiveMemoryWarning</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;log-DidReceiveMemoryWarning&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">applicationDidBecomeActive</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;log-applicationDidBecomeActive&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">applicationDidEnterBackground</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;log-applicationDidEnterBackground&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了代理方法后，我们还需要告诉SwiftUI在哪里增加我们的代理，在@main入口的struct中添加@UIApplicationDelegateAdaptor标记，SwiftUI会自动识别我们的代理类，并在合适的时机调用对应的代理方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SwiftUIDemoApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@UIApplicationDelegateAdaptor</span> <span class="keyword">private</span> <span class="keyword">var</span> appdelegate: <span class="type">APPDelegate</span></span><br><span class="line">    <span class="comment">//@UIApplicationDelegateAdaptor(APPDelegate.self) var appdelegate 这个写法也可以</span></span><br><span class="line">   <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较方便的是如果你的APPDelegate类遵循了ObservableObject协议，SwiftUI会自动把@UIApplicationDelegateAdaptor修饰的属性放到全局环境变量里去，例如这里我们并没有声明全局环境变量，但是在下层的View中依旧可以使用全局环境变量获取。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FeatureListHomeView</span>: <span class="title class_ inherited__">View</span> &#123;  </span><br><span class="line"> <span class="comment">// 这里去获取环境变量</span></span><br><span class="line"> <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> appdelegate: <span class="type">APPDelegate</span></span><br><span class="line"> <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">NavigationView</span> &#123;</span><br><span class="line">      <span class="operator">...</span></span><br><span class="line">    &#125;.onAppear &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在App内部的view获取到了全局的appdelegate中的name属性<span class="subst">\(appdelegate.name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意一个问题，随着API的更新，有些代理方法不再由UIApplicationDelegate调用。</p><p>例如App前后台切换的代理，iOS13以前，由UIApplicationDelegate来控制生命周期，iOS13以后，由UISceneDelegate来控制生命周期。在iOS 13之后为了解决iPadOS展示多窗口的问题，用UIScene替代了之前UIWindow来管理视图。</p><p>iOS14以后Apple又给SwiftUI提供了更优雅的API来显示和控制Scene。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SwiftUIDemoApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Environment</span>(\.scenePhase) <span class="keyword">var</span> scenePhase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">      <span class="type">WindowGroup</span> &#123;</span><br><span class="line">          <span class="type">DemoHomeView</span>()</span><br><span class="line">      &#125;.onChange(of: scenePhase) &#123; newValue <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">switch</span> newValue &#123;</span><br><span class="line">          <span class="keyword">case</span> .active:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;active&quot;</span>)</span><br><span class="line">          <span class="keyword">case</span> .background:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;background&quot;</span>)</span><br><span class="line">          <span class="keyword">case</span> .inactive:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;inactive&quot;</span>)</span><br><span class="line">          <span class="keyword">@unknown</span> <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UIWindowSceneDelegate"><a href="#UIWindowSceneDelegate" class="headerlink" title="UIWindowSceneDelegate"></a>UIWindowSceneDelegate</h3><p>多窗口管理和App代理类似，平常用的较少。</p><p>如果使用了场景委托UIWindowSceneDelegate，也需要自行创建委托文件SceneDelegate。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SceneDelegate</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">UIWindowSceneDelegate</span>, <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">windowScene</span>( <span class="keyword">_</span> <span class="params">windowScene</span>: <span class="type">UIWindowScene</span>,<span class="params">performActionFor</span> <span class="params">shortcutItem</span>: <span class="type">UIApplicationShortcutItem</span> ) <span class="keyword">async</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// Do something with the shortcut...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接在Appdelegate类中的方法中返回场景委托类即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">configurationForConnecting</span> <span class="params">connectingSceneSession</span>: <span class="type">UISceneSession</span>, <span class="params">options</span>: <span class="type">UIScene</span>.<span class="type">ConnectionOptions</span>) -&gt; <span class="type">UISceneConfiguration</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">UISceneConfiguration</span>(name: <span class="literal">nil</span>,sessionRole: connectingSceneSession.role)</span><br><span class="line">  <span class="keyword">if</span> connectingSceneSession.role <span class="operator">==</span> .windowApplication &#123;</span><br><span class="line">      configuration.delegateClass <span class="operator">=</span> <span class="type">SceneDelegate</span>.<span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> configuration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，如果你的SceneDelegate类遵循了ObservableObject协议，SwiftUI会自动把当前类型的属性放到环境环境变量里去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.zcx.info/e6c9d24ely1h4461xrrg2j211906rjrv.jpg&quot; alt=&quot;SWiftUITitleImage&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是SwiftUI&quot;&gt;&lt;a href=&quot;#什么是SwiftU</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="学习笔记" scheme="https://zcx4u.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>XCUITest iOS自动化UI测试框架</title>
    <link href="https://zcx4u.github.io/2022/02/28/XCUITest%E6%8E%A2%E7%B4%A2/"/>
    <id>https://zcx4u.github.io/2022/02/28/XCUITest%E6%8E%A2%E7%B4%A2/</id>
    <published>2022-02-27T16:00:00.000Z</published>
    <updated>2025-03-13T09:55:29.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCUITest-iOS自动化UI测试框架"><a href="#XCUITest-iOS自动化UI测试框架" class="headerlink" title="XCUITest iOS自动化UI测试框架"></a><em>XCUITest</em> iOS自动化UI测试框架</h1><h2 id="XCUITest简介"><a href="#XCUITest简介" class="headerlink" title="XCUITest简介"></a>XCUITest简介</h2><p>XCUITest是Apple提供的内嵌到xcode中的一套UI自动化测试框架。</p><blockquote><p>UI测试依赖于两项核心技术:XCTest框架和Accessibility。</p><p>XCTest提供了UI测试功能的框架，与Xcode集成在一起。创建和使用UI测试扩展了您对使用XCTest和创建单元测试的了解。您创建了一个UI测试目标，并将创建UI测试类和UI测试方法作为项目的一部分。您可以使用XCTest断言来验证预期结果是否为真。你也可以通过Xcode Server和xcodebuild实现持续集成。XCTest与Objective-C和Swift完全兼容。</p><p>Accessibility是一项核心技术，它允许残疾用户获得与其他用户相同的iOS和macOS丰富体验。它包含了一组丰富的UI语义数据，用户可以使用它来指导他们使用你的应用。可访问性集成了UIKit和AppKit，并有api允许你调整行为和对外公开的使用。UI测试使用这些数据来执行其功能。</p><p>在源代码中创建UI测试类似于创建单元测试。你为你的应用创建一个UI测试目标;然后Xcode为你创建一个默认的UI测试组和实现文件，在实现文件中有一个示例测试方法模板。在创建UI测试目标时，可以指定测试要处理的应用程序。</p></blockquote><p><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/09-ui_testing.html#//apple_ref/doc/uid/TP40014132-CH13-DontLinkElementID_8">User Interface Testing</a></p><p><a href="https://onevcat.com/2015/09/ui-testing/">WWDC15 Session笔记 - Xcode 7 UI 测试初窥</a></p><h2 id="添加target"><a href="#添加target" class="headerlink" title="添加target"></a>添加target</h2><p>以前在新建项目的时候可以看到自带单元测试和UI测试。新版本的XCode新建项目的时候可以看到Incloud Tests的选项，勾中这个选项就可以创建出来带单元测试和UI测试的target。</p><p><img src="https://cdn.zcx.info/e6c9d24ely1gzt95s1si1j20kq0eodge.jpg"></p><p><img src="https://cdn.zcx.info/e6c9d24ely1gzt95u7e5qj20ea0ajjrx.jpg" alt="自动创建了test有关的Target"></p><p>当然如果是以前就创建的项目也可以单独添加UI Test的Target。</p><h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><blockquote><p>UI 测试在基本方面不同于单元测试。单元测试使您能够在应用程序的范围内工作，并允许您在完全访问应用程序变量和状态的情况下练习函数和方法。UI 测试以与用户在不访问应用程序的内部方法、函数和变量的情况下执行相同的方式来测试应用程序的 UI。这使您的测试能够以与用户相同的方式查看应用程序，从而暴露用户遇到的 UI 问题。</p><p>您的测试代码作为一个单独的进程运行，综合应用程序中的 UI 响应的事件。</p></blockquote><p>编写测试代码不是一件容易的事情，由于UITest不能侵入代码逻辑，仅仅使用识别界面上的控件后发送事件来驱动APP，所以测试代码的编写逻辑趋向于查询屏幕上显示的控件，找到满足条件的控件，发送控件支持的事件，等待事件响应后使用断言或者期望断言来判断是否达到了预期的测试结果。</p><p>以36氪直播间内预约直播的过程为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">testSubscribeLiveInLiveHome</span>() &#123;</span><br><span class="line">  <span class="comment">//获取APP实例</span></span><br><span class="line">    <span class="keyword">let</span> app <span class="operator">=</span> <span class="type">XCUIApplication</span>()</span><br><span class="line"> <span class="comment">//启动APP</span></span><br><span class="line">    app.launch()</span><br><span class="line">  <span class="comment">//这里延迟了1s来等待APP启动项配置加载</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">//查询所有tabbar，筛选包含直播文字的底导，点击</span></span><br><span class="line">    app.tabBars[<span class="string">&quot;标签页栏&quot;</span>].buttons[<span class="string">&quot;直播&quot;</span>].tap()</span><br><span class="line">  <span class="comment">//查询APP上显示的scrollViews上的控件</span></span><br><span class="line">    <span class="keyword">let</span> elementsQuery <span class="operator">=</span> app.scrollViews.otherElements </span><br><span class="line">  <span class="comment">//点击包含直播文字的按钮 </span></span><br><span class="line">    elementsQuery.staticTexts[<span class="string">&quot;直播&quot;</span>].tap()</span><br><span class="line">  <span class="comment">//查询并点击APP上显示collectionViews中包含即将开播文字的按钮</span></span><br><span class="line">    elementsQuery.collectionViews.staticTexts[<span class="string">&quot;即将开播&quot;</span>].tap()</span><br><span class="line">  <span class="comment">//延迟1s等待APP加载即将开播列表</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">//找到第一个包含预约文字的cell，这里如果已经预约则不显示预约文字</span></span><br><span class="line">    app.collectionViews.cells.otherElements.containing(.staticText, identifier:<span class="string">&quot;预约&quot;</span>).element(boundBy: <span class="number">0</span>).tap()</span><br><span class="line">  <span class="comment">//延迟1s等待APP加载直播间</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">//查询并点击包含预约直播文字的按钮</span></span><br><span class="line">    elementsQuery.staticTexts[<span class="string">&quot;预约直播&quot;</span>].tap()</span><br><span class="line">  <span class="comment">//创建期望断言判断已预约文案是否存在，预约成功会修改按钮文案</span></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> app.staticTexts[<span class="string">&quot;已预约&quot;</span>]</span><br><span class="line">    expectation(for: <span class="type">NSPredicate</span>(format: <span class="string">&quot;exists &gt;= 1&quot;</span>), evaluatedWith: result, handler: <span class="literal">nil</span>)</span><br><span class="line">    waitForExpectations(timeout: <span class="number">3</span>, handler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就写好了一个直播间预约的测试流程。</p><p>可以看出测试代码的编写还是很繁琐的，写功能的同时几乎没有足够的时间再编写一套对应的测试代码。而且功能还会随着项目的迭代不断变化，同时维护功能代码和测试代码的成本是巨大的。</p><p>但是一些变化概率低的核心路径还是建议使用自动化测试来解放双手降低重复工作量。</p><h2 id="录制测试代码"><a href="#录制测试代码" class="headerlink" title="录制测试代码"></a>录制测试代码</h2><p>有时候不知道怎么查询具体某个控件的时候可以借用XCode上的录制功能。</p><p>把光标移入测试代码方法大括号内部空白处可以看到左下角有个红色圆点亮了起来，点击红色圆点及开启录制功能。</p><p>录制功能可以记录你手动点击的路径和流程，自动计算出操作路径的代码。但是计算结果可能不是一个通用的路径，所以还需要开发者自行调整。</p><h2 id="执行测试脚本"><a href="#执行测试脚本" class="headerlink" title="执行测试脚本"></a>执行测试脚本</h2><p>执行上面的测试方法，xcode会自动编译、运行你的APP，并会输出具体的测试结果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="type">Case</span> &#x27;<span class="operator">-</span>[<span class="type">ClientUITests</span>.<span class="type">ClientUITestsLaunchTests</span> testSubscribeLiveInLiveHome]&#x27; started.</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">0</span>.00s <span class="type">Setting</span> appearance mode to <span class="type">Light</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.08s     <span class="type">Wait</span> <span class="keyword">for</span> com.apple.springboard to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">62</span>.18s <span class="type">Start</span> <span class="type">Test</span> at <span class="number">2022</span><span class="operator">-</span><span class="number">02</span><span class="operator">-</span><span class="number">25</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">37.506</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">62</span>.27s <span class="type">Set</span> <span class="type">Up</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">62</span>.28s <span class="type">Open</span> com.zcx.iosclient</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">62</span>.35s     <span class="type">Launch</span> com.zcx.iosclient</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">66</span>.50s         <span class="type">Setting</span> up automation session</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">67</span>.71s         <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">70</span>.00s <span class="type">Tap</span> <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">70</span>.00s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">71</span>.77s     <span class="type">Find</span> the <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.10s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.14s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.30s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.42s <span class="type">Tap</span> <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.42s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.49s     <span class="type">Find</span> the <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.52s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.53s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.67s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.75s <span class="type">Tap</span> <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.75s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.81s     <span class="type">Find</span> the <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">73</span>.85s         <span class="type">Find</span> the <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span> (retry <span class="number">1</span>)</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">73</span>.91s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">73</span>.93s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">74</span>.07s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.66s <span class="type">Tap</span> <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.66s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.74s     <span class="type">Find</span> the <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.81s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.83s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.98s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.58s <span class="type">Tap</span> <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.58s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.68s     <span class="type">Find</span> the <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.78s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.81s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.97s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">79</span>.10s <span class="type">Checking</span> `<span class="type">Expect</span> predicate `exists <span class="operator">&gt;=</span> <span class="number">1</span>` <span class="keyword">for</span> object <span class="string">&quot;已预约&quot;</span> <span class="type">StaticText</span>`</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">79</span>.10s     <span class="type">Checking</span> existence of `<span class="string">&quot;已预约&quot;</span> <span class="type">StaticText</span>`</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">79</span>.17s <span class="type">Tear</span> <span class="type">Down</span></span><br><span class="line"><span class="type">Test</span> <span class="type">Case</span> &#x27;<span class="operator">-</span>[<span class="type">ClientUITests</span>.<span class="type">ClientUITestsLaunchTests</span> testSubscribeLiveInLiveHome]&#x27; passed (<span class="number">79.370</span> seconds).</span><br><span class="line"><span class="type">Test</span> <span class="type">Case</span> &#x27;<span class="operator">-</span>[<span class="type">ClientUITests</span>.<span class="type">ClientUITestsLaunchTests</span> testSubscribeLiveInLiveHome]&#x27; started.</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">0</span>.00s <span class="type">Setting</span> appearance mode to <span class="type">Dark</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.10s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.19s <span class="type">Start</span> <span class="type">Test</span> at <span class="number">2022</span><span class="operator">-</span><span class="number">02</span><span class="operator">-</span><span class="number">25</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">56.883</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.26s <span class="type">Set</span> <span class="type">Up</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.26s <span class="type">Open</span> com.zcx.iosclient</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.33s     <span class="type">Launch</span> com.zcx.iosclient</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.33s         <span class="type">Terminate</span> com.zcx.iosclient:<span class="number">21694</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">4</span>.44s         <span class="type">Setting</span> up automation session</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">5</span>.53s         <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">7</span>.76s <span class="type">Tap</span> <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">7</span>.76s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.30s     <span class="type">Find</span> the <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.53s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.57s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.72s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.86s <span class="type">Tap</span> <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.86s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.94s     <span class="type">Find</span> the <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.96s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.97s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">10</span>.12s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">10</span>.21s <span class="type">Tap</span> <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">10</span>.21s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">10</span>.27s     <span class="type">Find</span> the <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">11</span>.29s         <span class="type">Find</span> the <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span> (retry <span class="number">1</span>)</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">11</span>.39s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">11</span>.42s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">11</span>.57s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.18s <span class="type">Tap</span> <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.18s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.26s     <span class="type">Find</span> the <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.33s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.35s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.51s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.09s <span class="type">Tap</span> <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.09s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.29s     <span class="type">Find</span> the <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.39s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.41s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.58s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">16</span>.67s <span class="type">Checking</span> `<span class="type">Expect</span> predicate `exists <span class="operator">&gt;=</span> <span class="number">1</span>` <span class="keyword">for</span> object <span class="string">&quot;已预约&quot;</span> <span class="type">StaticText</span>`</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">16</span>.67s     <span class="type">Checking</span> existence of `<span class="string">&quot;已预约&quot;</span> <span class="type">StaticText</span>`</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">16</span>.74s <span class="type">Tear</span> <span class="type">Down</span></span><br><span class="line"><span class="type">Test</span> <span class="type">Case</span> &#x27;<span class="operator">-</span>[<span class="type">ClientUITests</span>.<span class="type">ClientUITestsLaunchTests</span> testSubscribeLiveInLiveHome]&#x27; passed (<span class="number">16.947</span> seconds).</span><br><span class="line"></span><br><span class="line"><span class="type">Test</span> <span class="type">Suite</span> &#x27;<span class="type">ClientUITestsLaunchTests</span>&#x27; passed at <span class="number">2022</span><span class="operator">-</span><span class="number">02</span><span class="operator">-</span><span class="number">25</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">11.642</span>.</span><br><span class="line"><span class="type">Executed</span> <span class="number">2</span> tests, with <span class="number">0</span> failures (<span class="number">0</span> unexpected) <span class="keyword">in</span> <span class="number">96.317</span> (<span class="number">96.319</span>) seconds</span><br><span class="line"></span><br><span class="line"><span class="type">Test</span> <span class="type">Suite</span> &#x27;<span class="type">ClientUITests</span>.xctest&#x27; passed at <span class="number">2022</span><span class="operator">-</span><span class="number">02</span><span class="operator">-</span><span class="number">25</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">11.644</span>.</span><br><span class="line"><span class="type">Executed</span> <span class="number">2</span> tests, with <span class="number">0</span> failures (<span class="number">0</span> unexpected) <span class="keyword">in</span> <span class="number">96.317</span> (<span class="number">96.321</span>) seconds</span><br><span class="line"></span><br><span class="line"><span class="type">Test</span> <span class="type">Suite</span> &#x27;<span class="type">Selected</span> tests&#x27; passed at <span class="number">2022</span><span class="operator">-</span><span class="number">02</span><span class="operator">-</span><span class="number">25</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">11.647</span>.</span><br><span class="line"><span class="type">Executed</span> <span class="number">2</span> tests, with <span class="number">0</span> failures (<span class="number">0</span> unexpected) <span class="keyword">in</span> <span class="number">96.317</span> (<span class="number">96.324</span>) seconds</span><br><span class="line">     </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XCUITest-iOS自动化UI测试框架&quot;&gt;&lt;a href=&quot;#XCUITest-iOS自动化UI测试框架&quot; class=&quot;headerlink&quot; title=&quot;XCUITest iOS自动化UI测试框架&quot;&gt;&lt;/a&gt;&lt;em&gt;XCUITest&lt;/em&gt; iOS自动</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="技术调研" scheme="https://zcx4u.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>iOS 一键唤起APP方案参考</title>
    <link href="https://zcx4u.github.io/2021/12/06/iOS%20Web%E5%94%A4%E8%B5%B7APP%E6%96%B9%E6%A1%88%E5%8F%82%E8%80%83/"/>
    <id>https://zcx4u.github.io/2021/12/06/iOS%20Web%E5%94%A4%E8%B5%B7APP%E6%96%B9%E6%A1%88%E5%8F%82%E8%80%83/</id>
    <published>2021-12-05T16:00:00.000Z</published>
    <updated>2025-03-13T09:54:35.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS-一键唤起APP方案参考"><a href="#iOS-一键唤起APP方案参考" class="headerlink" title="iOS 一键唤起APP方案参考"></a>iOS 一键唤起APP方案参考</h2><p>移动端业务发展过程中，几乎每个公司都会有活动宣传或者运营引流的需求。这些需求的实现不外乎开发一些吸引人的HTML页面，在页面的某些事件的响应中引导用户下载APP或者打开已经下载的APP。</p><p>基本流程为：</p><ol><li><p>策划运营投放活动链接（新用户送红包或者PDD砍一刀）</p></li><li><p>用户点击活动链接进入活动页面</p></li><li><p>用户被吸引或诱导点击某个按钮触发事件</p></li><li><p>H5页面调起相关APP</p></li><li><p>APP响应调起并接力打开对应页面</p></li></ol><p>我们这里主要说一说4、5两步其中的细节处理，也是对最近相关的业务的一个总结。</p><h3 id="DeepLink技术"><a href="#DeepLink技术" class="headerlink" title="DeepLink技术"></a>DeepLink技术</h3><p>在<code>iOS9</code>之前只有通过<code>URL Scheme</code>能够唤起一个APP。</p><p><code>Scheme</code>可以理解为一个APP的名字，因为是<code>URL Scheme</code>所以遵循URL的书写格式，类比于<code>http://www.baidu.com</code>，其中<code>http</code>就是它的<code>Scheme</code>。</p><p>每个APP可以设置自己的Scheme，即给自己起个名字，方便”别人“叫我的时候我可以听得懂。</p><p>例如我们起了个<code>Scheme</code>叫<code>kr</code>，那么在H5页面内可以通过 <code>openURL()</code>的方式打开 <code>kr://testPage</code>链接调起我们的APP，当然如果你知道别人的<code>Scheme</code>就可以调起他的APP。</p><p>这个时候就需要H5和APP约定好连接的<code>path</code>和<code>parameter</code>，APP端根据调起的链接中的<code>Path</code>来确定要跳转的目的页，根据传参来获取需要的数据比如文章ID、用户ID等，然后根据参数加载原生页面。这样就完成了从H5到原生APP的接力跳转。</p><hr><h4 id="如何给自己的APP”起名”？"><a href="#如何给自己的APP”起名”？" class="headerlink" title="如何给自己的APP”起名”？"></a>如何给自己的APP”起名”？</h4><p>注册URL Scheme，即配置info.plist 文件</p><p><img src="https://cdn.zcx.info/008i3skNly1gv92vcxu6jj60u206ewex02.jpg"></p><h4 id="如何响应被调用的跳转"><a href="#如何响应被调用的跳转" class="headerlink" title="如何响应被调用的跳转"></a>如何响应被调用的跳转</h4><p>检测到H5向自己发起了调用请求，我们需要对请求进行响应。在AppDelegate类中通过系统预留方法进行处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS9之前使用这个方法处理外部URL调用 </span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">handleOpen</span> <span class="params">url</span>: <span class="type">URL</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iOS9之后使用这个方法处理外部URL调用，示例代码中展示了若干个可以调起APP的途径，根据具体的路径和参数来处理不同的逻辑。 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">app</span>: <span class="type">UIApplication</span>, <span class="params">open</span> <span class="params">url</span>: <span class="type">URL</span>, <span class="params">options</span>: [<span class="type">UIApplication</span>.<span class="params">OpenURLOptionsKey</span> : <span class="keyword">Any</span>]) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="comment">// 三方登录回调</span></span><br><span class="line">  <span class="keyword">if</span> <span class="type">LoginSettings</span>.handleOpenURL(url) <span class="operator">??</span> <span class="literal">false</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 神策SDK回调</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> sensor <span class="operator">=</span> <span class="type">SensorsAnalyticsSDK</span>.sharedInstance(), sensor.handleSchemeUrl(url) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// zfb支付回调</span></span><br><span class="line">  <span class="keyword">if</span> url.host <span class="operator">==</span> <span class="type">Constants</span>.<span class="type">KrOpenAppSource</span>.<span class="type">AliPayHost</span> &#123;</span><br><span class="line">      <span class="type">KrThirdPayManager</span>.default.processOrderWithZfbPaymentResult(url: url)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Today小组件点击</span></span><br><span class="line">  <span class="keyword">if</span> url.host <span class="operator">==</span> <span class="type">Constants</span>.<span class="type">KrOpenAppSource</span>.<span class="type">TodayExtensionHost</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> queryItems <span class="operator">=</span> url.queryItems, <span class="operator">!</span>queryItems.isEmpty &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> query <span class="operator">=</span> url.queryItems<span class="operator">?</span>.first &#123;</span><br><span class="line">              <span class="keyword">if</span> <span class="keyword">let</span> route <span class="operator">=</span> query.value, query.name <span class="operator">==</span> <span class="type">Constants</span>.<span class="type">KrOpenAppSource</span>.<span class="type">TodayExtensionQueryNews</span> &#123;</span><br><span class="line">                  <span class="type">Router2</span>.pushURL(route, <span class="type">TrackInfo</span>(source: <span class="type">TrackSource</span>.todayExtension))</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// widget小组件点击</span></span><br><span class="line">  <span class="keyword">if</span> url.host <span class="operator">==</span> <span class="type">Constants</span>.<span class="type">KrOpenAppSource</span>.<span class="type">WidgetExtensionHost</span> &#123;</span><br><span class="line">      <span class="type">Router2</span>.pushURL(urlStr, <span class="type">TrackInfo</span>(source: <span class="type">TrackSource</span>.widgetExtension))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// URL Scheme 唤起app</span></span><br><span class="line">  <span class="keyword">if</span> canAppHandleURL(url) &#123;</span><br><span class="line">      <span class="keyword">let</span> urlString <span class="operator">=</span> url.description</span><br><span class="line">      <span class="keyword">let</span> tempArray <span class="operator">=</span> urlString.components(separatedBy: <span class="string">&quot;route/&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span> <span class="operator">!</span>tempArray.isEmpty, tempArray.count <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> route <span class="operator">=</span> tempArray[<span class="number">1</span>]</span><br><span class="line">          <span class="type">Router2</span>.pushURL(route, <span class="type">TrackInfo</span>(source: <span class="type">TrackSource</span>.linkedMe))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// app store 唤起</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> sourceApp <span class="operator">=</span> options[<span class="type">UIApplication</span>.<span class="type">OpenURLOptionsKey</span>.sourceApplication] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">     sourceApp <span class="operator">==</span> <span class="type">Constants</span>.<span class="type">KrOpenAppSource</span>.<span class="type">AppStore</span> &#123;</span><br><span class="line">      <span class="type">TrackManager</span>.track(event: .appLaunch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理旧版微信通过URL启动App时传递的数据</span></span><br><span class="line">  <span class="keyword">if</span> url.scheme <span class="operator">==</span> <span class="type">ShareManager</span>.<span class="type">Wechat</span>.appID &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">WXApi</span>.handleOpen(url, delegate:<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DeepLink的局限性"><a href="#DeepLink的局限性" class="headerlink" title="DeepLink的局限性"></a>DeepLink的局限性</h4><h5 id="无法检测目标APP是否安装"><a href="#无法检测目标APP是否安装" class="headerlink" title="无法检测目标APP是否安装"></a>无法检测目标APP是否安装</h5><blockquote><p>我知道你叫什么就可以调起你，但是我不知道你在不在。</p></blockquote><p>H5无法获取APP是否已经安装过，所以大部分的处理方案是在发起调用APP的链接之后几秒直接跳转到对应APP的下载页面。</p><p>即如果能够调起APP，用户就不会再关注H5页面， H5页面跳到哪里用户也看不见。</p><p>反之就稍等一下跳转到APP的下载页面引导用户下载。</p><h5 id="Scheme冲突"><a href="#Scheme冲突" class="headerlink" title="Scheme冲突"></a>Scheme冲突</h5><blockquote><p>和你叫周杰伦我也叫周杰伦一样，大家都是周杰伦。</p><p>当周杰伦真正回应你的呼唤的时候你才知道你调起的是哪个周杰伦，真~薛定谔的周杰伦…</p></blockquote><p>由于每家的APP都自己注册自己的URL Scheme，所以有可能出现两家APP的URL Scheme注册的一样的情况。当两个APP都安装之后就会出现问题，不确定调起的是哪个APP。</p><h5 id="调起流程冗余且可能被阻断"><a href="#调起流程冗余且可能被阻断" class="headerlink" title="调起流程冗余且可能被阻断"></a>调起流程冗余且可能被阻断</h5><blockquote><p>将在xxx中打开页面，是否继续？</p></blockquote><p>由于是使用js方法openURL来调起的APP，在调起之前系统会询问你是否在xxxAPP中打开连接。</p><p>这个询问是一个比较突兀的alert弹窗，所以在不知情的用户看来可能会认为存在一定的风险从而取消打开导致唤起APP中断。如果在这里中断则用户极有可能会直接返回上一页或者直接取消整个操作，前功尽弃！</p><h3 id="UniversalLink技术"><a href="#UniversalLink技术" class="headerlink" title="UniversalLink技术"></a>UniversalLink技术</h3><blockquote><p>Seamlessly link to content inside your app, or on your website in iOS 9 or later. With universal links, you can always give users the most integrated mobile experience, even when your app isn’t installed on their device.</p><p>苹果开发文档</p></blockquote><p><code>UniversalLink </code>技术是苹果在<code>iOS9</code>之后推出的一种使用<code>HTTPS</code>协议的，可以方便得使用已经存在的链接同时打开网址和唤起APP的新功能。</p><p>相对于DeepLink技术来说，UniversalLink在使用体验上是类似的。明显区别在于用户点击了支持的通用链接后会直接调起APP，进入APP内部处理逻辑，而不会再弹起提示信息弹窗以达到从H5页面无缝衔接到APP内部的效果。（可能会在第一次使用UniversalLink时还会弹窗，但是授权之后就不再弹出了）</p><h4 id="UniversalLink的优点"><a href="#UniversalLink的优点" class="headerlink" title="UniversalLink的优点"></a>UniversalLink的优点</h4><p>但是相对于<code>DeepLink</code>技术，<code>UniversalLink</code>技术还具有着以下优点：</p><p><strong>唯一</strong>：与自定义<code>URL</code>方案不同，其他应用无法声明通用链接，因为通用链接使用的是指向您网站的标准<code>HTTP</code>或<code>HTTPS</code>链接</p><blockquote><ul><li><strong>Unique.</strong> Unlike custom URL schemes, universal links can’t be claimed by other apps, because they use standard HTTP or HTTPS links to your website.</li></ul></blockquote><p>每个APP控制自身可以支持的通用链接的域名，由于域名的注册和解析都具有唯一性，通用链支持的域名一定不会出现和别家APP重复的情况。</p><hr><p><strong>安全</strong>：当用户安装您的应用程序时，iOS会检查您已上传到Web服务器的文件，以确保您的网站允许您的应用程序代表其打开URL。只有您可以创建和上传此文件，因此您的网站与应用程序的关联是安全的。</p><blockquote><ul><li><strong>Secure.</strong> When users install your app, iOS checks a file that you’ve uploaded to your web server to make sure that your website allows your app to open URLs on its behalf. Only you can create and upload this file, so the association of your website with your app is secure.</li></ul></blockquote><p>通用链接的域名配置写在项目中且每个可以支持通用链的域名都需要上传一份提供判断是否满足通用链接对应的配置文件。</p><p>配置文件规定了支持通用链功能的域名后的path和可以调起的APP，比如配置文件中规定了<code>www.abc.com/app/UniversalLink/*</code>这个路径可以打开<code>abcAPP</code>，那么只有访问对应的链接才能调起对应的APP。</p><hr><p><strong>灵活</strong>：即使未安装您的应用程序，通用链接也可以使用。如果未安装您的应用程序，点击指向您网站的链接可在Safari中打开内容。</p><blockquote><ul><li><strong>Flexible.</strong> Universal links work even when your app is not installed. When your app isn’t installed, tapping a link to your website opens the content in Safari, as users expect.</li></ul></blockquote><p>不用管用户是否安装了对应的APP，如果没有安装对应的APP，用户点击的链接也是一个有效的页面地址，会在浏览器中继续打开所点击的链接呈现出对应的内容。</p><p>常规的做法是在某个通用链链接的地址上放APP的下载引导页，如果用户未安装APP而点击了通用链接就会直接跳转到下载页。</p><p>对于iOS用户来说这个下载页也可以尝试重定向到<code>App Store</code>的通用链接。<code>App Store</code>对每个APP的下载页面都提供了可用的通用链接，重定向到<code>App Store</code>通用链会直接调起应用商店且打开APP下载页。</p><hr><p><strong>简单</strong>：一个URL既适用于您的网站，也适用于您的应用程序。</p><blockquote><ul><li><strong>Simple.</strong> One URL works for both your website and your app.</li></ul></blockquote><p>一个正常使用的URL即可当做通用链功能进行配置，同时不影响其本身的页面和功能。</p><hr><p><strong>私有</strong>：其他应用程序可以与您的应用程序通信，而无需知道您的应用程序是否已安装。</p><blockquote><ul><li><strong>Private.</strong> Other apps can communicate with your app without needing to know whether your app is installed.</li></ul></blockquote><p>通用链可以暴露给别的应用程序使用，像打开普通的webview一样的方式调起APP，而不用关心你是否真正下载了APP。你的通用链的功能和设置对其他APP来说是透明的。</p><hr><p><strong>短信、备忘录、邮件内部均可使用</strong>：</p><blockquote><p>使用通用链的一大优势。</p></blockquote><p>在iOS系统自带的短信、备忘录甚至邮件内的网页链接的点击也可以正常调起APP，这样发送给用户的引流短信或者邮件中均可附带对应活动的链接，如果用户有安装我们的APP，在点击链接时可以直接导向到APP内部对应的活动页面，不再需要Safari做中间人角色。如果用户未安装APP则跳到对应的活动页面，然后重定向到App Store的下载页。</p><hr><h4 id="如何配置UniversalLink"><a href="#如何配置UniversalLink" class="headerlink" title="如何配置UniversalLink"></a>如何配置UniversalLink</h4><p>网上很多朋友都分享了他们配置UniversalLink的过程，但是我还是建议去苹果官网上按照最新的文档说明进行配置。</p><p><a href="https://developer.apple.com/documentation/xcode/supporting-associated-domains">Support Universal Links</a></p><blockquote><ul><li>Create an <code>apple-app-site-association</code> file that contains JSON data about the URLs that your app can handle.</li><li>Upload the <code>apple-app-site-association</code> file to your HTTPS web server. You can place the file at the root of your server or in the <code>.well-known</code> subdirectory.</li><li>Prepare your app to handle universal links.</li></ul></blockquote><p>大体上分为三个步骤:</p><ol><li><p>在xcode的Associated Domains配置项中添加你需要映射的链接</p><p>一般需要先去开发者账号的管理网站上为APP根证书开通这个功能，然后在XCode上进行域名配置。</p><p><img src="https://cdn.zcx.info/008i3skNly1gvw7qzmkjdj30zn07lglw.jpg"></p></li><li><p>创建<code>apple-app-site-association</code>文件并编辑配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;applinks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;apps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;appID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9JA89QQLNQ.com.apple.wwdc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;/wwdc/news/&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/videos/wwdc/2015/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;appID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ABCD1234.com.apple.wwdc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;*&quot;</span> <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>The <code>appIDs</code> and <code>apps</code> keys specify the application identifiers for the apps that are available for use on this website along with their service types. Use the following format for the values in these keys:</p><p><Application Identifier Prefix>.<Bundle Identifier></p><p>前缀使用APPId 可以在 App Store Connect网站上找到APP的id，后面是APP的Bundle ID，可以在Xcode签名管理的地方找</p></blockquote></li><li><p>将<code>apple-app-site-association</code>文件放在链接的域名服务根目录下</p><p>这个文件使用json格式但是并不能设置.json扩展名，仅仅作为纯文本文件放在对应链接域名下的根目录或者<code>.well-known</code>目录下，以方便系统访问到配置。</p><p>比如你关联的域名为 <a href="http://www.test.com/">www.test.com</a> ，就需要把<code>apple-app-site-association</code>文件放在服务器的根目录下，在浏览器访问</p><p><a href="https://www.test.com/apple-app-site-association">https://www.test.com/apple-app-site-association</a> 链接可以下载此文件或者直接打开此文件。</p></li></ol><h4 id="配置UniversalLink需要注意的问题"><a href="#配置UniversalLink需要注意的问题" class="headerlink" title="配置UniversalLink需要注意的问题"></a>配置UniversalLink需要注意的问题</h4><ol><li>配置<code>apple-app-site-association</code>的域名必须支持HTTPS，且访问的链接没有被重定向</li><li>每个被链接的域名下都要有自身的配置<code>apple-app-site-association</code>文件，<strong><code>www.test.com</code>和 <code>test.com</code> 不是同一个域名</strong>，如果需要每个域名都需要通用链接功能则需要每个域名下都配置一个对应的文件。<strong>如果这两个域名有重写规则且属于同一台服务器则会优先生效<code>www.test.com</code>而忽略<code>test.com</code></strong>。（虽然大部分公司都是将test.com重写为<a href="http://www.test.com,但是也有为了seo反向重写的例子)/">www.test.com，但是也有为了SEO反向重写的例子）</a></li><li>从 macOS 11 和 iOS 14 开始，应用程序不再直接向您的网络服务器请求<code>apple-app-site-association</code>文件。相反，他们将这些请求发送到专用于关联域的 Apple 管理的内容交付网络 (CDN)。所以在APP启动阶段不会抓到对应域名和路径的请求了。</li><li>第一次安装APP的时候苹果CDN服务会在24 小时内为您的域请求<code>apple-app-site-association</code>文件进行配置，非第一次安装时每周检查一次通用链配置更新。</li></ol><h3 id="特殊的微信环境"><a href="#特殊的微信环境" class="headerlink" title="特殊的微信环境"></a>特殊的微信环境</h3><p>鉴于国内的网络社交大环境基本以微信为中心，所以每个APP的引流都绕不开微信生态环境。</p><p>而微信属于应用层APP，并不能像操作系统一样开放，基于安全性考虑，微信针对Deeplink和UniversalLink均做了不同程度的屏蔽。</p><h4 id="安全域名回调"><a href="#安全域名回调" class="headerlink" title="安全域名回调"></a>安全域名回调</h4><p>在微信内部浏览器中是无法直接调起Deeplink的，一般通过微信分享出链接卡片，打开目的页面后再通过微信开放平台提供的安全域名功能来做Deeplink调用。</p><p>js调用安全域名下的DeepLink后会通过微信的onReq回调来接收请求，然后解析传递的数据进而做出页面跳转功能。</p><p>大体的逻辑如下</p><p><img src="https://cdn.zcx.info/008i3skNly1gw4bj7l2lej31280u0411.jpg" alt="微信环境下使用DeepLink流程"></p><h4 id="通用链跳转"><a href="#通用链跳转" class="headerlink" title="通用链跳转"></a>通用链跳转</h4><p>而针对UniversalLink的屏蔽则表现为无法通过UniversalLink调起APP，只能打开对应的落地页。不过最近由于某些政策的调整，微信针对UniversalLink的屏蔽已经被放开了。目前可以正常在微信环境内使用通用链跳转功能（只要你要跳转的目的链接和当前链接是跨域的并且正确安装配置了对应的通用链的APP）。</p><p><img src="https://cdn.zcx.info/008i3skNly1gw7uwunklrj31da0u0n07.jpg"></p><h4 id="屏蔽链接分享"><a href="#屏蔽链接分享" class="headerlink" title="屏蔽链接分享"></a>屏蔽链接分享</h4><p>鉴于对UniversalLink的放开，微信对某些竞争对手做出了限制链接分享的功能。比如某多多和某宝是无法使用微信卡片分享的，所以针对这种场景他们做出了分享文字到微信的功能，即发送常一大串带标识码的文本到微信，然后通过系统粘贴板作为中转到APP内（常见的“复制这段话到xxxAPP打开即可获得xxx红包”）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不论是DeepLink技术 还是UniversalLink技术，都可以实现我们的需求。</p><p>在使用体验上来说还是UniversalLink技术更胜一筹。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;iOS-一键唤起APP方案参考&quot;&gt;&lt;a href=&quot;#iOS-一键唤起APP方案参考&quot; class=&quot;headerlink&quot; title=&quot;iOS 一键唤起APP方案参考&quot;&gt;&lt;/a&gt;iOS 一键唤起APP方案参考&lt;/h2&gt;&lt;p&gt;移动端业务发展过程中，几乎每个公司都</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="一键唤起" scheme="https://zcx4u.github.io/tags/%E4%B8%80%E9%94%AE%E5%94%A4%E8%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 如何做一个九宫格GIF播放器</title>
    <link href="https://zcx4u.github.io/2021/12/06/%E4%BF%A1%E6%81%AF%E6%B5%81GIF%E8%BD%AE%E6%92%AD%E6%A1%86%E6%9E%B6/"/>
    <id>https://zcx4u.github.io/2021/12/06/%E4%BF%A1%E6%81%AF%E6%B5%81GIF%E8%BD%AE%E6%92%AD%E6%A1%86%E6%9E%B6/</id>
    <published>2021-12-05T16:00:00.000Z</published>
    <updated>2025-03-12T11:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何做一个九宫格GIF播放器"><a href="#如何做一个九宫格GIF播放器" class="headerlink" title="如何做一个九宫格GIF播放器"></a>如何做一个九宫格GIF播放器</h1><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>APP V9.4.0版本上线了类似朋友圈的动态，包含文字及最多9张图片。</p><p>动态2期内容中九宫格图片内追加了GIF格式的图片，并要求多张GIF图片在九宫格内循环播放，且优先播放信息流内第一个动态中包含的GIF图片。可参考微博信息流内GIF组的播放表现。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><h3 id="GIF播放"><a href="#GIF播放" class="headerlink" title="GIF播放"></a>GIF播放</h3><p>GIF图是包含若干帧图片的图片组，由于阿里云存储或者其他存储容器中的文件特征，许多图片路径并不带.gif或.GIF的后缀，所以不能仅通过比对文件名来识别GIF图。而通过<strong>二进制数据</strong>中来标记其文件类型的固定的<strong>位特征</strong>来区分较为准确。</p><p>目前我们项目中集成了优秀的开源网络图片框架 <code>&#39;Kingfisher&#39;</code>，其中包含的 <code>AnimatedImageView</code>类能有效识别GIF文件类型和实现精细的播放控制，且使用方便，仅需要给图片view设置网络图片的URL。</p><h3 id="图片对齐方式"><a href="#图片对齐方式" class="headerlink" title="图片对齐方式"></a>图片对齐方式</h3><p>需求中同时需要支持图片设置顶部对齐裁剪和左部对齐裁剪，1期项目中 <code>KrShortContentImageView</code>类已使用 <code>UIImageViewAlignmentMask</code>来实现此需求。</p><p><code>UIImageViewAlignmentMask</code>的实现原理为要显示的图片View的外层嵌套一个”相框”容器View，图片View根据原图的比例来进行等比例缩放，再根据对齐方式使用“相框”来裁剪，从而做到顶部对齐或者左部对齐的视觉效果。</p><p>GIF图片同时满足此对齐方式的需求，所以只要把内部的图片View替换为支持GIF播放的 <code>AnimatedImageView</code>即可。</p><h3 id="播放控制"><a href="#播放控制" class="headerlink" title="播放控制"></a>播放控制</h3><h4 id="顺序播放与循环播放"><a href="#顺序播放与循环播放" class="headerlink" title="顺序播放与循环播放"></a>顺序播放与循环播放</h4><p><code>AnimatedImageView</code>默认自动播放GIF，与我们的需求不符合，所以这里需要关闭其自动播放功能改为手动控制播放列表的顺序播放和整体循环播放。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">var</span> realImageView <span class="operator">=</span> <span class="type">AnimatedImageView</span>().then &#123; img <span class="keyword">in</span></span><br><span class="line">    img.autoPlayAnimatedImage <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    img.contentMode <span class="operator">=</span> .scaleAspectFill</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺其自然的我们创建一个 <code>KrShortContentImageView</code>数组作为播放列表，数组中保存的每一个view都可以视为一个播放器来使用。</p><p>每次获取可以播放的view数组后我们从第一个view开始播放，在第一个view的GIF播放完毕后通过代理回到列表中调用下一个view的播放，且当播放的是最后一个view的时候回到数组头进行循环即可。</p><p>这里我们实现 <code>AnimatedImageView</code>的代理 <code>AnimatedImageViewDelegate</code>方法来监控每一个GIF的播放结束。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">animatedImageView</span>(<span class="keyword">_</span> <span class="params">imageView</span>: <span class="type">AnimatedImageView</span>, <span class="params">didPlayAnimationLoops</span> <span class="params">count</span>: <span class="type">UInt</span>) &#123;</span><br><span class="line">  <span class="comment">///每一个AnimatedImageView播放完毕后会调用这里的代理方法来播放下一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样顺其自然的我们创建了一个来集中处理播放逻辑和向外提供服务方法的单例类和传递GIF播放和加载事件的代理协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 三个方法分别处理图片加载成功、图片加载失败、GIF播放完毕</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">KrShortContentImageViewDelegate</span>: <span class="title class_ inherited__">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">krShortContentImageViewLoadImageDidSuccess</span>(<span class="params">imageView</span>: <span class="type">KrShortContentImageView</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">krShortContentImageViewLoadImageFailure</span>(<span class="params">imageView</span>: <span class="type">KrShortContentImageView</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">krShortContentImageViewDidFinishAnimation</span>(<span class="params">imageView</span>: <span class="type">KrShortContentImageView</span>, <span class="params">gifView</span>: <span class="type">AnimatedImageView</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 动态列表播放器管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShortContentGifListPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> `default` <span class="operator">=</span> <span class="type">ShortContentGifListPlayer</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="网络加载数据控制"><a href="#网络加载数据控制" class="headerlink" title="网络加载数据控制"></a>网络加载数据控制</h4><p>鉴于网络状态的波动，不能保证每一个GIF的加载都能很快完成，我们在 <code>KrShortContentImageView</code>类中增加了 <code>UIActivityIndicatorView</code>转动小菊花来表示此GIF图片正在加载中。</p><p>同时我们需要一个状态变量标识GIF资源的加载状态，以及简单的变化逻辑。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 图片加载状态机</span></span><br><span class="line"><span class="keyword">var</span> imageLoadState: <span class="type">LoadingState</span> <span class="operator">=</span> .initial </span><br><span class="line"></span><br><span class="line"><span class="comment">/// 图片加载过程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">setRealImage</span>(<span class="params">withUrl</span> <span class="params">url</span>: <span class="type">URL</span>?) &#123;</span><br><span class="line">  <span class="keyword">self</span>.imageLoadState <span class="operator">=</span> .loading</span><br><span class="line">  realImageView.kf.setImage(with: url, placeholder: <span class="type">UIImage</span>(color: <span class="type">KrColor</span>.<span class="type">Fill</span>.placeHolder), options: [], progressBlock: <span class="literal">nil</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (result) <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> `self` <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      <span class="keyword">switch</span> result &#123;</span><br><span class="line">      <span class="keyword">case</span> .success(<span class="keyword">_</span>):</span><br><span class="line">          <span class="keyword">self</span>.imageLoadState <span class="operator">=</span> .success</span><br><span class="line">          <span class="comment">// 通知代理GIF加载成功可以播放GIF</span></span><br><span class="line">          <span class="keyword">self</span>.loadingImageDelegate<span class="operator">?</span>.krShortContentImageViewLoadImageDidSuccess(imageView: <span class="keyword">self</span>)</span><br><span class="line">          <span class="keyword">self</span>.updateRealImageLayout()</span><br><span class="line">      <span class="keyword">case</span> .failure(<span class="keyword">_</span>):</span><br><span class="line">          <span class="keyword">self</span>.imageLoadState <span class="operator">=</span> .fail(msg: <span class="string">&quot;图片加载失败&quot;</span>, image: <span class="string">&quot;&quot;</span>)</span><br><span class="line">          <span class="comment">// 通知代理GIF加载失败可以播放下一个GIF</span></span><br><span class="line">          <span class="keyword">self</span>.loadingImageDelegate<span class="operator">?</span>.krShortContentImageViewLoadImageFailure(imageView: <span class="keyword">self</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弱网或者超时处理"><a href="#弱网或者超时处理" class="headerlink" title="弱网或者超时处理"></a>弱网或者超时处理</h4><p>弱网和超时暂时没有做自定义的超时时间，使用了kf框架内部的超时时间。在播放GIF时如果发现当前的图片正在加载中就把loadingView展示出来等待其加载，当kf.setImage方法回调失败时通过代理告诉管理器去播放下一个。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> gifContent.imageLoadState &#123;</span><br><span class="line">  <span class="keyword">case</span> .success:</span><br><span class="line">      gifContent.hideLoading()<span class="comment">// 收起loading层</span></span><br><span class="line">      gifContent.startAnimating()<span class="comment">// 开始播放GIF</span></span><br><span class="line">  <span class="keyword">case</span> .loading:</span><br><span class="line">      gifContent.showLoading()<span class="comment">// 展示loading层</span></span><br><span class="line">  <span class="keyword">case</span> .fail(<span class="keyword">let</span> err, <span class="keyword">_</span>):</span><br><span class="line">      playNextGif()<span class="comment">// 播放下一个</span></span><br><span class="line">      <span class="type">SwiftyBeaver</span>.error(<span class="string">&quot;播放GIF出错,<span class="subst">\(err)</span>&quot;</span>, context: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">      playNextGif()</span><br><span class="line">      <span class="type">SwiftyBeaver</span>.error(<span class="string">&quot;播放GIF出错,GIF未初始化成功&quot;</span>, context: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滚动结束后获取播放列表"><a href="#滚动结束后获取播放列表" class="headerlink" title="滚动结束后获取播放列表"></a>滚动结束后获取播放列表</h3><p>推荐信息流、关注信息流、动态流中均包含动态图片九宫格。滚动停止后如何取出可以播放的 <code>KrShortContentImageView</code>列表成为了关键问题。</p><p>为了达到较好的播放效果这里我们定义一个概念：</p><blockquote><p>如果GIF图在屏幕上渲染出并显示了超出一半的范围，则视为此图是可以播放的。</p></blockquote><p>介于每个GIF图拥有自身的显示标准（宽高），这里需要计算自身高度的50%来和信息流显示区域进行对比。需要我们把每个GIF图的 <code>Frame</code>计算出来，然后逐层转换坐标系到信息流的主显示层进行可展示区域的<strong>交集计算</strong>，如果和可展示区域相交则判断此GIF图是可以播放的。</p><p>以推荐信息流为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 播放Gif列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">playShortContentGifList</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> indexPaths: [<span class="type">IndexPath</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">let</span> cells <span class="operator">=</span> tableView.visibleCells</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> cells.count &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> indexPath <span class="operator">=</span> tableView.indexPath(for: cells[index]) &#123;</span><br><span class="line">            indexPaths.append(indexPath)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> needsPlayGifList: [<span class="type">KrShortContentImageView</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="comment">/// 这里逻辑是可优化的 之所以先遍历cell取indexPath是为了保证indexPath是从小到大排列的，本来这里还有一个indexPath数组的排序</span></span><br><span class="line">    <span class="comment">/// 重构过程中认识到visibleCells取出时就是有序的，只是把排序方法删掉了，当时没有改canDisplayGifViews的参数，后来忘记了...</span></span><br><span class="line">    <span class="comment">/// 遍历第一个包含可播放的GIF列表的Cell进行播放</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> indexPaths.count  &#123;</span><br><span class="line">        <span class="keyword">let</span> imageList <span class="operator">=</span> canDisplayGifViews(indexPath: indexPaths[index])</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>imageList.isEmpty &#123;</span><br><span class="line">            needsPlayGifList.append(contentsOf: imageList)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ShortContentGifListPlayer</span>.default.setNeedsPlayGifList(gifList: needsPlayGifList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片动态内部满足可播的gif列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">canDisplayGifViews</span>(<span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; [<span class="type">KrShortContentImageView</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> cell <span class="operator">=</span> <span class="keyword">self</span>.tableView.cellForRow(at: indexPath), <span class="keyword">let</span> provider <span class="operator">=</span> cell <span class="keyword">as?</span> <span class="type">ShortContentGifListProvider</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">    <span class="comment">/// 获取GIF列表</span></span><br><span class="line">    <span class="keyword">let</span> list <span class="operator">=</span> provider.provideGifViewList()</span><br><span class="line">    <span class="keyword">let</span> rectInTableView <span class="operator">=</span> tableView.rectForRow(at: indexPath)</span><br><span class="line">    <span class="keyword">var</span> showList: [<span class="type">KrShortContentImageView</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> list.count &#123;</span><br><span class="line">        <span class="keyword">let</span> imageFrame <span class="operator">=</span> list[index].frame</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> superView <span class="operator">=</span> list[index].superview <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;<span class="comment">//注意cell内层结构</span></span><br><span class="line">        <span class="comment">/// 坐标系转换</span></span><br><span class="line">        <span class="keyword">let</span> imageFrameInCell <span class="operator">=</span> superView.convert(imageFrame, to: cell)</span><br><span class="line">        <span class="keyword">let</span> imageFrameInTable <span class="operator">=</span> <span class="type">CGRect</span>(x: rectInTableView.origin.x <span class="operator">+</span> imageFrameInCell.origin.x,</span><br><span class="line">                                       y: rectInTableView.origin.y <span class="operator">+</span> imageFrameInCell.origin.y,</span><br><span class="line">                                       width: imageFrame.size.width, height: imageFrame.size.height)</span><br><span class="line">        <span class="keyword">let</span> reactInMainView <span class="operator">=</span> tableView.convert(imageFrameInTable, to: <span class="keyword">self</span>.view)</span><br><span class="line">        <span class="comment">/// 计算可播区域</span></span><br><span class="line">        <span class="keyword">let</span> safeShownGifArea <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: ceil(imageFrame.size.height <span class="operator">/</span> <span class="number">2</span>), </span><br><span class="line">                                      width: view.bounds.size.width, </span><br><span class="line">                                      height: view.bounds.height <span class="operator">-</span> imageFrame.size.height))</span><br><span class="line">        <span class="comment">/// 交集计算</span></span><br><span class="line">        <span class="keyword">if</span> safeShownGifArea.intersects(reactInMainView) &#123;</span><br><span class="line">            showList.append(list[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> showList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信息流刷新处理"><a href="#信息流刷新处理" class="headerlink" title="信息流刷新处理"></a>信息流刷新处理</h3><p>开发过程中发现信息流经常会有reload的操作，导致动态九宫格刷新数据，同时刷新了GIF的View，此时TableView会从复用池中获取一个新的动态模板使用，也就是说此时显示的GIF虽然图片内容和刷新之前一样但是其实质已经是一个新的GIF了（指针值已经变化）。此时正在播放GIF的View从九宫格上移除，GIF的播放被中断。</p><p>如果刷新后再手动调一次播放方法，计算逻辑会重新计算需要播放的GIF，如果滚动位置没有变化会计算出和刷新之前相同的GIF图播放列表（GIF文件URL相同），然后从第一个开始播放。</p><p>这样的话存在两个问题：</p><p>1：GIF列表播放进度被重置。当前正在播放第三个GIF&gt;触发刷新&gt;重新计算&gt;从头开始播放。</p><p>2：GIF播放帧进度被重置。当前正在播放第一个GIF（共60帧）且播放到第30帧图片&gt;触发刷新&gt;重新计算&gt;从头开始播放&gt;开始播放第一个GIF的第一帧。</p><p>当然，第一个问题我们尝试通过记录当前正在播放的GIF的URL来判断播放的位置的方法来解决，但是由于替换了承载GIF的View，播放帧被重置的问题是无法解决的。这样当弹起输入框、点赞等操作刷新动态Cell时无法做到无痕刷新，用户正在观看的GIF被中断，体验较差。</p><p>所以如果想解决问题2应<strong>避免让GIF直接在信息流中播放</strong>。</p><p>这里我们在 <code>ShortContentGifListPlayer</code>播放管理器中持有一个专门用来播放GIF的图片类 <code>gifContent</code>。然后将变化较大且较难控制的动态九宫格中的图片列表作为展示真正播放GIF的容器 <code>containerList</code>来管理，在信息流刷新时仅仅替换GIF容器，而不影响正在播放的GIF图片。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 真正播放的gif</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> gifContent <span class="operator">=</span> <span class="type">KrShortContentImageView</span>()</span><br><span class="line"><span class="comment">/// 当前的gif载体superview</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> currentContainer: <span class="type">KrShortContentImageView</span>?</span><br><span class="line"><span class="comment">/// 载体列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> containerList: [<span class="type">KrShortContentImageView</span>] <span class="operator">=</span> []</span><br></pre></td></tr></table></figure><p>每次触发信息流刷新时均重新计算GIF播放容器列表，对比正在播放的GIF的URL和容器的URL，把正在播放的GIF放到对应的容器中，做到视觉内无痕替换。</p><p>每次GIF播放完毕之后寻找下一个容器，从容器中获取GIF的图片URL进行加载。</p><p>如果播放完毕后找不到新的容器则界定为播放逻辑停止，整个播放器变为非活跃状态。</p><p><img src="https://cdn.zcx.info/202302221018159.jpg" alt="示意图"></p><hr><p>解决上述问题2后，问题1的解决方案也获得了优化。</p><p>鉴于我们动态流九宫格图片组经常会从推荐频道进入动态流然后从动态流再进入动态详情页，这三处位置的GIF都需要播放，每次进入后新页面都需要重新计算播放列表，而这种翻页的操作又携带相同（按照图片URL计算）的GIF组。</p><p>这样的场景就需要我们把不同位置的相同GIF列表记忆播放进度，即接力播放。</p><p>所以我们定义一个接力播放的规则：</p><blockquote><p>新GIF列表包含正在播放的GIF且新列表是当前播放的GIF列表的子集视为可以接力播放</p></blockquote><p>例如当前正在播放 <code>[A,B,C,D,E,F,G]</code>列表且正在播放 <code>GIF_C</code>，这个时候某个操作计算出了新的播放列表 <code>[A,B,C,D,E]</code>。我们发现新的播放列表是旧的播放列表的<strong>子集</strong>，且新列表<strong>包含</strong>了正在播放的 <code>GIF_C</code>，这个时候我们需要把正在播放的 <code>GIF_C</code>移动到新列表的 <code>容器C</code>上且设置播放进度为C，而不是重新加载A的URL进行GIF播放。</p><p>这样操作减少了GIF图重新播放的次数，降低了图片数据IO次数和GPU重新渲染的次数，将翻页的GIF图平滑过渡到新的播放列表。</p><h2 id="功能拓展"><a href="#功能拓展" class="headerlink" title="功能拓展"></a>功能拓展</h2><p>综上所述，如果将GIF变为视频或者实况照片或者其他任何可以控制开始和结束的功能模块，均可套用此逻辑进行交互。</p><h2 id="总结与优化"><a href="#总结与优化" class="headerlink" title="总结与优化"></a>总结与优化</h2><h3 id="信息流图片缩略"><a href="#信息流图片缩略" class="headerlink" title="信息流图片缩略"></a>信息流图片缩略</h3><p>由于GIF列表使用了固定的专门用来播放的承载器 <code>gifContent</code>,信息流中不再承担播放GIF图的责任，所以信息流中可以完全舍弃加载GIF，而改用加载GIF图的缩略图。缩略图的内存占用更小，加载速度更快，更加适合多图片信息流的展示。</p><p>当点击图片需要加载大图或者滚动停止需要播放GIF的时候再去加载真正的原图以获得较好的显示效果。这样图片原图以懒加载（用时加载）的方式来渲染能够提升信息流中大量图片的加载速度，降低内存消耗。</p><p>移动设备可视区域比较小，九宫格中显示的图片尺寸更小，所以使用缩略图（合适的压缩率）代替原图在视觉效果上不会产生特别大的损失。</p><h3 id="代码逻辑收敛"><a href="#代码逻辑收敛" class="headerlink" title="代码逻辑收敛"></a>代码逻辑收敛</h3><p>当前的代码实现比较散乱，特别是每个GIF转换坐标系时的计算以及和信息流可播区域进行的交集计算。坐标系转换逻辑的复杂度随着GIFView的层级复杂度的提示而显著提升。探索是否存在一种方法判断任意两个VIew是否存在交集（支持设置忽略EdgeInset），以通用的计算方法来代替包含业务View的计算，从而大量降低耦合度，同时减少了复杂度。</p><p>将必要的逻辑抽象为协议，以方便此功能移植到其他频道或者列表。</p><p>随着迭代增加功能，信息流Controller中的事件越来越多，提供内容（比如这次的GIF）的Cell可以考虑自身来计算可执行条件，实现或者调用功能，或者使用VM来降低Controller的臃肿。Controller中仅控制Tableview的代理事件监听然后调用符合条件的Cell内部的功能实现。这样每次有新的功能时仅仅增加新的Cell注册和新协议的调用，避开大量修改臃肿的Controller代码以降低出错的概率。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="坐标系转换简化"><a href="#坐标系转换简化" class="headerlink" title="坐标系转换简化"></a>坐标系转换简化</h3><p>带着疑问研究了一下坐标系转换的方法，发现他是 <code>UICoordinateSpace</code>协议，只包含几个和坐标转换相关的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">UICoordinateSpace</span> : <span class="title class_ inherited__">NSObjectProtocol</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">convert</span>(<span class="keyword">_</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">to</span> <span class="params">coordinateSpace</span>: <span class="type">UICoordinateSpace</span>) -&gt; <span class="type">CGPoint</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">convert</span>(<span class="keyword">_</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">from</span> <span class="params">coordinateSpace</span>: <span class="type">UICoordinateSpace</span>) -&gt; <span class="type">CGPoint</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">convert</span>(<span class="keyword">_</span> <span class="params">rect</span>: <span class="type">CGRect</span>, <span class="params">to</span> <span class="params">coordinateSpace</span>: <span class="type">UICoordinateSpace</span>) -&gt; <span class="type">CGRect</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">convert</span>(<span class="keyword">_</span> <span class="params">rect</span>: <span class="type">CGRect</span>, <span class="params">from</span> <span class="params">coordinateSpace</span>: <span class="type">UICoordinateSpace</span>) -&gt; <span class="type">CGRect</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>UIView</code>是实现这个协议的，所以，在父view的层级内肯定是可以将深层嵌套的子view转换到自身坐标系下的。这样一来我们就不必关心view到底是什么，无论是tableView还是collectionView，可以跨层级将cell上加载的图片的frame计算到上层的。</p><p>所以我们可以将这个方案合并为一个通用的扩展，用一个方法就可以把GIF位置是否满足播放条件给计算出来。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UIView</span> &#123;</span><br><span class="line">    <span class="comment">/// 递归查询是否是自己的subview/多级subview</span></span><br><span class="line">    <span class="comment">/// - Parameter subview: 子view或者深层子view</span></span><br><span class="line">    <span class="comment">/// - Returns: Bool</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isMySubview</span>(<span class="params">subview</span>: <span class="type">UIView</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> subview <span class="operator">!=</span> <span class="keyword">self</span>, <span class="keyword">let</span> subviewSuper <span class="operator">=</span> subview.superview <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> subviewSuper <span class="operator">==</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isMySubview(subview: subviewSuper)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 判断任意一子view或者嵌套深层子view是否显示在了父视图特定的可见区域内</span></span><br><span class="line">    <span class="comment">/// - Parameter subview: 子view或者深层子view</span></span><br><span class="line">    <span class="comment">/// - Returns: Bool</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isSubviewIntersectInAimRect</span>(<span class="params">subview</span>: <span class="type">UIView</span>, <span class="params">inset</span>: <span class="type">UIEdgeInsets</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> subviewSuper <span class="operator">=</span> subview.superview, isMySubview(subview: subview) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> subviewFrameInSuper <span class="operator">=</span> convert(subview.frame, from: subviewSuper)</span><br><span class="line">        <span class="keyword">if</span> subviewFrameInSuper <span class="operator">==</span> .zero <span class="operator">||</span> subviewFrameInSuper.isNull &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> safeShownArea <span class="operator">=</span> bounds.in<span class="keyword">set</span>(by: inset)</span><br><span class="line">        <span class="keyword">return</span> safeShownArea.intersects(subviewFrameInSuper)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用了这个方法后，我们可以对比一下</p><p>旧计算过程：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片动态内部满足可播的gif列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">canDisplayGifViews</span>(<span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; [<span class="type">KrShortContentImageView</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> cell <span class="operator">=</span> <span class="keyword">self</span>.tableView.cellForRow(at: indexPath), <span class="keyword">let</span> provider <span class="operator">=</span> cell <span class="keyword">as?</span> <span class="type">ShortContentGifListProvider</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">    <span class="comment">/// 获取GIF列表</span></span><br><span class="line">    <span class="keyword">let</span> list <span class="operator">=</span> provider.provideGifViewList()</span><br><span class="line">    <span class="keyword">let</span> rectInTableView <span class="operator">=</span> tableView.rectForRow(at: indexPath)</span><br><span class="line">    <span class="keyword">var</span> showList: [<span class="type">KrShortContentImageView</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> list.count &#123;</span><br><span class="line">        <span class="keyword">let</span> imageFrame <span class="operator">=</span> list[index].frame</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> superView <span class="operator">=</span> list[index].superview <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;<span class="comment">//注意cell内层结构</span></span><br><span class="line">        <span class="comment">/// 坐标系转换</span></span><br><span class="line">        <span class="keyword">let</span> imageFrameInCell <span class="operator">=</span> superView.convert(imageFrame, to: cell)</span><br><span class="line">        <span class="keyword">let</span> imageFrameInTable <span class="operator">=</span> <span class="type">CGRect</span>(x: rectInTableView.origin.x <span class="operator">+</span> imageFrameInCell.origin.x, y: rectInTableView.origin.y <span class="operator">+</span> imageFrameInCell.origin.y,  width: imageFrame.size.width, height: imageFrame.size.height)</span><br><span class="line">        <span class="keyword">let</span> reactInMainView <span class="operator">=</span> tableView.convert(imageFrameInTable, to: <span class="keyword">self</span>.view)</span><br><span class="line">        <span class="comment">/// 计算可播区域</span></span><br><span class="line">        <span class="keyword">let</span> safeShownGifArea <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: ceil(imageFrame.size.height <span class="operator">/</span> <span class="number">2</span>), width: view.bounds.size.width, height: view.bounds.height <span class="operator">-</span> imageFrame.size.height)</span><br><span class="line">        <span class="comment">/// 交集计算</span></span><br><span class="line">        <span class="keyword">if</span> safeShownGifArea.intersects(reactInMainView) &#123;</span><br><span class="line">            showList.append(list[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> showList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新计算过程：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一个图片动态内部满足可播的gif列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">canDisplayGifViews</span>(<span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; [<span class="type">KrShortContentImageView</span>] &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> cell <span class="operator">=</span> <span class="keyword">self</span>.tableView.cellForRow(at: indexPath),</span><br><span class="line">  <span class="keyword">let</span> provider <span class="operator">=</span> cell <span class="keyword">as?</span> <span class="type">ShortContentGifListProvider</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">  <span class="keyword">let</span> showList: [<span class="type">KrShortContentImageView</span>] <span class="operator">=</span> provider.provideGifViewList().filter &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> `self` <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">      <span class="comment">// tabbar是覆盖在流上方的，所以可播区域限制增加tabbar的高度</span></span><br><span class="line">      <span class="keyword">let</span> shownInset <span class="operator">=</span> <span class="type">UIEdgeInsets</span>(top: <span class="variable">$0</span>.frame.height <span class="operator">/</span> <span class="number">2</span>, left: <span class="number">0</span>, bottom: <span class="variable">$0</span>.frame.height <span class="operator">/</span> <span class="number">2</span> <span class="operator">+</span> <span class="type">BasicConst</span>.<span class="type">Layout</span>.tabBarHeight, right: <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 交集计算</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.tableView.isSubviewIntersectInAimRect(subview: <span class="variable">$0</span>, inset: shownInset)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> showList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功将复杂的逐层转换布局变成了一个方法实现，代码变得十分简洁，看起来很爽。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何做一个九宫格GIF播放器&quot;&gt;&lt;a href=&quot;#如何做一个九宫格GIF播放器&quot; class=&quot;headerlink&quot; title=&quot;如何做一个九宫格GIF播放器&quot;&gt;&lt;/a&gt;如何做一个九宫格GIF播放器&lt;/h1&gt;&lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="经验记录" scheme="https://zcx4u.github.io/tags/%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>iOS编译优化方案探索与实践-组件篇</title>
    <link href="https://zcx4u.github.io/2021/09/18/iOS%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%BB%84%E4%BB%B6%E7%AF%87/"/>
    <id>https://zcx4u.github.io/2021/09/18/iOS%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%BB%84%E4%BB%B6%E7%AF%87/</id>
    <published>2021-09-17T16:00:00.000Z</published>
    <updated>2025-03-13T09:58:31.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS编译优化方案探索与实践-组件篇"><a href="#iOS编译优化方案探索与实践-组件篇" class="headerlink" title="iOS编译优化方案探索与实践-组件篇"></a>iOS编译优化方案探索与实践-组件篇</h1><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>目前主流的项目构建方案中几乎都使用cocoapods进行组件库管理，不论是第三方开源库还是自研的私有库，都会生成.podspec文件使用cocoapods工具进行维护。</p><p>为了便于进行调试，第三方开源库或私有代码库 我们都以源码的方式进行引入。</p><p>每次在本机进行全量编译或者ci机器进行打包的时候都会先编译pod仓库中的源代码，然后链接到主项目中。</p><p>这个流程没有问题，但是随着项目的的大量迭代和长时间维护，引入的仓库会越来越多。以我们的项目为例，项目迭代了3年左右，引入的第三方仓库达到了30+个。在我的mac上进行一次全量编译时间达到了500s，性能稍差的设备编译消耗的时间更长。</p><p>针对组件库的编译时长的优化方案很简单，把cocoapods仓库中引入的需要编译的源码改成不需要编译的二进制库即可。</p><p>当然一刀切的引入方式切换是不可取的，根据自身的实际情况，对一些基本不会进入调试的代码和一些稳定版本的常用的仓库进行二进制化较为合适。</p><p>针对以上想法有了一些cocoapods插件可以使用。</p><h3 id="Cocoapods-Binary"><a href="#Cocoapods-Binary" class="headerlink" title="Cocoapods-Binary"></a>Cocoapods-Binary</h3><p>cocoapods 1.6.x版本的时候常用的一个仓库，大家可能都用过，其思路是在cocoapods进行install操作时通过将 dependencies 预编译成 binary 后缓存至本地，然后将原有的 Source Code link 到 binary 以几乎零成本的方式实现编译效率的提高。</p><p>也就是说在pod install的过程中先进行预编译，预编译之后每次pod install都将编译完的二进制link到项目，这样就完成了源码到二进制的转化。</p><p>规模较小的团队非常适合这种方案，没有什么额外的成本，成员协作之间也不会产生冲突，通过简单的 :binary &#x3D;&gt; true指令即可设置仓库的二进制和源码的切换。</p><blockquote><p>但是目前这个库不再维护了，同时在swift方面也存在着一些问题<br>由于 CocoaPods 在 1.7.x 以上版本，修改了 framework 生成逻辑，不会把 bundle copy 至 framework，因此我们需要将 Pod 环境固定到 1.6.2<br>pod 要支持 binary，header ref 需要变更为 #import &lt;&gt;或者 @import 以符合 moduler 标准<br>统一 CI 和开发的 compiler 环境，如果项目支持 Swift，不同 compiler 编译产物有 Swift 版本兼容问题<br>最终的 binary size 会比使用源码的时候大一点，不建议最终上传 Store<br>建议 Git ignore Pods 文件夹，否则在 source code 与 binary 切换过程会有大量的 file change，增加 git 负担<br>—引用自<a href="https://juejin.cn/post/6844904025624674311">浅析 Cocoapods-Binary 实现</a></p></blockquote><h3 id="cocoapods-imy-bin"><a href="#cocoapods-imy-bin" class="headerlink" title="cocoapods-imy-bin"></a>cocoapods-imy-bin</h3><p>cocoapods-imy-bin 插件是美柚团队开源的cocoapods二进制管理方案。</p><p>其核心思想是先制作二进制文件，然后上传到文件服务器进行保存，在pod install 阶段动态判断三方库是否在本地私有源有二进制记录，如果有就会将此库的源替换成二进制源然后下载二进制文件，进而link到项目中完成源码和二进制的切换。</p><p><a href="https://juejin.cn/post/6903407900006449160#heading-3">iOS编译速度如何稳定提高10倍以上之一</a></p><p><a href="https://juejin.cn/post/6903408514778497031#heading-1">iOS编译速度如何稳定提高10倍以上之二</a></p><p>所谓实践出真知，咱就试一试看看效果。</p><h3 id="cocoapods-imy-bin实践"><a href="#cocoapods-imy-bin实践" class="headerlink" title="cocoapods-imy-bin实践"></a>cocoapods-imy-bin实践</h3><p><a href="https://github.com/MeetYouDevs/cocoapods-imy-bin/blob/master/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.md">cocoapods-imy-bin使用教程</a></p><p><a href="https://github.com/su350380433/cocoapods-imy-bin-demo">cocoapods-imy-bin-demo工程</a></p><p><a href="https://github.com/su350380433/binary-server">binary-server 静态资源服务器</a></p><p>按照使用教程开始操作：</p><h4 id="1、首先创建二进制仓库私有源"><a href="#1、首先创建二进制仓库私有源" class="headerlink" title="1、首先创建二进制仓库私有源"></a>1、首先创建二进制仓库私有源</h4><p>可以选择私有的github&#x2F;gitlab仓库，这个仓库负责二进制源cocoapods repo的维护。</p><p>添加到本地repo</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add example_spec_bin_dev git<span class="variable">@github</span>.<span class="symbol">com:</span>su350380433/example_spec_bin_dev.git</span><br></pre></td></tr></table></figure><p>坑点：cocoapods-imy-bin配置私有源时只支持ssh，因此要修改以前的https的源，对ssh操作不熟练的需要google出现的问题及解决方案。</p><blockquote><p><a href="mailto:&#x67;&#105;&#x74;&#64;&#x78;&#x78;&#x78;&#x2e;&#99;&#111;&#109;">git@xxx.com</a> ssh一直报错，之前的公钥有密码,通过ssh连接私有库的时候一直报错让输入密码，但是输入之后还是不行,报错无授权,重新生成rsa秘钥对之后尝试还是不行，报同样的错误。最后发现是git地址没有给对，从cocoapods file中拷贝出来的时候带了一个source字符串，所以ssh授权一直失败（地址都错了授权肯定失败啊）</p></blockquote><p>创建repo不能仅仅拉一个git仓库就行了，还得找一个已有的仓库进行.podspec文件push ，否则添加此源之后 执行pod repo update 会一直失败。</p><blockquote><p>新增空的pod repo 之后 pod repo update 一直失败,尝试push一次已有的.podspec文件再更新repo才成功</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pod push 命令</span></span><br><span class="line">pod repo push demo_binary_source <span class="title class_">APPLog</span>.podspec --allow-warnings</span><br></pre></td></tr></table></figure><h4 id="2、搭建静态资源服务器"><a href="#2、搭建静态资源服务器" class="headerlink" title="2、搭建静态资源服务器"></a>2、搭建静态资源服务器</h4><p>本质是一个可以接收和下载文件的服务器，使用Node承载服务，使用MongoDB存储数据。 可自行选择ECS或者其他文件服务器，做测试的话可以在本地搭建。</p><p>先搭建数据库(Mac)</p><p>文档上MongoDB是在官网下载安装的，但是实测有很多文件夹权限问题，改用homebrew安装。<br>brew install mongodb 命令失效，且官网不再开源，这里改用homebrew的社区版。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap mongodb/brew <span class="comment">#先执行这个</span></span><br><span class="line">brew install mongodb-community<span class="variable">@4</span>.<span class="number">2</span> <span class="comment">#等一小会执行这个 安装4.2版本的 </span></span><br></pre></td></tr></table></figure><p>安装完毕后需要设置环境变量才能使用，根据终端使用的zsh还是bash各自在配置文件设置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export <span class="variable constant_">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:/usr/local/Cellar/mongodb-community</span><span class="variable">@4</span>.<span class="number">2</span>/<span class="number">4.2</span>.<span class="number">9</span>/bin</span><br></pre></td></tr></table></figure><p>安装完毕后测试结果，然后使用Mac系统服务的方式打开数据库，这样不用依托终端窗口，即使终端窗口关闭了数据库也不会关闭。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mongod -version <span class="comment">#测试是否安装成功</span></span><br><span class="line"><span class="comment">#除了安装包文件，安装还创建了以下文件和目录：</span></span><br><span class="line"><span class="comment">#配置文件（/usr/local/etc/mongod.conf）</span></span><br><span class="line"><span class="comment">#日志目录（/usr/local/var/log/mongodb）</span></span><br><span class="line"><span class="comment">#数据目录（/usr/local/var/mongodb）</span></span><br><span class="line"><span class="comment">#将MongoDB作为系统服务启动 不再依托终端窗口</span></span><br><span class="line">brew services start mongodb-community<span class="variable">@4</span>.<span class="number">2</span> /<span class="regexp">/启动</span></span><br><span class="line"><span class="regexp">brew services stop mongodb-community@4.2 /</span><span class="regexp">/停止</span></span><br><span class="line"><span class="regexp">brew services restart mongodb-community@4.2 /</span><span class="regexp">/重启</span></span><br></pre></td></tr></table></figure><p>也可以执行mongo shell命令查看数据库启动状态</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><p><img src="https://cdn.zcx.info/008i3skNly1gukuhvxnh2j613i0u0gr602.jpg" alt="mongodb启动shell"></p><p>到这里 你的数据库就搭好了也启动起来了。</p><p>然后搭建静态资源服务器</p><p>先下载服务源码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>su350380433/binary-server.git</span><br><span class="line">cd /binary-server <span class="comment">#进入到你下载binary-server的根目录去</span></span><br><span class="line">npm install <span class="comment">#安装依赖包</span></span><br><span class="line">npm start <span class="comment"># 启动node</span></span><br></pre></td></tr></table></figure><p>这是文件服务器App.js源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./server/routes&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;koa-logger&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">&#x27;koa-body&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span></span><br><span class="line"></span><br><span class="line">mongoose.<span class="title function_">connect</span>(<span class="string">&#x27;mongodb://localhost/binary_database&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">koaBody</span>(&#123; <span class="attr">multipart</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">logger</span>())</span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>())</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure><p>由此可见，文件服务器创建了binary_database数据库，并且占用了8080端口。</p><p>执行了npm start之后可能会出现两个问题</p><p>8080端口已经被占用：出现这个问题有可能是你之前安装过其他服务也占用这个端口，可以切换静态资源文件的使用端口修改app.listen(8080)即可，或者和我一样直接把不用的其他服务关掉。</p><p>数据库连接失败：出现这个问题可以看一下具体的报错内容，根据不同的内容处理。如果出现</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">getaddrinfo <span class="variable constant_">ENOTFOUND</span> localhost     at <span class="title class_">GetAddrInfoReqWrap</span>.onlookup</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样的报错的话很可能是你的设备没有做localhost的127.0.0.1的映射。db使用的链接是ip地址，但是静态资源服务中的代码里连接数据库使用的是localhost，且端口是db的默认端口，如果你数据库改过端口号，那这里一定要修改数据库连接地址。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; binary-server<span class="variable">@0</span>.<span class="number">1.0</span> start /<span class="title class_">Users</span>/zcx/binary-server</span><br><span class="line">&gt; node app.js</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果一切顺利，这里node服务器就启动起来了，监听8080(或你设置的)端口，提供http服务。</p><h4 id="3-安装和初始化cocoapods-imy-bin插件"><a href="#3-安装和初始化cocoapods-imy-bin插件" class="headerlink" title="3 安装和初始化cocoapods-imy-bin插件"></a>3 安装和初始化cocoapods-imy-bin插件</h4><p>安装这一步比较简单 直接执行gem命令安装插件即可</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods-imy-bin</span><br></pre></td></tr></table></figure><p>初始化插件配置：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">xx:</span><span class="title class_">Demo</span> slj<span class="variable">$ </span>pod bin init <span class="comment">#执行这个命令 根据提示信息进行下一步的操作</span></span><br><span class="line"></span><br><span class="line">======  dev 环境 ========</span><br><span class="line"></span><br><span class="line">开始设置二进制化初始信息.</span><br><span class="line">所有的信息都会保存在 /<span class="title class_">Users</span>/slj/.cocoapods/bin_dev.yml 文件中.</span><br><span class="line"><span class="string">%w[bin_dev.yml bin_debug_iphoneos.yml bin_release_iphoneos.yml]</span> </span><br><span class="line">你可以在对应目录下手动添加编辑该文件. 文件包含的配置信息样式如下：</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="symbol">configuration_env:</span> dev</span><br><span class="line"><span class="comment"># 上面这个是环境切换选项 先不改 目前先配一套环境</span></span><br><span class="line"><span class="symbol">code_repo_url:</span> git<span class="variable">@github</span>.<span class="symbol">com:</span>su350380433/example_spec_source.git</span><br><span class="line"><span class="comment"># 上面这个是正在使用的私有源地址</span></span><br><span class="line"><span class="symbol">binary_repo_url:</span> git<span class="variable">@github</span>.<span class="symbol">com:</span>su350380433/example_spec_bin_dev.git</span><br><span class="line"><span class="comment"># 上面这个是新增的二进制私有源地址</span></span><br><span class="line"><span class="symbol">binary_download_url:</span> <span class="symbol">http:</span>/<span class="regexp">/localhost:8080/frameworks</span><span class="regexp">/%s/</span>%s/zip</span><br><span class="line"><span class="comment"># 上面这个是新创建的服务器地址 默认使用的本地 %s是动态替换三方库的名称的 这里不要改</span></span><br><span class="line"><span class="symbol">download_file_type:</span> zip</span><br><span class="line"><span class="comment"># 上面这个是二进制传输用的压缩格式 一般都zip也不用改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上的配置都可以在配置文件里进行更改</span></span><br><span class="line">open /<span class="title class_">Users</span>/zcx/.cocoapods/bin_dev.yml  <span class="comment">#文件保存 插件的配置信息</span></span><br></pre></td></tr></table></figure><p>到这里准备工作就算是就绪了，可以开始制作二进制文件了。</p><h4 id="4-制作二进制文件"><a href="#4-制作二进制文件" class="headerlink" title="4 制作二进制文件"></a>4 制作二进制文件</h4><p>想要制作一系列的三方库二进制组件，必须得有个文件存储三方库的列表吧，所以这里还得准备一个.podspec文件来维护你想要制作的库。</p><p>在项目根目录新增一个<code>demo_binary_source.podspec</code>文件,内容如下（一个基本的依赖文件）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MARK: converted automatically by spec.py. <span class="doctag">@hgy</span></span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Pod::Spec</span>.new <span class="keyword">do</span> |<span class="params">s</span>|</span><br><span class="line">s.name = <span class="string">&#x27;demo_binary_source&#x27;</span></span><br><span class="line">s.version = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">s.description = <span class="string">&#x27;demo_binary_source&#x27;</span></span><br><span class="line">s.license = <span class="string">&#x27;MIT&#x27;</span></span><br><span class="line">s.summary = <span class="string">&#x27;demo_binary_source&#x27;</span></span><br><span class="line">s.homepage = <span class="string">&#x27;https://gitlab-media.corp.demo.com/iOS/krmedium_binary_source&#x27;</span></span><br><span class="line">s.authors = &#123; <span class="string">&#x27;zcx&#x27;</span> =&gt; <span class="string">&#x27;zhouchuanxiang@demo.com&#x27;</span> &#125;</span><br><span class="line">s.source = &#123; <span class="symbol">:git</span> =&gt; <span class="string">&#x27;git@gitlab-media.corp.demo.com:iOS/krmedium_binary_source.git&#x27;</span>, <span class="symbol">:branch</span> =&gt; <span class="string">&#x27;master&#x27;</span> &#125;</span><br><span class="line">        s.requires_arc = <span class="literal">true</span></span><br><span class="line">        s.ios.deployment_target = <span class="string">&#x27;11.0&#x27;</span></span><br><span class="line">        s.source_files = <span class="string">&#x27;Source/**/*.&#123;h,m,c,swift&#125;&#x27;</span></span><br><span class="line">        s.public_header_files = <span class="string">&#x27;Source/**/*.&#123;h,swift&#125;&#x27;</span></span><br><span class="line">        <span class="comment">#objc依赖</span></span><br><span class="line">        s.dependency <span class="string">&#x27;Masonry&#x27;</span>, <span class="string">&#x27;1.1.0&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;MJRefresh&#x27;</span>, <span class="string">&#x27;3.3.1&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;SDWebImage&#x27;</span>, <span class="string">&#x27;5.3.1&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;YYCategories&#x27;</span>, <span class="string">&#x27;1.0.4&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;MJExtension&#x27;</span>, <span class="string">&#x27;3.2.2&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;MBProgressHUD&#x27;</span>, <span class="string">&#x27;1.1.0&#x27;</span></span><br><span class="line">        <span class="comment">#demo项目依赖</span></span><br><span class="line">        s.dependency <span class="string">&#x27;KeychainAccess&#x27;</span>, <span class="string">&#x27;4.1.0&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;Moya/RxSwift&#x27;</span>, <span class="string">&#x27;13.0.1&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;ObjectMapper&#x27;</span>, <span class="string">&#x27;3.4.2&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;IQKeyboardManagerSwift&#x27;</span>, <span class="string">&#x27;6.5.1&#x27;</span> <span class="comment">#键盘管理</span></span><br><span class="line">        s.dependency <span class="string">&#x27;RTRootNavigationController&#x27;</span>, <span class="string">&#x27;0.5.19&#x27;</span> <span class="comment">#UI</span></span><br><span class="line">        s.dependency <span class="string">&#x27;Kingfisher&#x27;</span>, <span class="string">&#x27;5.15.4&#x27;</span> <span class="comment">#图片处理</span></span><br><span class="line">        s.dependency <span class="string">&#x27;Zip&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;SnapKit&#x27;</span>, <span class="string">&#x27;5.0.1&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;Stencil&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;iCarousel&#x27;</span>, <span class="string">&#x27;1.8.3&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;YYText&#x27;</span>, <span class="string">&#x27;1.0.5&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;lottie-ios&#x27;</span>, <span class="string">&#x27;3.1.9&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;YYCache&#x27;</span>, <span class="string">&#x27;1.0.4&#x27;</span></span><br><span class="line">        <span class="comment">#debug调试工具</span></span><br><span class="line">        s.dependency <span class="string">&#x27;NetSwitch&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;LookinServer&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件中所有的<code>dependency</code>依赖都会被尝试制作二进制文件。制作二进制文件之前需要保证所有的<code>repo</code>都是正常的，每个三方库的源都指向原始源（源代码源），我们制作的时候会先获取源码进行编译。<br>把这个文件放在和<code>Podfile</code>同一个目录下，进入此目录，然后执行</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod bin auto --all-make <span class="comment"># 开始制作二进制</span></span><br></pre></td></tr></table></figure><p>这个过程可能会根据你依赖的库报各种错误，比如我遇到的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Installing</span>...</span><br><span class="line"><span class="title class_">Installing</span> <span class="title class_">Realm</span> (<span class="number">3.19</span>.<span class="number">0</span>)</span><br><span class="line"><span class="title class_">Installing</span> <span class="title class_">RealmSwift</span> (<span class="number">3.19</span>.<span class="number">0</span>)</span><br><span class="line"><span class="title class_">Installing</span> demo_binary_source (<span class="number">1</span>)</span><br><span class="line">[!] /bin/bash -c</span><br><span class="line">set -e</span><br><span class="line">sh build.sh cocoapods-setup</span><br><span class="line"></span><br><span class="line"><span class="symbol">sh:</span> build.<span class="symbol">sh:</span> <span class="title class_">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行pod bin auto --all-make 报错 不知道啥原因</span></span><br><span class="line"><span class="comment">#经排查 使用插件后 swiftRealm库附带的下载依赖脚本无法执行</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Running</span> prepare command</span><br><span class="line"><span class="variable">$ </span>/bin/bash -c  set -e sh build.sh cocoapods-setup</span><br><span class="line"><span class="title class_">Downloading</span> <span class="symbol">dependency:</span> <span class="number">10.3</span>.<span class="number">2</span> from <span class="symbol">https:</span>/<span class="regexp">/static.realm.io/downloads</span><span class="regexp">/core/realm</span>-monorepo-xcframework-v10.<span class="number">3.2</span>.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方案</span></span><br><span class="line">单独的库无法处理，这里因为<span class="string">&#x27;Realm&#x27;</span>编译源码也很慢，所以改成<span class="string">&#x27;xcframework&#x27;</span>方式进行引入了。</span><br><span class="line">解决问题的过程中可能遇见<span class="string">&#x27;pod repo&#x27;</span>混乱的问题，</span><br><span class="line">之前尝试的 <span class="string">&#x27;--all-make&#x27;</span>命令 生成了一部分二进制和<span class="string">&#x27;repo&#x27;</span>信息引起混乱</span><br><span class="line">那就全部删掉，删掉<span class="string">&#x27;repo&#x27;</span>源，删掉已经上传的二进制文件从头再来一遍 </span><br></pre></td></tr></table></figure><p>解决完问题后再尝试进行二进制文件制作。如果顺利的话会看到制作结果。</p><p><img src="https://cdn.zcx.info/008i3skNly1gukvojcuwpj60u015rjxk02.jpg"></p><p>同时可以检验一下新创建的 私有源中是否记录的二进制文件的地址信息。</p><p><img src="https://cdn.zcx.info/008i3skNly1gukvrtyptvj61h30u0td202.jpg"></p><p>二进制文件制作好了，就差link到项目中了。</p><p>既然我们更新了私有源，这里最好把<code>cocoapods repo </code>更新一下再安装。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pod repo update --verbose <span class="comment">#更新源</span></span><br><span class="line">pod install --verbose <span class="comment">#你懂得</span></span><br><span class="line"><span class="comment">#然后你会看到执行的结果，部分三方库被替换成了打包好的静态库</span></span><br><span class="line">======  dev 环境 ========</span><br><span class="line"><span class="variable constant_">CDN</span>: trunk <span class="title class_">Relative</span> <span class="symbol">path:</span> <span class="title class_">CocoaPods</span>-version.yml exists! <span class="title class_">Returning</span> local because checking is only performed <span class="keyword">in</span> repo update</span><br><span class="line">cocoapods-imy-bin 插件</span><br><span class="line">- 开始处理 <span class="title class_">Alamofire</span> <span class="number">4.9</span>.<span class="number">1</span> 组件.</span><br><span class="line">specification =<span class="title class_">Alamofire</span> (<span class="number">4.9</span>.<span class="number">1</span>)</span><br><span class="line">#&lt;Pod::Resolver::ResolverSpecification:0x00007fc8369c9630&gt;</span><br><span class="line">cocoapods-imy-bin 插件</span><br><span class="line">- 开始处理 <span class="title class_">AliPlayer</span>SDK_iOS <span class="number">5.4</span>.<span class="number">0</span> 组件.</span><br><span class="line">cocoapods-imy-bin 插件</span><br><span class="line">- 开始处理 <span class="title class_">AliPlayer</span>SDK_iOS/<span class="title class_">AliPlayer</span>SDK <span class="number">5.4</span>.<span class="number">0</span> 组件.</span><br><span class="line">cocoapods-imy-bin 插件</span><br><span class="line">- 开始处理 <span class="title class_">Alipay</span>SDK-iOS <span class="number">15.7</span>.<span class="number">9</span> 组件.</span><br><span class="line">cocoapods-imy-bin 插件</span><br><span class="line">- 开始处理 <span class="title class_">Bugly</span> <span class="number">2.5</span>.<span class="number">90</span> 组件.</span><br><span class="line">........</span><br><span class="line">#&lt;Pod::Resolver::ResolverSpecification:0x00007fc8370b0f48&gt;</span><br><span class="line">【<span class="title class_">AliPlayer</span>SDK_iOS |<span class="params"> 5.4.0】组件无对应二进制版本 , 将采用源码依赖.</span></span><br><span class="line"><span class="params">【AliPlayerSDK_iOS/AliPlayerSDK </span>| <span class="number">5.4</span>.<span class="number">0</span>】组件无对应二进制版本 , 将采用源码依赖.</span><br><span class="line">【<span class="title class_">Alipay</span>SDK-iOS |<span class="params"> 15.7.9】组件无对应二进制版本 , 将采用源码依赖.</span></span><br><span class="line"><span class="params">【Bugly </span>| <span class="number">2.5</span>.<span class="number">90</span>】组件无对应二进制版本 , 将采用源码依赖.</span><br><span class="line">【<span class="title class_">CocoaAsyncSocket</span> |<span class="params"> 7.6.5】组件无对应二进制版本 , 将采用源码依赖.</span></span><br><span class="line"><span class="params">【GTSDK </span>| <span class="number">2.5</span>.<span class="number">5.0</span>】组件无对应二进制版本 , 将采用源码依赖.</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>最后查看<code>xcode</code>中的<code>pod</code>文件夹，从源码切换成了<code>framework</code><br><img src="https://cdn.zcx.info/008i3skNly1gukw1ce7iej60kq0fmq3x02.jpg"><br>如果没有出现<code>framework</code>的话可以尝试再更新一次<code>pod repo </code>和<code>执行 pod install</code></p><p><code>clean</code> 一下进行全量编译可以看到变化，优化前编译需要500s</p><p><img src="https://cdn.zcx.info/008i3skNly1gukw4a4ri8j61tc0lijvv02.jpg"></p><p>优化后<code>tasks</code>减少到2500左右</p><p><img src="https://cdn.zcx.info/008i3skNly1gukw3brvajj60x0038gly02.jpg"></p><p>编译时间减少到300s</p><p><img src="https://cdn.zcx.info/008i3skNly1gukw38z5bdj60nu05eq3w02.jpg"></p><h4 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h4><p>暂时没有测试ci打包机上的命令修改和真正realse发包过程。如果要上生产环境的话需要进行大面积的覆盖测试。切记谨慎行事。</p><h3 id="拓展与思考"><a href="#拓展与思考" class="headerlink" title="拓展与思考"></a>拓展与思考</h3><p>组件库的编译时间减少较为可观，这也许是大家推行项目组件化的原因。随着业务的发展，项目会越来越大，业务拓展后也可能会划分更多的部门。</p><p>每个部门做自己的业务，不关注其他部门的代码。所以如果指定一定的代码规范，制作比如网络请求组件、路由组件等公用组件的基础上，每个业务部门输出自身的业务组件，使用<code>cocoapods</code>进行二进制化管理。代码整体的编译上就可以节省不少时间，提升编译效率，团队间合作也会降低一些成本。</p><p>未来我们的项目也可以考虑分割各个组件，总体做一个壳工程，采用组件化的方案进行代码维护。但是组件化任重而道远，还得得根据自身的实际情况来选择技术方案。组件化和其他设计模式一样，都是为了解决实际问题，不要为了设计而设计。</p><p>当然一些前瞻性的思考还是不能缺少的，未雨绸缪总好过于亡羊补牢！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS编译优化方案探索与实践-组件篇&quot;&gt;&lt;a href=&quot;#iOS编译优化方案探索与实践-组件篇&quot; class=&quot;headerlink&quot; title=&quot;iOS编译优化方案探索与实践-组件篇&quot;&gt;&lt;/a&gt;iOS编译优化方案探索与实践-组件篇&lt;/h1&gt;&lt;h3 id=&quot;序</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="技术调研" scheme="https://zcx4u.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>module importing failed invalid pathname 问题解决</title>
    <link href="https://zcx4u.github.io/2021/09/09/module-importing%20failed-invalid%20pathname/"/>
    <id>https://zcx4u.github.io/2021/09/09/module-importing%20failed-invalid%20pathname/</id>
    <published>2021-09-08T16:00:00.000Z</published>
    <updated>2025-03-13T09:55:52.400Z</updated>
    
    <content type="html"><![CDATA[<p>最近Xcode编译完成后在命令行框里第一行总会报一个错误：</p><blockquote><p>error: module importing failed: invalid pathname</p></blockquote><p>不论是<code>clean</code>还是删除<code>support文件</code>还是<code>重启Xcode</code>都无法解决这个问题。</p><p>于是去google了一番：</p><p><a href="https://stackoverflow.com/questions/59800936/Xcode-11-shows-a-missing-module-error-when-compiling-python-3-8">把target的scheme中的debug executable的选项取消掉就不报这个错了</a></p><p><img src="https://raw.githubusercontent.com/zcx4u/images/master/Hexo/Xcode/008i3skNly1guaiuljmlhj60qi0gmwfh02.jpg" alt="关闭调试器"></p><p>试了一下，有效！但是这个选项不能去掉啊，去掉了这个选项就不能打断点进行调试了。😂</p><hr><p>Realm删除残留导致的问题？](<a href="https://stackoverflow.com/questions/59090655/removed-realm-but-still-getting-this-error-module-importing-failed-invalid-to/59094519#59094519?newreg=5c6ce4372354468b9449dfc34406e472">https://stackoverflow.com/questions/59090655/removed-realm-but-still-getting-this-error-module-importing-failed-invalid-to/59094519#59094519?newreg=5c6ce4372354468b9449dfc34406e472</a>)</p><p>看到朋友们删除Realm之后会出现这个问题，但是我又没有安装过Realm，为何也有这个问题呢。</p><p>回答中提到解决这个问题需要去编辑<code>~/.lldbinit</code>文件，看的我一脸懵逼，对于这种没见过的配置文件我可不敢去乱删乱改。又想起来被错改配置文件支配的恐惧，吃一堑长一智…</p><p>仔细看<code>lldbinit</code>文件命名，好像在哪见过，是LLDB调试器初始化的配置文件，于是在mac根目录下去找了找这个文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个文件的全部内容</span><br><span class="line">### Reveal LLDB commands support - DO NOT MODIFY</span><br><span class="line">    command script import /Applications/Reveal.app/Contents/SharedSupport/Scripts/RevealServerCommands.py</span><br><span class="line">###</span><br></pre></td></tr></table></figure><p>当我看到<code>Reveal.app</code>这个东西的时候便明白是什么问题了，我这台mac之前下载过破解版的Reveal软件用来调试界面。</p><p><code>Reveal</code>的插件需要在LLDB启动的时候加载用来获取UI栈信息，后来改用了<code>Lookin</code>就把<code>Reveal</code>给卸载了，但是<code>.lldbinit</code>中的命令没有改掉。LLDB启动的时候找不到<code>Reveal插件</code>便会报<code>module importing failed: invalid pathname</code>错误。</p><p><img src="https://raw.githubusercontent.com/zcx4u/images/master/Hexo/Xcode/008i3skNly1guaium1xjzj60n805q74o02.jpg"></p><p>同时这也验证了为什么在Xcode中关闭调试就不报这个错了(那肯定是Xcode在debug模式下运行时自动启动了内置的LLDB调试器啦)。</p><p>为了验证是LLDB的问题我把Xcode关闭，打开了终端，输入LLDB命令，然后终端中也报出了相同的错误提示。为了更加理解这个文件的作用，我便又去搜索了一番.lldbinit的作用。</p><blockquote><p>~&#x2F;.lldbinit是每次LLDB启动时会加载的文件。所以一些初始化的事儿，我们可以写入其中中，比如给命令定义别名等。但是由于这时候程序还没有真正运行，也有部分操作无法在里面玩，比如设置断点。</p></blockquote><p>到此我解决了Xcode中每次启动都报错的问题，也明白了这个问题出现的原因，同时也了解到了LLDB相关的新知识。所以当看到一些莫名其妙的报错的时候不要着急也不要焦虑，一定是在你不熟悉的地方出现了异常，当你慢慢理解那些内容的时候，这些报错也许只是一个很小很小的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近Xcode编译完成后在命令行框里第一行总会报一个错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;error: module importing failed: invalid pathname&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不论是&lt;code&gt;clean&lt;/c</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="Xcode" scheme="https://zcx4u.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>iOS-OCR实践</title>
    <link href="https://zcx4u.github.io/2021/08/31/iOS-OCR%E5%AE%9E%E8%B7%B5/"/>
    <id>https://zcx4u.github.io/2021/08/31/iOS-OCR%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-08-30T16:00:00.000Z</published>
    <updated>2025-03-13T09:53:35.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>近期老板提出了某些需求可能需要借助OCR能力来进行图片到文本的转换。</p><p>以下几种方案是对当前可用的免费的OCR的调研。</p><h2 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h2><blockquote><p>Vision 是 Apple 在 WWDC 2017 推出的图像识别框架，它基于 Core ML，所以可以理解成 Apple 的工程师设计了一种算法模型，然后利用 Core ML 训练，最后整合成一个新的框架，相比开源模型然后让开发者自己整合起来，这种方式更安全也更方便我们使用。</p></blockquote><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><blockquote><p>The Vision framework performs face and face landmark detection, text detection, barcode recognition, image registration, and general feature tracking. Vision also allows the use of custom Core ML models for tasks like classification or object detection.</p></blockquote><p>从官方文档中可以得到Vision框架能做的事情</p><table><thead><tr><th align="left"></th><th></th></tr></thead><tbody><tr><td align="left">Face Detection and Recognition</td><td>面部检测</td></tr><tr><td align="left">Machine Learning Image Analysis</td><td>机器学习图像分析</td></tr><tr><td align="left">Barcode Detection</td><td>矩阵码&#x2F;条形码检测</td></tr><tr><td align="left">Image Alignment Analysis</td><td>图像对齐分析</td></tr><tr><td align="left">Text Detection</td><td>文字检测</td></tr><tr><td align="left">Horizon Detection</td><td>水平面检测</td></tr><tr><td align="left">Object Detection and Tracking</td><td>物体检测和追踪</td></tr></tbody></table><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>对于我们需要的OCR功能，Text Detection就可以满足我们的需求，至于别的功能有兴趣的可以试一下。</p><p>Demo中的代码也比较简单就实现了功能</p><ol><li>创建一个<code>VNImageRequestHandler</code>来持有传入的图片</li><li>创建一个<code>VNRecognizeTextRequest</code>请求&#x2F;请求队列</li><li>创建一个<code>VNRequestCompletionHandler</code>函数指针&#x2F;block处理识别成功的回调</li><li>Perform the text-recognition request. 执行请求</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public typealias VNRequestCompletionHandler = (VNRequest, Error?) -&gt; Void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 苹果原生识别 准确率高 速度快</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">ocrAction</span>() &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> path <span class="operator">=</span> <span class="keyword">self</span>.path, <span class="keyword">let</span> img <span class="operator">=</span> <span class="type">UIImage</span>(contentsOfFile: path) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> cgImage <span class="operator">=</span> img.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">// 需要注意的写法</span></span><br><span class="line">    <span class="keyword">let</span> requestHandler <span class="operator">=</span> <span class="type">VNImageRequestHandler</span>(cgImage: cgImage)</span><br><span class="line">    <span class="comment">// 参数是一个函数指针/block</span></span><br><span class="line">    <span class="keyword">let</span> request <span class="operator">=</span> <span class="type">VNRecognizeTextRequest</span>(completionHandler: recognizeTextHandler)</span><br><span class="line">    <span class="comment">// 只有ios14以上支持中文识别</span></span><br><span class="line">    request.recognitionLanguages <span class="operator">=</span> [<span class="string">&quot;zh-Hans&quot;</span>,<span class="string">&quot;zh-Hant&quot;</span>,<span class="string">&quot;en-US&quot;</span>]</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Perform the text-recognition request.</span></span><br><span class="line">        <span class="keyword">try</span> requestHandler.perform([request])</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Unable to perform the requests: <span class="subst">\(error)</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 识别成功的回调 </span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">recognizeTextHandler</span>(<span class="params">request</span>: <span class="type">VNRequest</span>, <span class="params">error</span>: <span class="type">Error</span>?) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> observations <span class="operator">=</span> request.results <span class="keyword">as?</span> [<span class="type">VNRecognizedTextObservation</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> recognizedStrings <span class="operator">=</span> observations.compactMap &#123; observation <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// Return the string of the top VNRecognizedText instance.</span></span><br><span class="line">        <span class="keyword">return</span> observation.topCandidates(<span class="number">1</span>).first<span class="operator">?</span>.string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Process the recognized strings.</span></span><br><span class="line">  <span class="keyword">var</span> res <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> str <span class="keyword">in</span> recognizedStrings &#123;</span><br><span class="line">        res  <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(res)</span><span class="subst">\(str)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    resultLabel.text <span class="operator">=</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>iOS系统内置的API，无需引入多余文件直接调用。</li><li>API使用比较简单，不用考虑多线程切换，成功回调已经全部回到了主线程。</li><li>实测识别准确度还是比较高的。</li></ol><p>缺点：</p><p>只有iOS14以上的系统版本支持设置识别中文。</p><p>可以使用这个方法来判断这个API所支持识别的语言。<code>request.recognitionLanguages</code>属性支持设置ISO标准语言代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     @brief Returns all the supported languages for a given text recognition level. Note that a language supported in one recognition level might not be available in another.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">class</span> <span class="keyword">func</span> <span class="title function_">supportedRecognitionLanguages</span>(<span class="keyword">for</span> recognitionLevel: <span class="type">VNRequestTextRecognitionLevel</span>, revision requestRevision: <span class="type">Int</span>) <span class="keyword">throws</span> -&gt; [<span class="type">String</span>]</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/vision/recognizing_text_in_images">更多Vision识别文字相关文档可参考：Recognizing Text in Images</a></p><h2 id="Tesseract"><a href="#Tesseract" class="headerlink" title="Tesseract"></a>Tesseract</h2><blockquote><p>Tesseract 是一个 OCR 库,目前由 Google 赞助(Google 也是一家以 OCR 和机器学习技术闻名于世的公司)。Tesseract 是目前公认最优秀、最精确的开源 OCR 系统，除了极高的精确度，Tesseract 也具有很高的灵活性。它可以通过训练识别出任何字体，也可以识别出任何 Unicode 字符。Tesseract OCR 该软件包包含一个 OCR 引擎 – libtesseract 和一个命令行程序 – tesseract。 Tesseract 4 增加了一个基于 OCR 引擎的新神经网络（LSTM），该引擎专注于线路识别，但仍然支持 Tesseract 3 的传统 Tesseract OCR 引擎，该引擎通过识别字符模式来工作。通过使用 Legacy OCR Engine 模式（–oem 0）启用与 Tesseract 3 的兼容性。它还需要训练有素的数据文件，这些文件支持传统引擎，例如来自 tessdata 存储库的文件。</p><p><a href="https://github.com/tesseract-ocr/tesseract">GitHub Address</a></p></blockquote><h3 id="Tesseract-OCR-iOS"><a href="#Tesseract-OCR-iOS" class="headerlink" title="Tesseract-OCR-iOS"></a>Tesseract-OCR-iOS</h3><blockquote><p>Tesseract-OCR-iOS 是由<code>gali8</code>使用<code>Objective-C</code>封装的基于<code>Tesseract 3.03-rc1</code>的iOS版本库。<br><a href="https://github.com/gali8/Tesseract-OCR-iOS">GitHub Address</a></p></blockquote><h3 id="Useage"><a href="#Useage" class="headerlink" title="Useage"></a>Useage</h3><ol><li>通过<code>cocopods</code>可以直接引入此库。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#PodFile</span></span><br><span class="line">pod <span class="string">&#x27;TesseractOCRiOS&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>桌面创建一个<code>tessdata</code>文件夹</p></li><li><p>将训练好的中文语言文字数据集<code>chi_sim.traineddata</code>放入<code>tessdata</code>文件夹</p></li><li><p>将tessdata文件夹拖到项目根目录，<code>Added folders</code> 选择 <code>Create folder references</code>创建索引关系</p><blockquote><p>之所以创建索引，是因为Tesseract内部是使用静态路径访问的语言资源文件</p></blockquote></li><li><p>使用中文语言创建<code>G8Tesseract</code></p></li><li><p>设置<code>G8Tesseract</code>需要识别的<code>image</code></p></li><li><p>调用<code>recognize()</code>方法，同步方法，会阻塞进程</p></li><li><p>读取<code>recognizedText</code>属性字段</p></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// google Tesseract识别</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">ocrActionTesseract</span>() &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> path <span class="operator">=</span> <span class="keyword">self</span>.path, <span class="keyword">let</span> img <span class="operator">=</span> <span class="type">UIImage</span>(contentsOfFile: path) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> g8Rec <span class="operator">=</span> <span class="type">G8Tesseract</span>(language: <span class="string">&quot;chi_sim&quot;</span>)</span><br><span class="line">    g8Rec<span class="operator">?</span>.image <span class="operator">=</span> img</span><br><span class="line">    g8Rec<span class="operator">?</span>.engineMode <span class="operator">=</span> .tesseractOnly</span><br><span class="line">    g8Rec<span class="operator">?</span>.pageSegmentationMode <span class="operator">=</span> .autoOnly</span><br><span class="line">    g8Rec<span class="operator">?</span>.recognize()</span><br><span class="line">    resultLabel.text <span class="operator">=</span> g8Rec<span class="operator">?</span>.recognizedText</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集成过程中可能遇到的问题：</p><ol><li><p><code>actual_tessdata_num_entries_ &lt;= TESSDATA_NUM_ENTRIES:Error: Assert failed: in file ..\..\ccutil\tes...</code></p><p>原因：训练数据和sdk版本号不一致<br>解决方法：去 <a href="https://github.com/tesseract-ocr/tessdoc/blob/master/tess3/Data-Files.md#data-files-for-version-302">v3.0.2版本训练数据</a>下载对应版本的训练数据</p></li><li><p><code>setenv(&quot;TESSDATA_PREFIX&quot;, [_absoluteDataPath stringByAppendingString:@&quot;/&quot;].fileSystemRepresentation, 1);</code> 处崩溃</p><p>原因：未知，可能是代码BUG<br>解决方法：不使用作者提供的SwiftDemo中的<code>OperationQueue</code>直接使用<code>G8Tesseract</code>类</p></li></ol><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>Tesseract 可以支持自定义训练数据，可以根据自身的需求进行数据训练。可以实现手写字体或其他不规则字体的识别。</li><li>识别准确率参照训练结果，在大量业务数据的支持下可能会达到较高的准确率。</li><li>无iOS系统版本要求，或基本满足低版本要求</li></ol><p>缺点：</p><ol><li><code>Tesseract-OCR-iOS</code> 库不再维护和更新，代码BUG无人解决，<code>Tesseract</code>版本依旧停留在3.0版本，限制使用3.0版本的训练数据集。若不自行训练，低版本训练数据比较难找。自行fork进行二次开发学习成本较高。</li><li><code>Tesseract-OCR-iOS</code>库自行测试结果对简体中文的识别准确率稍低，可能是因为<code>Tesseract</code>版本过低。</li><li>引入此三方库的成本过高，基本的简体中文训练数据集大小就为40+MB，引入工程内会显著增加IPA包体积大小，影响APP下载和分发</li></ol><h2 id="OnLine-OCR"><a href="#OnLine-OCR" class="headerlink" title="OnLine OCR"></a>OnLine OCR</h2><p>服务商较多，也有免费试用版，可衡量业务与需求选择。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果OCR不是App的核心功能还是尽量选择<code>Vision</code>，<code>Apple</code>马上要更新<code>iOS15</code>版本，随着时间发展<code>iOS14</code>以上的用户数量会越来越多，相信系统版本限制不会永远是APP功能发展的瓶颈。</p><p>如果OCR是APP的核心功能或业务相关，建议自行对最新的<code>Tesseract</code> 进行c++接口封装或者对<code>Tesseract-OCR-iOS</code>库二次开发更新版本并进行维护。</p><p>或者选择使用收费在线业务，大部分场景下花钱都能解决技术问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h2&gt;&lt;p&gt;近期老板提出了某些需求可能需要借助OCR能力来进行图片到文本的转换。&lt;/p&gt;
&lt;p&gt;以下几种方案是对当前可用的免费的OCR的</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="技术调研" scheme="https://zcx4u.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>AVPlayer相关BUG记录</title>
    <link href="https://zcx4u.github.io/2021/08/25/AVPlayer%E7%9B%B8%E5%85%B3BUG%E8%AE%B0%E5%BD%95/"/>
    <id>https://zcx4u.github.io/2021/08/25/AVPlayer%E7%9B%B8%E5%85%B3BUG%E8%AE%B0%E5%BD%95/</id>
    <published>2021-08-24T16:00:00.000Z</published>
    <updated>2025-03-13T09:55:42.270Z</updated>
    
    <content type="html"><![CDATA[<p>Bug：音频列表顺序播放过程中偶尔出现设置的1.5倍速重置为1</p><p>原因：音频流卡顿暂停并缓冲到了足够可以继续播放的buffer长度后响应<code>playbackLikelyToKeepUp</code> 事件中 手动调用了 <code>player.play()</code> 方法播放音频</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> keyPath <span class="operator">==</span> <span class="string">&quot;currentItem.playbackLikelyToKeepUp&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> item <span class="operator">=</span> currentItem, item.isPlaybackLikelyToKeepUp, playStatus <span class="operator">==</span> .loading, isPlayerActive &#123;</span><br><span class="line">    playStatus <span class="operator">=</span> .playing</span><br><span class="line">    player.play()</span><br><span class="line">    <span class="comment">// 播放之后需增加设置rate的步骤</span></span><br><span class="line">    rate <span class="operator">=</span> <span class="type">CGFloat</span>(<span class="type">UserDefaultManager</span>.manager.getAudioRateValue()) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看文档可以看到<code>play</code>方法等同于 <code>player.rate = 1</code>，故而导致音频的速率变成了1</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> @methodplay</span></span><br><span class="line"><span class="comment"> @abstractSignals the desire to begin playback at the current item&#x27;s natural rate.</span></span><br><span class="line"><span class="comment"> @discussionEquivalent to setting the value of rate to 1.0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="operator">-</span> (void)play;</span><br></pre></td></tr></table></figure><p>总结：api的使用还是需要多看文档不要仅仅看名字就想当然(play &#x3D; 以当前速率进行继续播放)，简单的api名称并不代表着简单的功能！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Bug：音频列表顺序播放过程中偶尔出现设置的1.5倍速重置为1&lt;/p&gt;
&lt;p&gt;原因：音频流卡顿暂停并缓冲到了足够可以继续播放的buffer长度后响应&lt;code&gt;playbackLikelyToKeepUp&lt;/code&gt; 事件中 手动调用了 &lt;code&gt;player.play</summary>
      
    
    
    
    <category term="iOS" scheme="https://zcx4u.github.io/categories/iOS/"/>
    
    
    <category term="BUG记录和经验收集" scheme="https://zcx4u.github.io/tags/BUG%E8%AE%B0%E5%BD%95%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
</feed>
