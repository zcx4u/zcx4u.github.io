<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APP内部代理</title>
    <url>/2021/01/18/APP%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="APP内部代理"><a href="#APP内部代理" class="headerlink" title="APP内部代理"></a>APP内部代理</h3><hr>
<h5 id="wifi的代理配置不会自动保存？"><a href="#wifi的代理配置不会自动保存？" class="headerlink" title="wifi的代理配置不会自动保存？"></a>wifi的代理配置不会自动保存？</h5><p>使用iPhone的大概都遇见过这种事情：</p>
<p>每次需要给APP抓包的时候都需要到设置-WIFI-下手动配置代理，然而当我们连着代理的时候无法访问App Store或其他禁止代理的服务，这个时候我们会把WIFI的代理给关闭。</p>
<p>弄完杂七杂八的东西之后回到抓包调试，打开WIFI设置页，手动配置代理…</p>
<p>？？？</p>
<p>我刚才填的本机IP和端口呢？我还得再输一次？WTF！</p>
<hr>
<h5 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h5><p>弄两个wifi信号，一个挂笔记本的代理不关，另一个正常联网，需要切换代理的时候切换wifi。</p>
<p> 说实话操作起来挺麻烦的，并且公司只有一个公用的wifi信号，想弄一个新的信号还需要运维小伙伴来搞，难顶。</p>
<hr>
<h5 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h5><p>安装VPN软件，配置本地代理规则，需要抓包的时候打开网络代理。</p>
<p>小火箭之类好用的软件需要美区账号安装，每个测试机都可能会有这个需求，不可能每个测试机都这么操作一遍。</p>
<hr>
<h5 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h5><p>APP内部通过代码设置代理，只在APP内部生效，开发环境使用，可持久化配置文件。</p>
<p>去goole了一圈，发现<code>URLSessionConfiguration</code> 中有个字典专门保存代理信息<code>connectionProxyDictionary</code> </p>
<p>官方这么说的：</p>
<blockquote>
<p>This property controls which proxy tasks within sessions based on this configuration use when connecting to remote hosts.<br>The default value is NULL, which means that tasks use the default system settings.</p>
</blockquote>
<p>也就是说默认NULL的时候是走系统的代理设置，如果我们自定义的话就走我们APP内部自定义的代理设置咯。</p>
<p>同理如果我们强制将这个值置空就能够避免我们的请求走隧道也能防止别人抓包辣！</p>
<hr>
<h5 id="动动小手试试效果"><a href="#动动小手试试效果" class="headerlink" title="动动小手试试效果"></a>动动小手试试效果</h5><p>我们工程中使用了<code>Moya</code>来做网络封装，<code>Moya</code>内部使用<code>Alamofire</code>来请求网络，不论是<code>Moya</code> 还是<code>Alamofire</code>都不影响实际的代码效果。因为他们都使用了<code>URLSessionConfiguration</code>的单例，只需要在构建网络请求的时候添加上对应的代理信息即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> alamofireConfiguration: <span class="type">URLSessionConfiguration</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.default</span><br><span class="line">        <span class="keyword">#if</span> <span class="type">DEBUG</span></span><br><span class="line">        configuration.timeoutIntervalForRequest <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> proxyHost: <span class="type">String</span> <span class="operator">=</span> <span class="type">UserDefaultManager</span>.object(forKey: <span class="type">UserDefaultsKeys</span>.<span class="type">Test</span>.proxyHost),</span><br><span class="line">           <span class="keyword">let</span> proxyPort: <span class="type">Int64</span> <span class="operator">=</span> <span class="type">UserDefaultManager</span>.object(forKey: <span class="type">UserDefaultsKeys</span>.<span class="type">Test</span>.proxyPort) &#123;</span><br><span class="line">            <span class="keyword">var</span> proxyConfiguration <span class="operator">=</span> [<span class="type">AnyHashable</span>:<span class="keyword">Any</span>]()</span><br><span class="line">            <span class="comment">//HTTP</span></span><br><span class="line">            proxyConfiguration.updateValue(<span class="number">1</span> <span class="keyword">as</span> <span class="type">AnyObject</span>, forKey: <span class="string">&quot;HTTPEnable&quot;</span>)</span><br><span class="line">            proxyConfiguration.updateValue(proxyHost <span class="keyword">as</span> <span class="type">AnyObject</span>, forKey: <span class="string">&quot;HTTPProxy&quot;</span>)</span><br><span class="line">            proxyConfiguration.updateValue(proxyPort <span class="keyword">as</span> <span class="type">AnyObject</span>, forKey: <span class="string">&quot;HTTPPort&quot;</span>)</span><br><span class="line">            <span class="comment">//HTTPS</span></span><br><span class="line">            proxyConfiguration.updateValue(<span class="number">1</span> <span class="keyword">as</span> <span class="type">AnyObject</span>, forKey: <span class="string">&quot;HTTPSEnable&quot;</span>)</span><br><span class="line">            proxyConfiguration.updateValue(proxyHost <span class="keyword">as</span> <span class="type">AnyObject</span>, forKey: <span class="string">&quot;HTTPSProxy&quot;</span>)</span><br><span class="line">            proxyConfiguration.updateValue(proxyPort <span class="keyword">as</span> <span class="type">AnyObject</span>, forKey: <span class="string">&quot;HTTPSPort&quot;</span>)</span><br><span class="line">            configuration.connectionProxyDictionary <span class="operator">=</span> proxyConfiguration</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">#else</span></span><br><span class="line">        configuration.timeoutIntervalForRequest <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">        <span class="keyword">#endif</span></span><br><span class="line">        <span class="keyword">return</span> configuration</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后再做个保存设置功能之类的东东就大功告成了！</p>
<p>使用起来十分舒服，再也不用老去WIFI设置页去填自己电脑的IP和端口了，在APP内部设置然后持久化一下就可以抓包分析而且不担心影响其他APP了。</p>
<p>当然要记得控制好开发环境，不要影响线上业务哦！</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>有用的</tag>
      </tags>
  </entry>
  <entry>
    <title>AVPlayer相关BUG记录</title>
    <url>/2021/08/25/AVPlayer%E7%9B%B8%E5%85%B3BUG%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Bug：音频列表顺序播放过程中偶尔出现设置的1.5倍速重置为1</p>
<p>原因：音频流卡顿暂停并缓冲到了足够可以继续播放的buffer长度后响应<code>playbackLikelyToKeepUp</code> 事件中 手动调用了 <code>player.play()</code> 方法播放音频</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> keyPath <span class="operator">==</span> <span class="string">&quot;currentItem.playbackLikelyToKeepUp&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> item <span class="operator">=</span> currentItem, item.isPlaybackLikelyToKeepUp, playStatus <span class="operator">==</span> .loading, isPlayerActive &#123;</span><br><span class="line">    playStatus <span class="operator">=</span> .playing</span><br><span class="line">    player.play()</span><br><span class="line">    <span class="comment">// 播放之后需增加设置rate的步骤</span></span><br><span class="line">    rate <span class="operator">=</span> <span class="type">CGFloat</span>(<span class="type">UserDefaultManager</span>.manager.getAudioRateValue()) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看文档可以看到<code>play</code>方法等同于 <code>player.rate = 1</code>，故而导致音频的速率变成了1</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> @method		play</span></span><br><span class="line"><span class="comment"> @abstract		Signals the desire to begin playback at the current item&#x27;s natural rate.</span></span><br><span class="line"><span class="comment"> @discussion	Equivalent to setting the value of rate to 1.0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="operator">-</span> (void)play;</span><br></pre></td></tr></table></figure>

<p>总结：api的使用还是需要多看文档不要仅仅看名字就想当然(play &#x3D; 以当前速率进行继续播放)，简单的api名称并不代表着简单的功能！</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>BUG记录和经验收集</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT使用技巧手册</title>
    <url>/2024/01/15/ChatGPT%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="ChatGPT使用技巧手册"><a href="#ChatGPT使用技巧手册" class="headerlink" title="ChatGPT使用技巧手册"></a>ChatGPT使用技巧手册</h1><hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%8A%80%E5%B7%A7">核心技巧</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E9%87%8D%E6%9E%84">代码优化与重构</a></li>
<li><a href="#%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86">多语言处理</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E8%BE%85%E5%8A%A9">开发辅助</a></li>
<li><a href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%80%82%E9%85%8D">跨平台适配</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8">扩展应用</a></li>
</ul>
<hr>
<h2 id="核心技巧"><a href="#核心技巧" class="headerlink" title="核心技巧"></a>核心技巧</h2><h3 id="Prompt生成方法论"><a href="#Prompt生成方法论" class="headerlink" title="Prompt生成方法论"></a>Prompt生成方法论</h3><ol>
<li><p><strong>多Prompt生成</strong></p>
<ul>
<li>通过生成多个prompt迭代优化输出质量</li>
<li>示例流程：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成初始Prompt → 评估结果 → 生成改进Prompt → 最终优化</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>角色扮演</strong></p>
<ul>
<li>作为超级语言解释器（处理复杂语义）</li>
<li>作为提示词训练器（生成领域专用Prompt）</li>
</ul>
</li>
<li><p><strong>格式规范</strong></p>
<ul>
<li>强制JSON&#x2F;YAML结构化输出</li>
<li>表格化数据呈现</li>
</ul>
</li>
</ol>
<hr>
<h2 id="代码优化与重构"><a href="#代码优化与重构" class="headerlink" title="代码优化与重构"></a>代码优化与重构</h2><h3 id="10大即时代码重构技巧"><a href="#10大即时代码重构技巧" class="headerlink" title="10大即时代码重构技巧"></a>10大即时代码重构技巧</h3><table>
<thead>
<tr>
<th>优化方向</th>
<th>典型操作</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>性能优化</td>
<td>算法复杂度分析</td>
<td>循环结构</td>
</tr>
<tr>
<td>兼容性</td>
<td>多语言语法适配</td>
<td>跨平台项目</td>
</tr>
<tr>
<td>可维护性</td>
<td>模块化拆分</td>
<td>大型工程</td>
</tr>
</tbody></table>
<p><strong>重构步骤示例：</strong></p>
<ol>
<li>使用最新库版本替换过时代码</li>
<li>将ArrayList改为ConcurrentHashMap（数据结构优化）</li>
<li>添加try-with-resources错误处理</li>
</ol>
<hr>
<h2 id="多语言处理"><a href="#多语言处理" class="headerlink" title="多语言处理"></a>多语言处理</h2><h3 id="多语种翻译工作流"><a href="#多语种翻译工作流" class="headerlink" title="多语种翻译工作流"></a>多语种翻译工作流</h3><p><strong>关键注意事项：</strong></p>
<ul>
<li>使用 <code>LANG_CODE</code>作为字典key</li>
<li>保留原始文本占位符（如 <code>&#123;0&#125;</code>）</li>
<li>优先处理数字&#x2F;日期格式</li>
</ul>
<hr>
<h2 id="开发辅助"><a href="#开发辅助" class="headerlink" title="开发辅助"></a>开发辅助</h2><h3 id="测试驱动开发（TDD）"><a href="#测试驱动开发（TDD）" class="headerlink" title="测试驱动开发（TDD）"></a>测试驱动开发（TDD）</h3><ol>
<li><p><strong>UT生成</strong></p>
<ul>
<li>输入：方法签名 + 边界条件</li>
<li>输出：JUnit&#x2F;TestNG测试套件</li>
<li>覆盖率分析建议</li>
</ul>
</li>
<li><p><strong>Mock数据生成</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;##number(1,100)&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;##name.fullName&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="跨平台适配"><a href="#跨平台适配" class="headerlink" title="跨平台适配"></a>跨平台适配</h2><h3 id="iOS布局转换"><a href="#iOS布局转换" class="headerlink" title="iOS布局转换"></a>iOS布局转换</h3><p><strong>Objective-C框架迁移流程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 原始Frame布局</span><br><span class="line">CGRectMake(10, 20, 30, 40);</span><br><span class="line"></span><br><span class="line">// Masonry转换后</span><br><span class="line">make.top.equalTo(20);</span><br><span class="line">make.left.equalTo(10);</span><br><span class="line">make.width.equalTo(30);</span><br><span class="line">make.height.equalTo(40);</span><br></pre></td></tr></table></figure>

<p><strong>优化建议：</strong></p>
<ul>
<li>将布局逻辑拆分为 <code>setupConstraints</code>方法</li>
<li>使用 <code>MAS_SHORTHAND</code>简化语法</li>
</ul>
<hr>
<h2 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a>扩展应用</h2><h3 id="Figma-ChatGPT协作"><a href="#Figma-ChatGPT协作" class="headerlink" title="Figma+ChatGPT协作"></a>Figma+ChatGPT协作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">frame Figma设计稿 &#123;</span><br><span class="line">  component 图层结构</span><br><span class="line">  component 样式参数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frame ChatGPT &#123;</span><br><span class="line">  component 设计规范解析</span><br><span class="line">  component 代码生成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Figma设计稿 --&gt; ChatGPT : 导出设计规范</span><br><span class="line">ChatGPT --&gt; 前端工程 : 生成组件代码</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="实用资源"><a href="#实用资源" class="headerlink" title="实用资源"></a>实用资源</h3><ul>
<li><a href="https://www.aishort.top/?tags=code">Prompt精选库</a></li>
<li>Recharts数据可视化库</li>
<li>Lucide React图标集</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>AIGC</tag>
        <tag>ChatGPT</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CTMediator 架构方案深度解析</title>
    <url>/2025/03/14/CTMediator%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="一、架构背景深度剖析"><a href="#一、架构背景深度剖析" class="headerlink" title="一、架构背景深度剖析"></a>一、架构背景深度剖析</h1><h2 id="1-1-问题场景再现"><a href="#1-1-问题场景再现" class="headerlink" title="1.1 问题场景再现"></a>1.1 问题场景再现</h2><p><strong>典型痛点表现</strong>：</p>
<ul>
<li>编译时间随模块增加呈指数增长（N 模块编译耗时约 [T &#x3D; k*N^2]）</li>
<li>多团队协作时出现「修改冲突风暴」</li>
<li>基础模块迭代导致全量回归测试</li>
</ul>
<h2 id="1-2-设计决策矩阵"><a href="#1-2-设计决策矩阵" class="headerlink" title="1.2 设计决策矩阵"></a>1.2 设计决策矩阵</h2><table>
<thead>
<tr>
<th>方案类型</th>
<th>编译时耦合</th>
<th>运行时开销</th>
<th>可维护性</th>
<th>学习曲线</th>
</tr>
</thead>
<tbody><tr>
<td>直接引用</td>
<td>高</td>
<td>低</td>
<td>差</td>
<td>低</td>
</tr>
<tr>
<td>协议抽象</td>
<td>中</td>
<td>中</td>
<td>优</td>
<td>高</td>
</tr>
<tr>
<td>CTMediator</td>
<td>低</td>
<td>中</td>
<td>良</td>
<td>中</td>
</tr>
<tr>
<td>URL Router</td>
<td>低</td>
<td>高</td>
<td>良</td>
<td>低</td>
</tr>
</tbody></table>
<h1 id="二、技术实现详解"><a href="#二、技术实现详解" class="headerlink" title="二、技术实现详解"></a>二、技术实现详解</h1><h2 id="2-1-核心类结构"><a href="#2-1-核心类结构" class="headerlink" title="2.1 核心类结构"></a>2.1 核心类结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">class CTMediator &#123;</span><br><span class="line">  - cachedTargets: NSMutableDictionary</span><br><span class="line">  + sharedInstance(): CTMediator</span><br><span class="line">  + performTarget(): id</span><br><span class="line">  + safePerformAction(): id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Target_XXX &#123;</span><br><span class="line">  + Action_YYY(): id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTMediator --&gt; Target_XXX : 动态调用</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="2-2-完整调用链路"><a href="#2-2-完整调用链路" class="headerlink" title="2.2 完整调用链路"></a>2.2 完整调用链路</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用端示例（含安全校验）</span><br><span class="line">NSDictionary *params = @&#123;</span><br><span class="line">  @&quot;pageID&quot;: @(1024),</span><br><span class="line">  @&quot;authToken&quot;: @&quot;3a8d7f0e&quot;,</span><br><span class="line">  @&quot;callback&quot;: ^(BOOL success) &#123;</span><br><span class="line">      NSLog(@&quot;操作状态: %@&quot;, success ? @&quot;成功&quot; : @&quot;失败&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UIViewController *vc = [[CTMediator sharedInstance]</span><br><span class="line">    performTarget:@&quot;UserCenter&quot;  // 目标模块标识</span><br><span class="line">     action:@&quot;ProfilePage&quot;       // 功能单元标识</span><br><span class="line">     params:[params copy]       // 防御性拷贝</span><br><span class="line">     shouldCacheTarget:YES];    // 高频访问缓存</span><br><span class="line"></span><br><span class="line">// 异常处理流程</span><br><span class="line">if (![vc conformsToProtocol:@protocol(SafeViewProtocol)]) &#123;</span><br><span class="line">    [self trackException:@&#123;</span><br><span class="line">        @&quot;code&quot;: @(403),</span><br><span class="line">        @&quot;reason&quot;: @&quot;视图控制器协议不匹配&quot;</span><br><span class="line">    &#125;];</span><br><span class="line">    vc = [FallbackViewController new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-性能优化策略"><a href="#2-3-性能优化策略" class="headerlink" title="2.3 性能优化策略"></a>2.3 性能优化策略</h2><p><strong>缓存机制实现</strong>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTMediatorCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> targetCache <span class="operator">=</span> [<span class="type">String</span>: <span class="type">NSObject</span>]()</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cache</span>(<span class="params">target</span>: <span class="type">NSObject</span>, <span class="params">forKey</span> <span class="params">key</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> targetCache.count <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125; <span class="comment">// 防溢出</span></span><br><span class="line">        targetCache[key] <span class="operator">=</span> target</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">purgeExpired</span>() &#123;</span><br><span class="line">        targetCache.keys</span><br><span class="line">            .filter &#123; lastAccessTime(for: <span class="variable">$0</span>) <span class="operator">&lt;</span> .now<span class="operator">-</span><span class="number">3600</span> &#125;</span><br><span class="line">            .forEach &#123; targetCache.removeValue(forKey: <span class="variable">$0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、架构演进路线"><a href="#三、架构演进路线" class="headerlink" title="三、架构演进路线"></a>三、架构演进路线</h1><h2 id="3-1-当前应用场景"><a href="#3-1-当前应用场景" class="headerlink" title="3.1 当前应用场景"></a>3.1 当前应用场景</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">  subgraph 基础层</span><br><span class="line">      CommonUtils --&gt;|反向调用| CTMediator</span><br><span class="line">  end</span><br><span class="line">  </span><br><span class="line">  subgraph 业务层</span><br><span class="line">      FeatureA --&gt;|跨模块调用| CTMediator</span><br><span class="line">      CTMediator --&gt;|动态路由| I18NModule</span><br><span class="line">  end</span><br><span class="line">  </span><br><span class="line">  subgraph 数据层</span><br><span class="line">      Analytics --&gt;|事件上报| CTMediator</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

<h2 id="3-2-改造路线图"><a href="#3-2-改造路线图" class="headerlink" title="3.2 改造路线图"></a>3.2 改造路线图</h2><table>
<thead>
<tr>
<th>阶段</th>
<th>时间范围</th>
<th>重点任务</th>
<th>关键指标</th>
</tr>
</thead>
<tbody><tr>
<td>过渡期</td>
<td>2025 Q1-Q2</td>
<td>建立调用备案制度</td>
<td>调用文档覆盖率 ≥90%</td>
</tr>
<tr>
<td>迁移期</td>
<td>2025 Q3-Q4</td>
<td>核心模块接口改造</td>
<td>直接引用占比 ≤30%</td>
</tr>
<tr>
<td>稳定期</td>
<td>2026 Q1</td>
<td>全量静态校验实施</td>
<td>编译时检查覆盖率 100%</td>
</tr>
</tbody></table>
<h1 id="四、最佳实践指南"><a href="#四、最佳实践指南" class="headerlink" title="四、最佳实践指南"></a>四、最佳实践指南</h1><h2 id="4-1-安全调用模板"><a href="#4-1-安全调用模板" class="headerlink" title="4.1 安全调用模板"></a>4.1 安全调用模板</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SafeInvoker.h</span><br><span class="line">#define SAFE_CALL(target, action, paramsType) \</span><br><span class="line">__attribute__((overloadable)) \</span><br><span class="line">static inline id safeInvoke(NSString *target, NSString *action, paramsType params) &#123; \</span><br><span class="line">    if (![CTMediator validateTarget:target]) &#123; \</span><br><span class="line">        [NSException raise:@&quot;非法调用&quot; format:@&quot;未经注册的 Target: %@&quot;, target]; \</span><br><span class="line">    &#125; \</span><br><span class="line">    /* ... 参数校验逻辑 ... */ \</span><br><span class="line">    return [[CTMediator sharedInstance] performTarget:target action:action params:params]; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-监控指标配置"><a href="#4-2-监控指标配置" class="headerlink" title="4.2 监控指标配置"></a>4.2 监控指标配置</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;metrics&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;调用成功率&quot;</span><span class="punctuation">:</span> <span class="string">&quot;98.7%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;平均响应时间&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12ms&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;缓存命中率&quot;</span><span class="punctuation">:</span> <span class="string">&quot;82.3%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;异常类型分布&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;TargetNotFound&quot;</span><span class="punctuation">:</span> <span class="number">45</span>%<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ActionMissing&quot;</span><span class="punctuation">:</span> <span class="number">30</span>%<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ParamError&quot;</span><span class="punctuation">:</span> <span class="number">25</span>%</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="五、常见问题诊断"><a href="#五、常见问题诊断" class="headerlink" title="五、常见问题诊断"></a>五、常见问题诊断</h1><table>
<thead>
<tr>
<th>故障现象</th>
<th>排查步骤</th>
<th>修复方案</th>
</tr>
</thead>
<tbody><tr>
<td>调用返回 nil</td>
<td>1. 检查 Target 类前缀<code>&lt;br&gt;</code>2. 验证 Action 参数类型</td>
<td>添加 Class 前缀约定</td>
</tr>
<tr>
<td>参数传递丢失</td>
<td>1. 检查字典 key 大小写<code>&lt;br&gt;</code>2. 验证 NSJSONSerialization 兼容性</td>
<td>使用类型安全的参数包装器</td>
</tr>
<tr>
<td>内存持续增长</td>
<td>1. 检查 Target 缓存策略<code>&lt;br&gt;</code>2. 分析 ARC 引用关系</td>
<td>实现缓存自动回收机制</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>架构师建议</strong>：在 Swift 主导的新项目中，建议采用 <code>Protocol-Oriented Dependency Injection</code> 模式逐步替代 CTMediator，同时保留其作为应急通信机制。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>代码审查实战指南</title>
    <url>/2025/03/14/CodeReview%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="代码审查实战指南"><a href="#代码审查实战指南" class="headerlink" title="代码审查实战指南"></a>代码审查实战指南</h1><h2 id="一、代码风格标准化"><a href="#一、代码风格标准化" class="headerlink" title="一、代码风格标准化"></a>一、代码风格标准化</h2><h3 id="1-1-命名规范"><a href="#1-1-命名规范" class="headerlink" title="1.1 命名规范"></a>1.1 命名规范</h3><ul>
<li>采用匈牙利命名法（如 <code>strUserName</code>）或现代语义命名（如 <code>userNameTextField</code>）</li>
<li>禁止使用 <code>tmp</code>&#x2F;<code>data</code>等无意义命名</li>
<li>类名采用大驼峰，方法名使用小驼峰</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好的示例</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UserService</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)updateUserProfile:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-格式一致性"><a href="#1-2-格式一致性" class="headerlink" title="1.2 格式一致性"></a>1.2 格式一致性</h3><ul>
<li>统一缩进策略（4空格制或2空格制）</li>
<li>方法参数对齐标准：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)complexCalculationWithParam1:(<span class="built_in">NSInteger</span>)param1</span><br><span class="line">                             param2:(<span class="built_in">CGFloat</span>)param2</span><br><span class="line">                             param3:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="type">id</span>&gt; *)param3</span><br><span class="line">                         completion:(<span class="type">void</span>(^)(ResultType *result))completion;</span><br></pre></td></tr></table></figure>

<h2 id="二、冗余代码治理"><a href="#二、冗余代码治理" class="headerlink" title="二、冗余代码治理"></a>二、冗余代码治理</h2><h3 id="2-1-代码重复检测"><a href="#2-1-代码重复检测" class="headerlink" title="2.1 代码重复检测"></a>2.1 代码重复检测</h3><p>使用OCLint工具检测重复代码块：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disable-rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">LongLine</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">LongMethod</span></span><br><span class="line"><span class="attr">enable-rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">DuplicatedCode:</span></span><br><span class="line">      <span class="attr">threshold:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-无效代码处理流程"><a href="#2-2-无效代码处理流程" class="headerlink" title="2.2 无效代码处理流程"></a>2.2 无效代码处理流程</h3><h2 id="三、业务逻辑验证"><a href="#三、业务逻辑验证" class="headerlink" title="三、业务逻辑验证"></a>三、业务逻辑验证</h2><h3 id="3-1-核心检查点矩阵"><a href="#3-1-核心检查点矩阵" class="headerlink" title="3.1 核心检查点矩阵"></a>3.1 核心检查点矩阵</h3><table>
<thead>
<tr>
<th>检查维度</th>
<th>正向案例验证</th>
<th>异常场景覆盖</th>
<th>性能边界测试</th>
</tr>
</thead>
<tbody><tr>
<td>支付流程</td>
<td>✓</td>
<td>✓</td>
<td>＞100TPS</td>
</tr>
<tr>
<td>库存扣减</td>
<td>✓</td>
<td>超卖防护</td>
<td>分布式锁</td>
</tr>
</tbody></table>
<h3 id="3-2-防御性编程模式"><a href="#3-2-防御性编程模式" class="headerlink" title="3.2 防御性编程模式"></a>3.2 防御性编程模式</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用NSParameterAssert进行参数检查</span></span><br><span class="line"><span class="built_in">NSParameterAssert</span>(orderId.length &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (orderId.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *errorMsg = <span class="string">@&quot;订单ID不能为空&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, errorMsg);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、规范执行机制"><a href="#四、规范执行机制" class="headerlink" title="四、规范执行机制"></a>四、规范执行机制</h2><h3 id="4-1-自动化检查清单"><a href="#4-1-自动化检查清单" class="headerlink" title="4.1 自动化检查清单"></a>4.1 自动化检查清单</h3><ol>
<li>SonarQube质量门禁（覆盖率＞80%）</li>
<li>OCLint格式校验</li>
<li>OWASP依赖扫描</li>
<li>编译器警告零容忍</li>
</ol>
<h3 id="4-2-审查记录模板"><a href="#4-2-审查记录模板" class="headerlink" title="4.2 审查记录模板"></a>4.2 审查记录模板</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**审查项**</span>：用户服务模块  </span><br><span class="line"><span class="strong">**问题类型**</span>：  </span><br><span class="line"><span class="bullet">-</span> [ ] 代码风格  </span><br><span class="line"><span class="bullet">-</span> [x] 业务逻辑  </span><br><span class="line"><span class="strong">**改进建议**</span>：  </span><br><span class="line">建议使用NSDate替代CFAbsoluteTime  </span><br><span class="line"><span class="strong">**严重程度**</span>：⭐️⭐️</span><br></pre></td></tr></table></figure>

<h2 id="五、典型问题解答"><a href="#五、典型问题解答" class="headerlink" title="五、典型问题解答"></a>五、典型问题解答</h2><h3 id="Q1：如何处理紧急需求与代码规范的冲突？"><a href="#Q1：如何处理紧急需求与代码规范的冲突？" class="headerlink" title="Q1：如何处理紧急需求与代码规范的冲突？"></a>Q1：如何处理紧急需求与代码规范的冲突？</h3><p>建立 <code>紧急通道白名单</code>机制，需满足：</p>
<ol>
<li>提交风险评估报告</li>
<li>添加TODO注释标记</li>
<li>72小时内补全审查</li>
</ol>
<h3 id="Q2：跨团队代码审查如何协作？"><a href="#Q2：跨团队代码审查如何协作？" class="headerlink" title="Q2：跨团队代码审查如何协作？"></a>Q2：跨团队代码审查如何协作？</h3><p>推荐使用<a href="https://www.gerritcodereview.com/">Gerrit</a>的评审工作流：</p>
<ol>
<li>创建跨域评审组</li>
<li>设置权重评分机制</li>
<li>实施追踪看板</li>
</ol>
<hr>
<p><strong>延伸阅读</strong>：</p>
<ul>
<li><a href="https://google.github.io/eng-practices/review/">Google代码审查标准</a></li>
<li><a href="https://docs.microsoft.com/codereview-checklist">微软代码评审checklist</a></li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>代码审查</tag>
        <tag>最佳实践</tag>
        <tag>开发流程</tag>
      </tags>
  </entry>
  <entry>
    <title>NSCache</title>
    <url>/2021/04/20/NSCache/</url>
    <content><![CDATA[<h2 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><blockquote>
<p>A mutable collection you use to temporarily store transient key-value pairs that are subject to eviction when resources are low.</p>
</blockquote>
<p>一种用于临时存储临时键值对的可变集合，在资源不足时容易被回收。</p>
<blockquote>
<p>Cache objects differ from other mutable collections in a few ways:<br>The NSCache class incorporates various auto-eviction policies, which ensure that a cache doesn’t use too much of the system’s memory. If memory is needed by other applications, these policies remove some items from the cache, minimizing its memory footprint.<br>You can add, remove, and query items in the cache from different threads without having to lock the cache yourself.<br>Unlike an NSMutableDictionary object, a cache does not copy the key objects that are put into it.<br>You typically use NSCache objects to temporarily store objects with transient data that are expensive to create. Reusing these objects can provide performance benefits, because their values do not have to be recalculated. However, the objects are not critical to the application and can be discarded if memory is tight. If discarded, their values will have to be recomputed again when needed.<br>Objects that have subcomponents that can be discarded when not being used can adopt the NSDiscardableContent protocol to improve cache eviction behavior. By default, NSDiscardableContent objects in a cache are automatically removed if their content is discarded, although this automatic removal policy can be changed. If an NSDiscardableContent object is put into the cache, the cache calls discardContentIfPossible() on it upon its removal.</p>
</blockquote>
<p>缓存对象与其他可变集合在以下几个方面有所不同:</p>
<p><strong>自动回收</strong>： NSCache类包含各种自动回收策略，这些策略确保缓存不会使用太多的系统内存。如果其他应用程序需要内存，这些策略会从缓存中删除一些项，从而最小化其内存占用。</p>
<p><strong>线程安全</strong>：可以从不同的线程在缓存中添加、删除和查询项，而不必自己锁定缓存。</p>
<p><strong>Key无需实现NSCopying</strong>：与NSMutableDictionary对象不同，缓存不会复制放入其中的key对象，降低内存占用。</p>
<p><strong>不能长久储存数据</strong>： 您通常使用NSCache对象来临时存储带有临时数据的对象，这些数据的创建成本很高。重用这些对象可以提供性能优势，因为它们的值不必重新计算。但是，这些对象对应用程序并不重要，如果内存紧张，可以丢弃这些对象。如果丢弃，它们的值将不得不在需要时重新计算。</p>
<p><strong>NSDiscardableContent 在NSCache中不会强引用</strong>：具有子组件的对象在不使用时可以被丢弃，可以采用NSDiscardableContent 协议来改进缓存回收行为。默认情况下，如果缓存中的NSDiscardableContent 对象的内容被丢弃，那么它们将被自动删除，尽管这个自动删除策略可以更改。如果一个NSDiscardableContent 对象被放入缓存，缓存在它被删除时调用discardContentIfPossible()。</p>
<p>（一般不用可丢弃对象包裹，直接使用方法保存原始obj就行）</p>
<h3 id="Values-Methods"><a href="#Values-Methods" class="headerlink" title="Values &amp; Methods"></a>Values &amp; Methods</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/NSObject.h&gt;</span><br><span class="line"></span><br><span class="line">@class NSString;</span><br><span class="line">@protocol NSCacheDelegate;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0))</span><br><span class="line">@interface NSCache &lt;KeyType, ObjectType&gt; : NSObject &#123;</span><br><span class="line">@private</span><br><span class="line">    id _delegate;</span><br><span class="line">    void *_private[5];</span><br><span class="line">    void *_reserved;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (copy) NSString *name; // 用来管理区分cache对象的名字</span><br><span class="line"></span><br><span class="line">@property (nullable, assign) id&lt;NSCacheDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">- (nullable ObjectType)objectForKey:(KeyType)key; // 取数据</span><br><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key; // 0 cost 缓存数据</span><br><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g; // 缓存数据 cost值设置的消耗内存大小</span><br><span class="line">- (void)removeObjectForKey:(KeyType)key;// 移除数据</span><br><span class="line"></span><br><span class="line">- (void)removeAllObjects;// 移除所有数据</span><br><span class="line"></span><br><span class="line">@property NSUInteger totalCostLimit;	// limits are imprecise/not strict 限制缓存数量</span><br><span class="line">@property NSUInteger countLimit;	// limits are imprecise/not strict 限制缓存保存数大小（cost）</span><br><span class="line">@property BOOL evictsObjectsWithDiscardedContent; // 是否自动回收</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol NSCacheDelegate &lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line">- (void)cache:(NSCache *)cache willEvictObject:(id)obj; // 回收内存的时候调用代理的方法</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD相关知识学习笔记</title>
    <url>/2020/09/22/GCD/</url>
    <content><![CDATA[<p>致未来的我：你是不是有点忘记了GCD的一些知识？恰巧这几天我有看这些，让我给你讲讲吧？<br>GCD是基于C语言的API，开发者只需要将任务放在block内，并指定好追加的队列，就可以完成多线程开发.</p>
<h2 id="知识点速览"><a href="#知识点速览" class="headerlink" title="知识点速览"></a>知识点速览</h2><p>1.队列： 串行队列、并发队列</p>
<p>2.任务： 同步任务、异步任务</p>
<p>3.队列和任务的交叉组合使用</p>
<p>4.死锁的产生和预防</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>Dispatch Queue是执行处理的等待队列，按照任务（block）追加到队列里的顺序，先进先出执行处理。</p>
<p>而等待队列有两种</p>
<p>Serial Dispatch Queue：串行队列，等待当前执行任务处理结束的队列。</p>
<p>Concurrent Dispatch Queue:并发队列，不等待当前执行任务处理结束的队列</p>
<p>那么如何创建一个新队列呢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建了串行队列</span><br><span class="line">dispatch_queue_t serailQueue = dispatch_queue_create(&quot;Test_SERIAL_GCD_Queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">//创建了并行队列</span><br><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;Test_CONCURRENT_GCD_Queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外系统自带的两个队列<br>主队列：mainqueen, APP启动随之启动的一个操作队列<br>全局队列：golobalQueue, Apple为开发者预设的一个全局并发队列，任务较为简单没有新建队列的需求的时候 可以直接在全局队列执行任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取到了主队列</span><br><span class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line">//获取到了全局队列 （默认优先级，第二个参数暂时没用）</span><br><span class="line">dispatch_queue_t golobalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>GCD的任务是以封装好的block的形式来执行的<br>任务分为 同步任务和异步任务</p>
<p>同步任务：一种追加到队列中按照追加顺序执行的任务，当前任务未执行完毕时会等待其执行完毕再开始自己的任务, 使用 dispatch_sync 来追加任务<br>例如 给全局队列追加一个同步任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_sync(golobalQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是golobalQueue的同步任务一&quot;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>异步任务：追加到队列中不再等待当前任务执行完毕而直接开始执行的任务，一般会开启一个新的线程，但是线程不会无限制的创建, 使用 dispatch_async 来追加任务<br>例如 给全局队列追加一个异步任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 主队列异步会等待主队列的任务执行完了再执行</span><br><span class="line">dispatch_async(golobalQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是golobalQueue的异步任务一&quot;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="队列和任务的组合"><a href="#队列和任务的组合" class="headerlink" title="队列和任务的组合"></a>队列和任务的组合</h3><p>串行队列+同步任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给串行队列增加两个同步任务</span><br><span class="line">dispatch_sync(serailQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是串行队列serailQueue的同步任务一&quot;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(serailQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是串行队列serailQueue的同步任务二&quot;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>串行队列的同步任务会按照添加的次序在当前线程依次执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-09-22 00:30:08.334655+0800 MyDemo[75669:3948525] 我是串行队列serailQueue的同步任务一当前线程: &lt;NSThread: 0x6000023ec780&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-09-22 00:30:08.335000+0800 MyDemo[75669:3948525] 我是串行队列serailQueue的同步任务二当前线程: &lt;NSThread: 0x6000023ec780&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>因为是在主线程给串行队列追加的同步任务，所以可以看到两个任务在主线程里依次执行</p>
<p>串行队列+并行任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给串行队列增加两个异步任务</span><br><span class="line">dispatch_async(serailQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是串行队列serailQueue的异步任务一&quot;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(serailQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是串行队列serailQueue的异步任务二&quot;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>串行队列的异步任务会新开一条线程然后按照添加的次序执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-09-22 00:30:08.335765+0800 MyDemo[75669:3949753] 我是串行队列serailQueue的异步任务一当前线程: &lt;NSThread: 0x6000023d7980&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">2020-09-22 00:30:08.336010+0800 MyDemo[75669:3949753] 我是串行队列serailQueue的异步任务二当前线程: &lt;NSThread: 0x6000023d7980&gt;&#123;number = 11, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>虽然在主线程追加的任务，但是异步任务会开启一条新线程执行，再看两次打印的线程地址相同，可得知串行队列的异步任务只会开启一条新线程执行异步任务</p>
<p>并发队列+同步任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给并行队列增加两个同步任务</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是并行队列concurrentQueue的同步任务一&quot;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是并行队列concurrentQueue的同步任务二&quot;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>并发队列的同步任务依旧会在当前线程按照添加次序执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-09-22 00:30:08.335258+0800 MyDemo[75669:3948525] 我是并行队列concurrentQueue的同步任务一当前线程: &lt;NSThread: 0x6000023ec780&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-09-22 00:30:08.335446+0800 MyDemo[75669:3948525] 我是并行队列concurrentQueue的同步任务二当前线程: &lt;NSThread: 0x6000023ec780&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>因为是在主线程给并发队列追加的同步任务，所以可以看到两个任务在主线程里依次执行</p>
<p>并发队列+异步任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给并行队列增加两个异步任务</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是并行队列concurrentQueue的异步任务一&quot;];</span><br><span class="line">    [self logThreadRunSomeTimeWith:3 TaskName:@&quot;异步任务一&quot;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是并行队列concurrentQueue的异步任务二&quot;];</span><br><span class="line">    [self logThreadRunSomeTimeWith:2 TaskName:@&quot;异步任务二&quot;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-09-22 00:37:23.038545+0800 MyDemo[75770:3956315] 我是并行队列concurrentQueue的异步任务一当前线程: &lt;NSThread: 0x600002a900c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-09-22 00:37:23.038552+0800 MyDemo[75770:3956312] 我是并行队列concurrentQueue的异步任务二当前线程: &lt;NSThread: 0x600002addf40&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>并发队列的异步任务会立即开启新线程执行，可以看到两个任务所在的线程是不一致的</p>
<h3 id="死锁的产生和预防"><a href="#死锁的产生和预防" class="headerlink" title="死锁的产生和预防"></a>死锁的产生和预防</h3><p>死锁就是队列引起的循环等待</p>
<p>一个最常见的例子：主队列追加同步任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       </span><br><span class="line">        NSLog(@&quot;deallock&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主线程中运用主队列同步，也就是把任务放到了主线程的队列中。<br>同步对于任务是立刻执行的，那么当把任务放进主队列时，它就会立马执行,只有执行完这个任务，viewDidLoad才会继续向下执行。<br>而viewDidLoad和任务都是在主队列上的，由于队列的先进先出原则，任务又需等待viewDidLoad执行完毕后才能继续执行，viewDidLoad和这个任务就形成了相互循环等待，就造成了死锁。<br>想避免这种死锁，可以将同步改成异步dispatch_async,或者将dispatch_get_main_queue换成其他串行或并行队列，都可以解决。</p>
<p>复杂一点的例子: 串行队列异步任务中嵌套了同一个队列的同步任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;Test_SERIAL_GCD_Queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;deadlock&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>外面的函数无论是同步还是异步都会造成死锁。<br>这是因为里面的任务和外面的任务都在同一个serialQueue队列内，又是同步，这就和上边主队列同步的例子一样造成了死锁<br>解决方法也和上边一样，将里面的同步改成异步dispatch_async,或者将serialQueue换成其他串行或并行队列，都可以解决</p>
<p>而两个不同的串行队列嵌套则不会产生死锁，且两个队列追加的任务在同一个线程中执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t serialQueueA= dispatch_queue_create(&quot;TestA_SERIAL_GCD_Queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t serialQueueB = dispatch_queue_create(&quot;TestB_SERIAL_GCD_Queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_async(serialQueueA, ^&#123;</span><br><span class="line">       </span><br><span class="line">    dispatch_sync(serialQueueB, ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;deadlock&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="栅栏任务和延时任务"><a href="#栅栏任务和延时任务" class="headerlink" title="栅栏任务和延时任务"></a>栅栏任务和延时任务</h3><p>栅栏任务：等待栅栏之前的异步任务都执行完毕了之后再执行此任务<br>举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给并行队列增加两个异步任务</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是并行队列concurrentQueue的异步任务一&quot;];</span><br><span class="line">    [self logThreadRunSomeTimeWith:3 TaskName:@&quot;异步任务一&quot;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是并行队列concurrentQueue的异步任务二&quot;];</span><br><span class="line">    [self logThreadRunSomeTimeWith:2 TaskName:@&quot;异步任务二&quot;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//给并行队列增加栅栏任务 栅栏任务会等待之前所有的异步任务完成后才执行</span><br><span class="line">dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是并行队列concurrentQueue的栅栏任务&quot;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是并行队列concurrentQueue的异步任务三&quot;];</span><br><span class="line">    dispatch_async(mainQueue, ^&#123;</span><br><span class="line">        [self logCurrentThreadNameWith:@&quot;concurrentQueue异步任务回到主队列追加任务&quot;];</span><br><span class="line">        [self logThreadRunSomeTimeWith:2 TaskName:@&quot;回到主队列的异步任务&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;我是并行队列concurrentQueue的异步任务四&quot;];</span><br><span class="line">    [self logThreadRunSomeTimeWith:4 TaskName:@&quot;异步任务四&quot;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-09-22 00:37:23.038545+0800 MyDemo[75770:3956315] 我是并行队列concurrentQueue的异步任务一当前线程: &lt;NSThread: 0x600002a900c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-09-22 00:37:23.038552+0800 MyDemo[75770:3956312] 我是并行队列concurrentQueue的异步任务二当前线程: &lt;NSThread: 0x600002addf40&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-09-22 00:37:26.045128+0800 MyDemo[75770:3956315] 我是并行队列concurrentQueue的栅栏任务当前线程: &lt;NSThread: 0x600002a900c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-09-22 00:37:26.045309+0800 MyDemo[75770:3956315] 我是并行队列concurrentQueue的异步任务三当前线程: &lt;NSThread: 0x600002a900c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-09-22 00:37:26.045323+0800 MyDemo[75770:3956312] 我是并行队列concurrentQueue的异步任务四当前线程: &lt;NSThread: 0x600002addf40&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>延时任务：使用GCD的延时任务比较简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), mainQueue, ^&#123;</span><br><span class="line">    [self logCurrentThreadNameWith:@&quot;2秒后异步追加的任务执行&quot;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同步任务不具备开启新线程的能力 异步任务总是会开启新线程<br>串行队列中无论是否开启了新线程 都会按照指定的顺序执行</p>
<p>如果执行同步任务则阻塞任务的线程 执行异步任务则不会阻塞任务所在的线程<br>串行队列中的异步任务即使开启了新线程也会因为队列的串行限制而一个一个按顺序执行，所以只需要开启一条新线程就能够满足需求<br>并发队列中的同步任务在当前线程去执行</p>
<p>为了方便程序员的使用,苹果提供了全局队列:dispatch_get_global_queue(0, 0)<br>全局队列是一个并发队列(concurrent)<br>在使用多线程开发时,如果对队列没有特殊需求,在执行异步任务时,可以直接使用全局队列</p>
<p>队列相当于一个线程的调度器 串行队列总是在当前线程去进行任务调度 并发队列会对异步任务开启新线程</p>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>通过我今天对GCD的学习，我觉得之前总是有许多自己给自己设置的学习障碍，一个大概只需要两个小时就能搞明白的知识为什么不静下心来去看看呢？<br>不会的技术并不是难以跨越的大山，只要用心钻研，就一定会有所收获。<br>好了，看到这里了，未来的我有什么要给我补充的吗？</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>XCUITest iOS自动化UI测试框架</title>
    <url>/2022/02/28/XCUITest%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="XCUITest-iOS自动化UI测试框架"><a href="#XCUITest-iOS自动化UI测试框架" class="headerlink" title="XCUITest iOS自动化UI测试框架"></a><em>XCUITest</em> iOS自动化UI测试框架</h1><h2 id="XCUITest简介"><a href="#XCUITest简介" class="headerlink" title="XCUITest简介"></a>XCUITest简介</h2><p>XCUITest是Apple提供的内嵌到xcode中的一套UI自动化测试框架。</p>
<blockquote>
<p>UI测试依赖于两项核心技术:XCTest框架和Accessibility。</p>
<p>XCTest提供了UI测试功能的框架，与Xcode集成在一起。创建和使用UI测试扩展了您对使用XCTest和创建单元测试的了解。您创建了一个UI测试目标，并将创建UI测试类和UI测试方法作为项目的一部分。您可以使用XCTest断言来验证预期结果是否为真。你也可以通过Xcode Server和xcodebuild实现持续集成。XCTest与Objective-C和Swift完全兼容。</p>
<p>Accessibility是一项核心技术，它允许残疾用户获得与其他用户相同的iOS和macOS丰富体验。它包含了一组丰富的UI语义数据，用户可以使用它来指导他们使用你的应用。可访问性集成了UIKit和AppKit，并有api允许你调整行为和对外公开的使用。UI测试使用这些数据来执行其功能。</p>
<p>在源代码中创建UI测试类似于创建单元测试。你为你的应用创建一个UI测试目标;然后Xcode为你创建一个默认的UI测试组和实现文件，在实现文件中有一个示例测试方法模板。在创建UI测试目标时，可以指定测试要处理的应用程序。</p>
</blockquote>
<p><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/09-ui_testing.html#//apple_ref/doc/uid/TP40014132-CH13-DontLinkElementID_8">User Interface Testing</a></p>
<p><a href="https://onevcat.com/2015/09/ui-testing/">WWDC15 Session笔记 - Xcode 7 UI 测试初窥</a></p>
<h2 id="添加target"><a href="#添加target" class="headerlink" title="添加target"></a>添加target</h2><p>以前在新建项目的时候可以看到自带单元测试和UI测试。新版本的XCode新建项目的时候可以看到Incloud Tests的选项，勾中这个选项就可以创建出来带单元测试和UI测试的target。</p>
<p><img src="https://cdn.zcx.info/e6c9d24ely1gzt95s1si1j20kq0eodge.jpg"></p>
<p><img src="https://cdn.zcx.info/e6c9d24ely1gzt95u7e5qj20ea0ajjrx.jpg" alt="自动创建了test有关的Target"></p>
<p>当然如果是以前就创建的项目也可以单独添加UI Test的Target。</p>
<h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><blockquote>
<p>UI 测试在基本方面不同于单元测试。单元测试使您能够在应用程序的范围内工作，并允许您在完全访问应用程序变量和状态的情况下练习函数和方法。UI 测试以与用户在不访问应用程序的内部方法、函数和变量的情况下执行相同的方式来测试应用程序的 UI。这使您的测试能够以与用户相同的方式查看应用程序，从而暴露用户遇到的 UI 问题。</p>
<p>您的测试代码作为一个单独的进程运行，综合应用程序中的 UI 响应的事件。</p>
</blockquote>
<p>编写测试代码不是一件容易的事情，由于UITest不能侵入代码逻辑，仅仅使用识别界面上的控件后发送事件来驱动APP，所以测试代码的编写逻辑趋向于查询屏幕上显示的控件，找到满足条件的控件，发送控件支持的事件，等待事件响应后使用断言或者期望断言来判断是否达到了预期的测试结果。</p>
<p>以36氪直播间内预约直播的过程为例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">testSubscribeLiveInLiveHome</span>() &#123;</span><br><span class="line">  	<span class="comment">//获取APP实例</span></span><br><span class="line">    <span class="keyword">let</span> app <span class="operator">=</span> <span class="type">XCUIApplication</span>()</span><br><span class="line"> 		<span class="comment">//启动APP</span></span><br><span class="line">    app.launch()</span><br><span class="line">  	<span class="comment">//这里延迟了1s来等待APP启动项配置加载</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">  	<span class="comment">//查询所有tabbar，筛选包含直播文字的底导，点击</span></span><br><span class="line">    app.tabBars[<span class="string">&quot;标签页栏&quot;</span>].buttons[<span class="string">&quot;直播&quot;</span>].tap()</span><br><span class="line">  	<span class="comment">//查询APP上显示的scrollViews上的控件</span></span><br><span class="line">    <span class="keyword">let</span> elementsQuery <span class="operator">=</span> app.scrollViews.otherElements </span><br><span class="line">  	<span class="comment">//点击包含直播文字的按钮 </span></span><br><span class="line">    elementsQuery.staticTexts[<span class="string">&quot;直播&quot;</span>].tap()</span><br><span class="line"> 	 	<span class="comment">//查询并点击APP上显示collectionViews中包含即将开播文字的按钮</span></span><br><span class="line">    elementsQuery.collectionViews.staticTexts[<span class="string">&quot;即将开播&quot;</span>].tap()</span><br><span class="line"> 	 	<span class="comment">//延迟1s等待APP加载即将开播列表</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">  	<span class="comment">//找到第一个包含预约文字的cell，这里如果已经预约则不显示预约文字</span></span><br><span class="line">    app.collectionViews.cells.otherElements.containing(.staticText, identifier:<span class="string">&quot;预约&quot;</span>).element(boundBy: <span class="number">0</span>).tap()</span><br><span class="line">  	<span class="comment">//延迟1s等待APP加载直播间</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"> 	 <span class="comment">//查询并点击包含预约直播文字的按钮</span></span><br><span class="line">    elementsQuery.staticTexts[<span class="string">&quot;预约直播&quot;</span>].tap()</span><br><span class="line"> 	 <span class="comment">//创建期望断言判断已预约文案是否存在，预约成功会修改按钮文案</span></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> app.staticTexts[<span class="string">&quot;已预约&quot;</span>]</span><br><span class="line">    expectation(for: <span class="type">NSPredicate</span>(format: <span class="string">&quot;exists &gt;= 1&quot;</span>), evaluatedWith: result, handler: <span class="literal">nil</span>)</span><br><span class="line">    waitForExpectations(timeout: <span class="number">3</span>, handler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就写好了一个直播间预约的测试流程。</p>
<p>可以看出测试代码的编写还是很繁琐的，写功能的同时几乎没有足够的时间再编写一套对应的测试代码。而且功能还会随着项目的迭代不断变化，同时维护功能代码和测试代码的成本是巨大的。</p>
<p>但是一些变化概率低的核心路径还是建议使用自动化测试来解放双手降低重复工作量。</p>
<h2 id="录制测试代码"><a href="#录制测试代码" class="headerlink" title="录制测试代码"></a>录制测试代码</h2><p>有时候不知道怎么查询具体某个控件的时候可以借用XCode上的录制功能。</p>
<p>把光标移入测试代码方法大括号内部空白处可以看到左下角有个红色圆点亮了起来，点击红色圆点及开启录制功能。</p>
<p>录制功能可以记录你手动点击的路径和流程，自动计算出操作路径的代码。但是计算结果可能不是一个通用的路径，所以还需要开发者自行调整。</p>
<h2 id="执行测试脚本"><a href="#执行测试脚本" class="headerlink" title="执行测试脚本"></a>执行测试脚本</h2><p>执行上面的测试方法，xcode会自动编译、运行你的APP，并会输出具体的测试结果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="type">Case</span> &#x27;<span class="operator">-</span>[<span class="type">ClientUITests</span>.<span class="type">ClientUITestsLaunchTests</span> testSubscribeLiveInLiveHome]&#x27; started.</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">0</span>.00s <span class="type">Setting</span> appearance mode to <span class="type">Light</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.08s     <span class="type">Wait</span> <span class="keyword">for</span> com.apple.springboard to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">62</span>.18s <span class="type">Start</span> <span class="type">Test</span> at <span class="number">2022</span><span class="operator">-</span><span class="number">02</span><span class="operator">-</span><span class="number">25</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">37.506</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">62</span>.27s <span class="type">Set</span> <span class="type">Up</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">62</span>.28s <span class="type">Open</span> com.zcx.iosclient</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">62</span>.35s     <span class="type">Launch</span> com.zcx.iosclient</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">66</span>.50s         <span class="type">Setting</span> up automation session</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">67</span>.71s         <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">70</span>.00s <span class="type">Tap</span> <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">70</span>.00s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">71</span>.77s     <span class="type">Find</span> the <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.10s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.14s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.30s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.42s <span class="type">Tap</span> <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.42s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.49s     <span class="type">Find</span> the <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.52s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.53s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.67s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.75s <span class="type">Tap</span> <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.75s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">72</span>.81s     <span class="type">Find</span> the <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">73</span>.85s         <span class="type">Find</span> the <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span> (retry <span class="number">1</span>)</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">73</span>.91s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">73</span>.93s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">74</span>.07s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.66s <span class="type">Tap</span> <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.66s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.74s     <span class="type">Find</span> the <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.81s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.83s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">75</span>.98s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.58s <span class="type">Tap</span> <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.58s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.68s     <span class="type">Find</span> the <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.78s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.81s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">77</span>.97s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">79</span>.10s <span class="type">Checking</span> `<span class="type">Expect</span> predicate `exists <span class="operator">&gt;=</span> <span class="number">1</span>` <span class="keyword">for</span> object <span class="string">&quot;已预约&quot;</span> <span class="type">StaticText</span>`</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">79</span>.10s     <span class="type">Checking</span> existence of `<span class="string">&quot;已预约&quot;</span> <span class="type">StaticText</span>`</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">79</span>.17s <span class="type">Tear</span> <span class="type">Down</span></span><br><span class="line"><span class="type">Test</span> <span class="type">Case</span> &#x27;<span class="operator">-</span>[<span class="type">ClientUITests</span>.<span class="type">ClientUITestsLaunchTests</span> testSubscribeLiveInLiveHome]&#x27; passed (<span class="number">79.370</span> seconds).</span><br><span class="line"><span class="type">Test</span> <span class="type">Case</span> &#x27;<span class="operator">-</span>[<span class="type">ClientUITests</span>.<span class="type">ClientUITestsLaunchTests</span> testSubscribeLiveInLiveHome]&#x27; started.</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">0</span>.00s <span class="type">Setting</span> appearance mode to <span class="type">Dark</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.10s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.19s <span class="type">Start</span> <span class="type">Test</span> at <span class="number">2022</span><span class="operator">-</span><span class="number">02</span><span class="operator">-</span><span class="number">25</span> <span class="number">15</span>:<span class="number">18</span>:<span class="number">56.883</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.26s <span class="type">Set</span> <span class="type">Up</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.26s <span class="type">Open</span> com.zcx.iosclient</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.33s     <span class="type">Launch</span> com.zcx.iosclient</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">2</span>.33s         <span class="type">Terminate</span> com.zcx.iosclient:<span class="number">21694</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">4</span>.44s         <span class="type">Setting</span> up automation session</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">5</span>.53s         <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">7</span>.76s <span class="type">Tap</span> <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">7</span>.76s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.30s     <span class="type">Find</span> the <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.53s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;直播&quot;</span> <span class="type">Button</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.57s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.72s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.86s <span class="type">Tap</span> <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.86s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.94s     <span class="type">Find</span> the <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.96s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>     <span class="number">9</span>.97s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">10</span>.12s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">10</span>.21s <span class="type">Tap</span> <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">10</span>.21s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">10</span>.27s     <span class="type">Find</span> the <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">11</span>.29s         <span class="type">Find</span> the <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span> (retry <span class="number">1</span>)</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">11</span>.39s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;即将开播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">11</span>.42s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">11</span>.57s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.18s <span class="type">Tap</span> <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.18s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.26s     <span class="type">Find</span> the <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.33s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="type">Other</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.35s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">13</span>.51s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.09s <span class="type">Tap</span> <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.09s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.29s     <span class="type">Find</span> the <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.39s     <span class="type">Check</span> <span class="keyword">for</span> interrupting elements affecting <span class="string">&quot;预约直播&quot;</span> <span class="type">StaticText</span></span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.41s     <span class="type">Synthesize</span> event</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">15</span>.58s     <span class="type">Wait</span> <span class="keyword">for</span> com.zcx.iosclient to idle</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">16</span>.67s <span class="type">Checking</span> `<span class="type">Expect</span> predicate `exists <span class="operator">&gt;=</span> <span class="number">1</span>` <span class="keyword">for</span> object <span class="string">&quot;已预约&quot;</span> <span class="type">StaticText</span>`</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">16</span>.67s     <span class="type">Checking</span> existence of `<span class="string">&quot;已预约&quot;</span> <span class="type">StaticText</span>`</span><br><span class="line">    t <span class="operator">=</span>    <span class="number">16</span>.74s <span class="type">Tear</span> <span class="type">Down</span></span><br><span class="line"><span class="type">Test</span> <span class="type">Case</span> &#x27;<span class="operator">-</span>[<span class="type">ClientUITests</span>.<span class="type">ClientUITestsLaunchTests</span> testSubscribeLiveInLiveHome]&#x27; passed (<span class="number">16.947</span> seconds).</span><br><span class="line"></span><br><span class="line"><span class="type">Test</span> <span class="type">Suite</span> &#x27;<span class="type">ClientUITestsLaunchTests</span>&#x27; passed at <span class="number">2022</span><span class="operator">-</span><span class="number">02</span><span class="operator">-</span><span class="number">25</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">11.642</span>.</span><br><span class="line"><span class="type">Executed</span> <span class="number">2</span> tests, with <span class="number">0</span> failures (<span class="number">0</span> unexpected) <span class="keyword">in</span> <span class="number">96.317</span> (<span class="number">96.319</span>) seconds</span><br><span class="line"></span><br><span class="line"><span class="type">Test</span> <span class="type">Suite</span> &#x27;<span class="type">ClientUITests</span>.xctest&#x27; passed at <span class="number">2022</span><span class="operator">-</span><span class="number">02</span><span class="operator">-</span><span class="number">25</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">11.644</span>.</span><br><span class="line"><span class="type">Executed</span> <span class="number">2</span> tests, with <span class="number">0</span> failures (<span class="number">0</span> unexpected) <span class="keyword">in</span> <span class="number">96.317</span> (<span class="number">96.321</span>) seconds</span><br><span class="line"></span><br><span class="line"><span class="type">Test</span> <span class="type">Suite</span> &#x27;<span class="type">Selected</span> tests&#x27; passed at <span class="number">2022</span><span class="operator">-</span><span class="number">02</span><span class="operator">-</span><span class="number">25</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">11.647</span>.</span><br><span class="line"><span class="type">Executed</span> <span class="number">2</span> tests, with <span class="number">0</span> failures (<span class="number">0</span> unexpected) <span class="keyword">in</span> <span class="number">96.317</span> (<span class="number">96.324</span>) seconds</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>技术调研</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 从入门到放弃</title>
    <url>/2022/07/06/SwiftUI/</url>
    <content><![CDATA[<p><img src="https://cdn.zcx.info/e6c9d24ely1h4461xrrg2j211906rjrv.jpg" alt="SWiftUITitleImage"></p>
<h2 id="什么是SwiftUI"><a href="#什么是SwiftUI" class="headerlink" title="什么是SwiftUI"></a>什么是SwiftUI</h2><p>SwiftUI 于 2019 年度 WWDC 全球开发者大会上发布，它是基于 Swift 建立的声明式UI框架。</p>
<p>该框架可以用于 watchOS、tvOS、macOS、iOS 等平台的应用开发，等于说统一了苹果生态圈的开发工具。</p>
<blockquote>
<p>SwiftUI provides views, controls, and layout structures for declaring your app’s user interface. The framework provides event handlers for delivering taps, gestures, and other types of input to your app, and tools to manage the flow of data from your app’s models down to the views and controls that users will see and interact with.</p>
</blockquote>
<h2 id="SwiftUI-Hello-World"><a href="#SwiftUI-Hello-World" class="headerlink" title="SwiftUI Hello World"></a>SwiftUI Hello World</h2><p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">创建新项目并预览画布</a></p>
<p>和平时创建新项目流程基本一致。只需要选择Swift UI Interface即可。</p>
<p><img src="https://cdn.zcx.info/e6c9d24ely1h36ny2yym8j213002fmx4.jpg" alt="2"></p>
<p>工程初始化创建完毕后可以看到文件结构如下：</p>
<p><img src="https://cdn.zcx.info/e6c9d24ely1h36o3x0gvgj207h04lglm.jpg" alt="3"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="title class_">SwiftUIClient</span></span><br><span class="line">│   ├── <span class="title class_">Assets</span>.xcassets /<span class="regexp">/ 素材文件夹</span></span><br><span class="line"><span class="regexp">│   │   ├── AccentColor.colorset</span></span><br><span class="line"><span class="regexp">│   │   │   └── Contents.json</span></span><br><span class="line"><span class="regexp">│   │   ├── AppIcon.appiconset</span></span><br><span class="line"><span class="regexp">│   │   │   └── Contents.json</span></span><br><span class="line"><span class="regexp">│   │   └── Contents.json</span></span><br><span class="line"><span class="regexp">│   ├── ContentView.swift /</span><span class="regexp">/ 默认view</span></span><br><span class="line"><span class="regexp">│   ├── Preview Content</span></span><br><span class="line"><span class="regexp">│   │   └── Preview Assets.xcassets</span></span><br><span class="line"><span class="regexp">│   │       └── Contents.json</span></span><br><span class="line"><span class="regexp">│   └── SwiftUIClientApp.swift /</span><span class="regexp">/ APP入口文件</span></span><br><span class="line"><span class="regexp">└── SwiftUIClient.xcodeproj </span></span><br><span class="line"><span class="regexp">    ├── project.pbxproj</span></span><br><span class="line"><span class="regexp">    └── xcuserdata</span></span><br><span class="line"><span class="regexp">        └── pxcm-0101-01-0246.xcuserdatad</span></span><br><span class="line"><span class="regexp">            └── xcschemes</span></span><br><span class="line"><span class="regexp">                └── xcschememanagement.plist</span></span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="@main"></a>@main</h2><p>找到APP入口文件<code>SwiftUIClientApp.swift</code>中的<code>@main</code>标记<br>根据经验APP会从@main入口启动开始执行</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SwiftUIClientApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">ContentView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会遇到三个新的结构: App, Scene, WindowGroup</p>
<h3 id="App-Protocol"><a href="#App-Protocol" class="headerlink" title="App Protocol"></a>App Protocol</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">14.0</span>, <span class="keyword">macOS</span> <span class="number">11.0</span>, <span class="keyword">tvOS</span> <span class="number">14.0</span>, <span class="keyword">watchOS</span> <span class="number">7.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">App</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过声明符合<code>App</code>协议的结构来创建应用程序。实现所需的<a href="https://developer.apple.com/documentation/swiftui/app/body-swift.property"><code>body</code></a>计算属性来定义应用程序的内容。</p>
<p>在结构声明之前加上<a href="https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#ID626">@main</a>属性，表明您的自定义<code>App</code>协议符合者提供了应用程序的入口点。<a href="https://developer.apple.com/documentation/swiftui/app/main()"><code>main()</code></a>该协议提供了系统调用以启动您的应用程序的方法的默认实现。在所有应用程序文件中只可以有一个入口点。</p>
<p>可以简单理解为APP的外壳&#x2F;容器</p>
<h3 id="Scene-Protocol"><a href="#Scene-Protocol" class="headerlink" title="Scene Protocol"></a>Scene Protocol</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">14.0</span>, <span class="keyword">macOS</span> <span class="number">11.0</span>, <span class="keyword">tvOS</span> <span class="number">14.0</span>, <span class="keyword">watchOS</span> <span class="number">7.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Scene</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以<a href="https://developer.apple.com/documentation/swiftui/app"><code>App</code></a>通过组合一个或多个符合<code>Scene</code>应用程序中协议的实例来创建<a href="https://developer.apple.com/documentation/swiftui/app/body-swift.property"><code>body</code></a>. 您可以使用 SwiftUI 提供的内置场景，例如，以及您从其他场景中组合的自定义场景。要创建自定义场景，请声明符合协议的类型。实现所需的计算属性并为您的自定义场景提供内容：<a href="https://developer.apple.com/documentation/swiftui/windowgroup"><code>WindowGroup</code></a><code>Scene</code><a href="https://developer.apple.com/documentation/swiftui/scene/body-swift.property"><code>body</code></a></p>
<p>场景是视图（View）层次结构的容器。通过在App实例的body中组合一个或多个符合Scene协议的实例来呈现具体程序。</p>
<ul>
<li>生命周期由系统管理</li>
<li>系统会根据运行平台的不同而调整场景的展示行为（比如相同的代码在iOS和macOS下的呈现不同，或者某些场景仅能运行于特定的平台）</li>
<li>SwiftUI2.0提供了几个预置的场景，用户也可以自己编写符合Scene协议的场景。上述代码中便是使用的一个预置场景WindowGroup</li>
</ul>
<p>可以简单理解为多窗口模式下的某一个窗口(iPad&#x2F;Mac)</p>
<h3 id="WindowGroup-Struct"><a href="#WindowGroup-Struct" class="headerlink" title="WindowGroup Struct"></a>WindowGroup Struct</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">14.0</span>, <span class="keyword">macOS</span> <span class="number">11.0</span>, <span class="keyword">tvOS</span> <span class="number">14.0</span>, <span class="keyword">watchOS</span> <span class="number">7.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">WindowGroup</span>&lt;<span class="type">Content</span>&gt; : <span class="type">Scene</span> <span class="keyword">where</span> <span class="type">Content</span> : <span class="type">View</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最常用的Scene，可以呈现一组结构相同的窗口。使用该场景，我们无需在代码上做修改，只需要在项目中设定是否支持多窗口，系统将会按照运行平台的特性自动管理。</p>
<p>如果在一个WindowGroup里加入多个View,呈现状态有点类似VStack。从上到下依排列</p>
<p>在一个Scene中加入多个WindowGroup，只有最前面的可以被显示。</p>
<h2 id="View-Protocol-和常用控件"><a href="#View-Protocol-和常用控件" class="headerlink" title="View Protocol 和常用控件"></a>View Protocol 和常用控件</h2><p>SwiftUI使用过程中可以明显感觉到整个APP都是使用一系列View互相嵌套&#x2F;堆叠而成的。</p>
<p>View 协议是整个UI界面的基础,提供配置界面的各个部分。</p>
<blockquote>
<p>A type that represents part of your app’s user interface and provides modifiers that you use to configure views.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;我是一个设置了蓝底白字行间距5内边距5边框3的Text控件&quot;</span>)</span><br><span class="line">.lineLimit(<span class="number">2</span>)<span class="comment">// 最大2行</span></span><br><span class="line">.font(.largeTitle) <span class="comment">// 字体</span></span><br><span class="line">.foregroundColor(.white)<span class="comment">// 字体颜色</span></span><br><span class="line">.background(.blue) <span class="comment">// 背景颜色</span></span><br><span class="line">.lineSpacing(<span class="number">5</span>) <span class="comment">// 行间距</span></span><br><span class="line">.padding(.all, <span class="number">5</span>) <span class="comment">// 文字和空间间的内边距</span></span><br><span class="line">.border(.blue, width: <span class="number">3</span>)<span class="comment">// 边框</span></span><br><span class="line">.rotationEffect(<span class="type">Angle</span>(degrees: <span class="number">50</span>)) <span class="comment">// 旋转</span></span><br></pre></td></tr></table></figure>

<p>简单且强大的文本控件,类似于UILabel.可以支持很短的代码设置所需属性</p>
<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3i0g7vwrdj214w0mjacl.jpg"></image></pre>
</details>

<h4 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">TextField</span>(<span class="string">&quot;输入框&quot;</span>, text: <span class="variable">$value</span>)</span><br><span class="line">.textFieldStyle(.roundedBorder)</span><br><span class="line">.keyboardType(.alphabet)</span><br></pre></td></tr></table></figure>

<p>相当于UIKit中的UITextField的单行文本输入框.支持banging一个@state修饰的string变量。</p>
<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3i5s1lrouj214r0mejuw.jpg"></image></pre>
</details>

<h4 id="SecureField"><a href="#SecureField" class="headerlink" title="SecureField"></a>SecureField</h4><p>密码输入框,用法和普通的输入框一致</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SecureField</span>(<span class="string">&quot;密码输入&quot;</span>, text: <span class="variable">$value</span>)</span><br><span class="line">.textFieldStyle(.roundedBorder)</span><br><span class="line">.keyboardType(.alphabet)</span><br><span class="line">.accentColor(.red)</span><br></pre></td></tr></table></figure>

<h4 id="TextEditor"><a href="#TextEditor" class="headerlink" title="TextEditor"></a>TextEditor</h4><p>类似UITextView,多行输入文本</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">TextEditor</span>(text: <span class="variable">$value</span>)</span><br><span class="line">.keyboardType(.default)</span><br><span class="line">.multilineTextAlignment(.leading)</span><br><span class="line">.accentColor(.red)</span><br><span class="line">.foregroundColor(.black)</span><br><span class="line">.background(.gray.opacity(<span class="number">0.3</span>))</span><br><span class="line">.lineSpacing(<span class="number">5</span>)</span><br><span class="line">.frame(maxHeight: <span class="number">500</span>)</span><br><span class="line">.textInputAutocapitalization(.words)</span><br><span class="line">.disableAutocorrection(<span class="literal">true</span> )</span><br><span class="line">.onChange(of: value) &#123; newValue <span class="keyword">in</span></span><br><span class="line">    textCount <span class="operator">=</span> newValue.count <span class="comment">// 输入文本变化监听器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3i8b01bi2j214q0mg437.jpg"></image></pre>
</details>

<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><h4 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带边框style的button</span></span><br><span class="line"><span class="type">Button</span>(<span class="string">&quot;不应用边框的按钮样式&quot;</span>)&#123;&#125;.buttonStyle(<span class="type">BorderlessButtonStyle</span>()).padding()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过自定义PrimitiveButtonStyle类来实现一些自定义的button</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PriButton</span>: <span class="title class_ inherited__">PrimitiveButtonStyle</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Body</span> <span class="operator">=</span> <span class="type">Button</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeBody</span>(<span class="params">configuration</span>: <span class="type">Configuration</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        configuration.trigger()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        <span class="type">Button</span>(configuration)</span><br><span class="line">            .background(<span class="type">Color</span>.orange)</span><br><span class="line">            .clipShape(<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">25.0</span>, style: .continuous))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接使用label参数设置自定义view</span></span><br><span class="line"><span class="type">Button</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;click&quot;</span>) <span class="comment">// 事件block</span></span><br><span class="line">&#125; label: &#123;</span><br><span class="line">   <span class="comment">//这里可以放自定义view</span></span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;star&quot;</span>).offset(x: <span class="operator">-</span><span class="number">10</span>, y: <span class="number">0</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;带图标的按钮&quot;</span>)</span><br><span class="line">&#125;.padding()</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3i0k7u9qvj213d0mj42p.jpg"></image></pre>
</details>

<h4 id="Menu-PullDownButton"><a href="#Menu-PullDownButton" class="headerlink" title="Menu(PullDownButton)"></a>Menu(<em>PullDownButton</em>)</h4><p>点击弹出选择菜单,可以加在toolbar上或者其他地方,本体是一个Button,也可以是自定义View.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Menu</span>(<span class="string">&quot;menu&quot;</span>) &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Duplicate&quot;</span>, action: duplicate)</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Rename&quot;</span>, action: rename)</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Delete…&quot;</span>, action: delete)</span><br><span class="line">    <span class="type">Menu</span>(<span class="string">&quot;Copy&quot;</span>) &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Copy&quot;</span>, action: <span class="keyword">copy</span>)</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Copy Formatted&quot;</span>, action: copyFormatted)</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Copy Library Path&quot;</span>, action: copyPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.menuStyle(.borderlessButton)</span><br><span class="line"></span><br><span class="line"><span class="type">Menu</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Open in Preview&quot;</span>, action: openInPreview)</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Save as PDF&quot;</span>, action: saveAsPDF)</span><br><span class="line">&#125; label: &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;document&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;PDF&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3i91gt97aj214s0mgn15.jpg"></image></pre>
</details>

<h4 id="EditButton"><a href="#EditButton" class="headerlink" title="EditButton"></a>EditButton</h4><p>支持改变整个环境变量中的editMode字段,开启编辑状态后一些系统控件会自动触发状态变化。例如支持删除或者排序的List中的ForEach列表在开启editmode后会显示出List的编辑功能。</p>
<p>当然,你也可以创建一些支持编辑模式的View,同时也可以监听环境中的editMode。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Environment</span>(\.editMode) <span class="keyword">var</span> editMode</span><br></pre></td></tr></table></figure>

<p>经常会和toolbar功能共用,在导航条右上角支持编辑模式。</p>
<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3j3vq77r8j214l0md793.jpg"></image></pre>
</details>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="List-Section-ForEach"><a href="#List-Section-ForEach" class="headerlink" title="List, Section, ForEach"></a>List, Section, ForEach</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>&#123;</span><br><span class="line">  <span class="type">Section</span>(<span class="string">&quot;水果列表&quot;</span>) &#123;</span><br><span class="line">      <span class="type">ForEach</span>(fruits, id: \.<span class="keyword">self</span>) &#123; fruit <span class="keyword">in</span></span><br><span class="line">          <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(fruit)</span>&quot;</span>)</span><br><span class="line">      &#125;.onMove &#123; indexSet, index <span class="keyword">in</span></span><br><span class="line">          fruits.move(fromOffsets: indexSet, toOffset: index)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="operator">!</span>balls.isEmpty &#123;</span><br><span class="line">      <span class="type">Section</span>(<span class="string">&quot;球类列表&quot;</span>) &#123;</span><br><span class="line">          <span class="type">ForEach</span>(balls, id: \.<span class="keyword">self</span>) &#123; ball <span class="keyword">in</span></span><br><span class="line">              <span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(ball)</span>&quot;</span>)</span><br><span class="line">          &#125;.onDelete &#123; indexSet <span class="keyword">in</span></span><br><span class="line">              balls.remove(atOffsets: indexSet)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List类似UIKit中的UITableView,常与ForEach语句一起使用。不像UIKit中繁琐的代理和数据源模式,List是字面含义的View列表,手动将每个VIew排列起来即可。</p>
<p>当然List也可以直接装填数据源进行列表展示</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">100</span>)&#123; i <span class="keyword">in</span></span><br><span class="line">  <span class="type">Text</span>(<span class="string">&quot;id:<span class="subst">\(id)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Section则可理解为UITableView中的SectionHeader和Footer在SwiftUI中的实现.List和Section联合使用可以实现常用的多Section的tableview。</p>
<p>ForEach语句需求传入的数据拥有唯一标识,针对数组可以直接使用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ForEach</span>(array.indices, id: \.<span class="keyword">self</span>)&#123; index <span class="keyword">in</span></span><br><span class="line"> <span class="comment">//some view</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3j3sni4zjj214s0mhtbz.jpg"></image></pre>
</details>

<h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>Group用于集合多个视图，对 Group 设置的属性，将作用于每个子视图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Group</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.foregroundColor(.blue)</span><br><span class="line">.font(.caption)</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3rnl7bryaj213o0metbb.jpg"></image></pre>
</details>

<h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>Form是SwiftUI的基础控件，如果我们需要显示产品配置、选项、用户输入时，使用Form可以快速搭建出各类表单。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="type">Form</span> &#123;</span><br><span class="line">    <span class="type">Section</span> &#123;</span><br><span class="line">        <span class="type">HStack</span>&#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;star.fill&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;输入的内容:<span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TextField</span>(<span class="string">&quot;输入框的placeholder&quot;</span>, text: <span class="variable">$value</span>)</span><br><span class="line">            .textFieldStyle(.roundedBorder)</span><br><span class="line">            .keyboardType(.alphabet)</span><br><span class="line">            .accentColor(.red)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;一个简单的Form写法,如果我们需要显示产品配置、选项、用户输入时，使用Form可以快速搭建出各类表单,会自动增加内边距&quot;</span>)</span><br><span class="line">            .font(.caption)</span><br><span class="line">            .foregroundColor(.gray)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Section</span>(<span class="string">&quot;另一组内容&quot;</span>) &#123;</span><br><span class="line">        <span class="type">HStack</span>&#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;star&quot;</span>)</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;一个右对齐的文案&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3jl3sied0j214q0mb0w3.jpg"></image></pre>
</details>

<h4 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h4><p>在有限空间放较多内容的容器View</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ScrollView</span>(.vertical, showsIndicators: <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="type">ForEach</span>(list, id:\.<span class="keyword">self</span>) &#123; item <span class="keyword">in</span></span><br><span class="line">        <span class="type">Text</span>(item).padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3jbr3uhfej214s0mfjy1.jpg"></image></pre>
</details>

<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h4 id="VStack-HStack"><a href="#VStack-HStack" class="headerlink" title="VStack,HStack"></a>VStack,HStack</h4><p>VStack类似UIStackView,属于布局修饰符,其中包裹的view会按照一定的规则进行垂直方向的自动布局。</p>
<p>同理HStack会在水平方向自动布局,二者可叠加嵌套。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;垂直方向左对齐&quot;</span>).border(.blue, width: <span class="number">1</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;设置的两个label&quot;</span>).border(.blue, width: <span class="number">1</span>)</span><br><span class="line">    <span class="type">HStack</span>(alignment: .center, spacing: <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;嵌套一个水平方向的HStack&quot;</span>).border(.blue, width: <span class="number">1</span>)</span><br><span class="line">        <span class="type">Spacer</span>()</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;的两个label&quot;</span>).border(.blue, width: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3uoh36i9gj213v0n1418.jpg"></image></pre>
</details>

<h4 id="ZStack"><a href="#ZStack" class="headerlink" title="ZStack"></a>ZStack</h4><p>ZStack的布局方式类似于UIKit中的View父子层级,但是SwiftUI中较少提及父子层级关系,SwiftUI中认为每个View都是独立的View,仅仅是布局方式的不同。</p>
<p>例如在UIKit中在一个View内部增加几个小View会用到addSubview方法来添加子View,但是在SwiftUI中会使用ZStack布局方式来进行View堆叠。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ZStack</span>(alignment: .center) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font></summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3uorpdw9qj213s0mtn0l.jpg"></image></pre>
</details>

<h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><h4 id="TabView"><a href="#TabView" class="headerlink" title="TabView"></a>TabView</h4><p>类似UIKit中的UITabbar承担tab切换的功能</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TabType</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> featureList</span><br><span class="line">    <span class="keyword">case</span> other</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">  <span class="comment">//FeatureListHomeView是这个tabbar的root层级的view</span></span><br><span class="line">  <span class="type">FeatureListHomeView</span>().tabItem(&#123;</span><br><span class="line">      <span class="type">Label</span>(<span class="string">&quot;列表&quot;</span>, systemImage: <span class="string">&quot;list.bullet&quot;</span>)<span class="comment">// tabItem来进行展示内容</span></span><br><span class="line">  &#125;).tag(<span class="type">TabType</span>.featureList) <span class="comment">// .tag来标志映射</span></span><br><span class="line"></span><br><span class="line">  <span class="type">CustomViews</span>().tabItem(&#123;</span><br><span class="line">      <span class="type">Label</span>(<span class="string">&quot;自定义&quot;</span>, systemImage: <span class="string">&quot;star&quot;</span>)</span><br><span class="line">  &#125;).tag(<span class="type">TabType</span>.other)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3jkd4vkktj214o0men09.jpg"></image></pre>
</details>

<h4 id="NavigationView-NavigationLink"><a href="#NavigationView-NavigationLink" class="headerlink" title="NavigationView, NavigationLink"></a>NavigationView, NavigationLink</h4><p>类似UINavigationViewController,负责导航栈的管理。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line"><span class="type">List</span> &#123;</span><br><span class="line">    <span class="type">ForEach</span>(feature.demoFeatures.featureSections, id: \.<span class="keyword">self</span>) &#123; sec <span class="keyword">in</span></span><br><span class="line">        <span class="type">Section</span>(sec.featureSectionName) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(sec.featureList, id: \.<span class="keyword">self</span>) &#123; item <span class="keyword">in</span></span><br><span class="line">                <span class="type">NavigationLink</span> &#123;</span><br><span class="line">                    getDestinationViews(featureItem: item)</span><br><span class="line">                &#125; label: &#123;</span><br><span class="line">                    <span class="type">DemoRowView</span>(title: item.featureName, subTitle: item.featureDesc)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.onDelete &#123; offset <span class="keyword">in</span></span><br><span class="line">                deleteRow(offset: offset, from: sec)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.listStyle(.in<span class="keyword">set</span>)</span><br><span class="line">.navigationTitle(<span class="string">&quot;控件列表&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>一般配合NavigationLink来进行点击跳转.类似的,导航栈跳转后续的页面共用同一个导航栈。可以通过navigationTitle方法设置导航栈的标题,通过navigationBarTitleDisplayMode方法设置导航标题的展示形式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">.navigationTitle(<span class="string">&quot;NavigationView&quot;</span>)</span><br><span class="line">.navigationBarTitleDisplayMode(.inline)<span class="comment">// 只在顶部标题区域显示</span></span><br><span class="line">.navigationBarTitleDisplayMode(.large)<span class="comment">// 会在当前页面顶部显示一个较大的标题</span></span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3n25qldn7j214q0mg0va.jpg"></image></pre>
</details>

<h4 id="Modal"><a href="#Modal" class="headerlink" title="Modal"></a>Modal</h4><p>模态弹出是经常使用的一种弹出信息页面的模式。</p>
<p>SwiftUI给VIew增加的.sheet的扩展,给定一个绑定的值,当这个值发生变化的时候(true),触发模态框的事件。</p>
<p>UIKit中的Present VIewController不同的style,有半弹窗和全屏present</p>
<p>同理,SwiftUI给VIew增加了.fullScreenCover的扩展,给定一个绑定的值,当这个值发生变化的时候(true),触发全屏模态框的事件。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Form</span>&#123;</span><br><span class="line">  <span class="type">Button</span>(<span class="string">&quot;Modal New View&quot;</span>) &#123;</span><br><span class="line">      isPresented.toggle()</span><br><span class="line">  &#125;.sheet(isPresented: <span class="variable">$isPresented</span>, onDismiss: &#123;</span><br><span class="line">      <span class="comment">// dismiss</span></span><br><span class="line">  &#125;) &#123;</span><br><span class="line">      <span class="type">ImageDemo</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Button</span>(<span class="string">&quot;FullScreenCover New View&quot;</span>) &#123;</span><br><span class="line">      fullScreenCover.toggle()</span><br><span class="line">  &#125;.fullScreenCover(isPresented: <span class="variable">$fullScreenCover</span>) &#123;</span><br><span class="line">      <span class="type">TextEditorDemo</span>(value: <span class="string">&quot;FullScreenCover&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3pdafcupzj213e0mgwgx.jpg"></image></pre>
</details>

<h4 id="Popover"><a href="#Popover" class="headerlink" title="Popover"></a>Popover</h4><p>Popover在不同的设备上展示会出现差异,在iOS上是模态弹出一个新页面,在iPad或Mac上弹出一个气泡框。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;Popover New View&quot;</span>) &#123;</span><br><span class="line">    popover.toggle()</span><br><span class="line">&#125;.popover(isPresented: <span class="variable">$popover</span>) &#123;</span><br><span class="line">   <span class="type">Text</span>(<span class="string">&quot;在iphone上显示为模态框弹出页面,在ipad上显示为点击气泡弹窗&quot;</span>)</span><br><span class="line">        .padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3ro8fw598j21380fatah.jpg"></image></pre>
</details>

<h3 id="Pickers"><a href="#Pickers" class="headerlink" title="Pickers"></a>Pickers</h3><h4 id="Picker"><a href="#Picker" class="headerlink" title="Picker"></a>Picker</h4><p>可以自定义数据的选择器</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Picker</span>(selection: <span class="variable">$selectIndex</span>) &#123;</span><br><span class="line">  <span class="type">ForEach</span>(fruits, id: \.<span class="keyword">self</span>) &#123; fruit <span class="keyword">in</span></span><br><span class="line">      <span class="type">Text</span>(fruit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; label: &#123;</span><br><span class="line">  <span class="type">Text</span>(<span class="string">&quot;Picker&quot;</span>)</span><br><span class="line">&#125;.pickerStyle(.wheel) <span class="comment">// 使用此方法切换选择风格</span></span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3n2vebx0zj214s0mijv7.jpg"></image></pre>
</details>

<h4 id="DatePicker"><a href="#DatePicker" class="headerlink" title="DatePicker"></a>DatePicker</h4><p>系统内置的时间选择器</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DatePicker</span>(<span class="string">&quot;选择日期&quot;</span>, selection: <span class="variable">$selectDate</span>, displayedComponents: .date)</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3nr7v7zu9j214p0mdjvb.jpg"></image></pre>
</details>

<h4 id="Toggle"><a href="#Toggle" class="headerlink" title="Toggle"></a>Toggle</h4><p>类似于UISwitch,用于开关选择</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Toggle</span>(<span class="string">&quot;开关&quot;</span>, isOn: <span class="variable">$open</span>)</span><br><span class="line">.onChange(of: <span class="keyword">open</span>) &#123; newValue <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;切换了开关状态&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3o0cr0v3mj214q0mdmz8.jpg"></image></pre>
</details>

<h4 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h4><p>Slider相当于UIKit中的UISlider，通过移动滑杆实现指定区域和间隔的数值的选择。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Slider</span>(value: <span class="variable">$opacity</span>, in: <span class="number">0.1</span> <span class="operator">...</span> <span class="number">1.0</span>, step: <span class="number">0.05</span>).accentColor(.red)</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3p7s7u4plj214v0mf0vu.jpg"></image></pre>
</details>

<h4 id="Stepper"><a href="#Stepper" class="headerlink" title="Stepper"></a>Stepper</h4><p>步进选择器</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Stepper</span>(<span class="string">&quot;有限的选择数量&quot;</span>, value: <span class="variable">$value</span>, in: <span class="operator">-</span><span class="number">1</span> <span class="operator">...</span> <span class="number">5</span>, step: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3p82b0ae5j214r0mhace.jpg"></image></pre>
</details>

<h3 id="Alerts"><a href="#Alerts" class="headerlink" title="Alerts"></a>Alerts</h3><h4 id="Alert"><a href="#Alert" class="headerlink" title="Alert"></a>Alert</h4><p>AlertView将被废弃,被.alert方法替代</p>
<p>swiftUI给VIew增加了.alert的扩展,给定一个绑定的值,当这个值发生变化的时候(true),触发Alert的事件。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.alert(<span class="string">&quot;Alert Title&quot;</span>, isPresented: <span class="variable">$isPresented1</span>, actions: &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;OK&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">// button点击事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, message: &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;一个选择项的Alert&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当action中的button数量不同时会自动切换alert的显示格式</p>
<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3pcgv2l0dj213s0mgjuh.jpg"></image></pre>
</details>

<h4 id="ActionSheet"><a href="#ActionSheet" class="headerlink" title="ActionSheet"></a>ActionSheet</h4><p>ActionSheet将被废弃,被.confirmationDialog替代</p>
<p>SwiftUI给VIew增加了.confirmationDialog的扩展,给定一个绑定的值,当这个值发生变化的时候(true),触发ActionSheet的事件。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.confirmationDialog(<span class="string">&quot;选择你需要的选项&quot;</span>, isPresented: <span class="variable">$isPresented</span>) &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Update&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// choose update</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Delete&quot;</span>, role: .destructive) &#123;</span><br><span class="line">        <span class="comment">// choose delete</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Cancel&quot;</span>, role:  .cancel) &#123;</span><br><span class="line">        <span class="comment">// choose cancel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24egy1h3pctoaj0pj213k0mfaco.jpg"></image></pre>
</details>

<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>Image,类似于UIImageView,相对于UIimageview,Image控件可以更加简单的设置圆角,边框,阴影等属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(<span class="string">&quot;stmarylake&quot;</span>)</span><br><span class="line">.resizable() <span class="comment">// 必须先设置可以重设尺寸才可以改变图片原始尺寸</span></span><br><span class="line">.frame(width: <span class="number">100</span>, height: <span class="number">100</span>, alignment: .center)</span><br><span class="line">.clipShape(<span class="type">Rectangle</span>()) <span class="comment">// 边缘切割</span></span><br><span class="line">.overlay(<span class="type">Rectangle</span>().stroke(.white, lineWidth: <span class="number">4</span>), alignment: .bottom)<span class="comment">// 覆盖一个等大小的方块增加4的宽度的stroke用来做边框</span></span><br><span class="line">.shadow(radius: <span class="number">10</span>)<span class="comment">// 阴影</span></span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3jk79vi59j214p0mf76j.jpg"></image></pre>
</details>

<h3 id="WebImage"><a href="#WebImage" class="headerlink" title="WebImage"></a>WebImage</h3><p>SwiftUI中的VIew控件可以控制其生命周期,在onAppear的时候进行URL图片下载,下载成功后替换image即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(uiImage: baseImage)</span><br><span class="line">.resizable()</span><br><span class="line">.frame(height: <span class="number">200</span>)</span><br><span class="line">.aspectRatio(contentMode: .fit)</span><br><span class="line">.onAppear &#123;</span><br><span class="line">    downloadImageWithURL(url: url)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">downloadImageWithURL</span>(<span class="params">url</span>: <span class="type">String</span>?) &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> urlStr <span class="operator">=</span> url, <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: urlStr) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="type">SwiftUIDemoHelper</span>.defult.downLoadImageWithURL(url: url) &#123; receivedSize, totalSize <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">let</span> progress <span class="operator">=</span> <span class="type">Float</span>(receivedSize) <span class="operator">/</span> <span class="type">Float</span>(totalSize)</span><br><span class="line">      downloadTaskProgress <span class="operator">=</span> progress</span><br><span class="line">  &#125; completion: &#123; res <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">switch</span> res &#123;</span><br><span class="line">      <span class="keyword">case</span> .success(<span class="keyword">let</span> img):</span><br><span class="line">          baseImage <span class="operator">=</span> img</span><br><span class="line">          downloadTaskProgress <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> .failure(<span class="keyword">_</span>):</span><br><span class="line">          downloadError <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3uxv5n357j213q0natdv.jpg"></image></pre>
</details>

<p>当然可以使用kf图片库来进行网络图片的下载和缓存管理。</p>
<details>
<summary><font color=gray>点击查看长时间下载的加载效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3uxr4o7zbg20oo1hcx6p.gif" height = 400></image></pre>
</details>

<h3 id="Webview"><a href="#Webview" class="headerlink" title="Webview"></a>Webview</h3><p>SwiftUI没有再封装一套新的Webview容器,直接桥接WKWebView即可。</p>
<p>如何和UIKit进行桥接参考后续桥接部分。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> WebKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WebviewDemo</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> url: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> pageTitle: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Webview&quot;</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">       <span class="type">SWWkWebview</span>(url: <span class="variable">$url</span>, pageTitle: <span class="variable">$pageTitle</span>)</span><br><span class="line">            .navigationTitle(pageTitle)</span><br><span class="line">            .navigationBarTitleDisplayMode(.inline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SWWkWebview</span>: <span class="title class_ inherited__">UIViewRepresentable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">UIViewType</span> <span class="operator">=</span> <span class="type">WKWebView</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> url: <span class="type">String</span></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> pageTitle: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeUIView</span>(<span class="params">context</span>: <span class="type">Context</span>) -&gt; <span class="type">WKWebView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> <span class="type">WKWebView</span>()</span><br><span class="line">        view.navigationDelegate <span class="operator">=</span> context.coordinator</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: url) &#123;</span><br><span class="line">            view.load(<span class="type">URLRequest</span>(url: url))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUIView</span>(<span class="keyword">_</span> <span class="params">uiView</span>: <span class="type">WKWebView</span>, <span class="params">context</span>: <span class="type">Context</span>) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeCoordinator</span>() -&gt; <span class="type">Coordinator</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val <span class="operator">=</span>  <span class="type">Coordinator</span>()</span><br><span class="line">        val.updateTitle <span class="operator">=</span> &#123; title <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.pageTitle <span class="operator">=</span> title</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Coordinator</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">var</span> updateTitle: ((<span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">didFinish</span> <span class="params">navigation</span>: <span class="type">WKNavigation</span>!) &#123;</span><br><span class="line">            webView.evaluateJavaScript(<span class="string">&quot;document.title&quot;</span>) &#123; (result, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> title: <span class="type">String</span> <span class="operator">=</span> <span class="type">String</span>(describing: result <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="keyword">self</span>.updateTitle<span class="operator">?</span>(title)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3uqhsiluvj213m0nc42w.jpg"></image></pre>
</details>

<hr>
<h2 id="桥接UIKit"><a href="#桥接UIKit" class="headerlink" title="桥接UIKit"></a>桥接UIKit</h2><p>SwiftUI可以自由的和当前项目中的framework协作，不论你是UIKit还是APPKit或者是WatchKit。这里我们简单说下如何桥接UIKit。</p>
<h3 id="UIViewRepresentable"><a href="#UIViewRepresentable" class="headerlink" title="UIViewRepresentable"></a>UIViewRepresentable</h3><p>有一些View还未被SwiftUI原生实现，需要从UIKit中桥接而来，例如前面的<a href="#Webview">WebviewDemo</a>。当然一些自己封装的View或者三方库View均可桥接到SwiftUI中展示。当我们需要在SwiftUI使用UIKit中的View时，我们需要创建一个实现了UIViewRepresentable协议的结构体作为我们的桥接View。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">UIViewRepresentable</span> : <span class="title class_ inherited__">View</span> <span class="keyword">where</span> <span class="title class_ inherited__">Self</span>.<span class="title class_ inherited__">Body</span> == <span class="title class_ inherited__">Never</span> &#123;</span><br><span class="line">    <span class="comment">/// 首先需要确定你要桥接的View的类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">UIViewType</span> : <span class="type">UIView</span></span><br><span class="line">    <span class="comment">/// 必须实现的协议，系统在初始化结构体的时候会初始化你的View</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeUIView</span>(<span class="params">context</span>: <span class="keyword">Self</span>.<span class="type">Context</span>) -&gt; <span class="keyword">Self</span>.<span class="type">UIViewType</span></span><br><span class="line">    <span class="comment">/// 必须实现的协议，SwiftUI更新的时候会调用此方法让你的View同步更新</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUIView</span>(<span class="keyword">_</span> <span class="params">uiView</span>: <span class="keyword">Self</span>.<span class="type">UIViewType</span>, <span class="params">context</span>: <span class="keyword">Self</span>.<span class="type">Context</span>)</span><br><span class="line">    <span class="comment">/// 非必须实现的协议，相当于 UIView 的 deinit 方法，可以在其中做一些诸如删除通知 observer，停止 timer 等清理工作</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">dismantleUIView</span>(<span class="keyword">_</span> <span class="params">uiView</span>: <span class="keyword">Self</span>.<span class="type">UIViewType</span>, <span class="params">coordinator</span>: <span class="keyword">Self</span>.<span class="type">Coordinator</span>)</span><br><span class="line">    <span class="comment">/// 协调器，当前结构体从UIKit中获取数据的途径，一般用来实现UIKit View 的代理</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Coordinator</span> <span class="operator">=</span> <span class="type">Void</span></span><br><span class="line">    <span class="comment">/// 创建一个协调器，用来连接SwiftUI和UIKit，makeUIView之前就会调用</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeCoordinator</span>() -&gt; <span class="keyword">Self</span>.<span class="type">Coordinator</span></span><br><span class="line">    <span class="comment">/// 存储一些数据的上下文</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Context</span> <span class="operator">=</span> <span class="type">UIViewRepresentableContext</span>&lt;<span class="keyword">Self</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桥接过程的生命周期为：</p>
<p><img src="https://cdn.zcx.info/e6c9d24ely1h3x76m90gnj20b80buglq.jpg" alt="4"></p>
<p>其中updateUIView方法会随着View的刷新调用多次。</p>
<h3 id="UIViewControllerRepresentable"><a href="#UIViewControllerRepresentable" class="headerlink" title="UIViewControllerRepresentable"></a>UIViewControllerRepresentable</h3><p>类似于桥接UIView，SwiftUI也给出了桥接UIViewController的方式</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">UIViewControllerRepresentable</span> : <span class="title class_ inherited__">View</span> <span class="keyword">where</span> <span class="title class_ inherited__">Self</span>.<span class="title class_ inherited__">Body</span> == <span class="title class_ inherited__">Never</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">UIViewControllerType</span> : <span class="type">UIViewController</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeUIViewController</span>(<span class="params">context</span>: <span class="keyword">Self</span>.<span class="type">Context</span>) -&gt; <span class="keyword">Self</span>.<span class="type">UIViewControllerType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUIViewController</span>(<span class="keyword">_</span> <span class="params">uiViewController</span>: <span class="keyword">Self</span>.<span class="type">UIViewControllerType</span>, <span class="params">context</span>: <span class="keyword">Self</span>.<span class="type">Context</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeCoordinator</span>() -&gt; <span class="keyword">Self</span>.<span class="type">Coordinator</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Context</span> <span class="operator">=</span> <span class="type">UIViewControllerRepresentableContext</span>&lt;<span class="keyword">Self</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从实现上来看桥接View和ViewController都是同一种实现方式，都借助了生成一个协调器Coordinator来连接二者。</p>
<hr>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>SwiftUI的设计理念是，所有数据<strong>有且仅有一个</strong>数据源。物理内存中仅仅保存一份数据,其余地方均引用其指针地址。</p>
<h3 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h3><p>SwiftUI中大量使用结构体<code>Struct</code>,结构体中的变量一般是不能修改的,但是在View层级中会随着用户操作或者其他条件触发数据的变化,这个时候我们该如何让数据变化的同时界面跟随刷新变化呢。</p>
<p>如果视图需要存储它可以修改的数据，请使用<a href="https://developer.apple.com/documentation/swiftui/state"><code>State</code></a>属性包装器声明一个变量。</p>
<p>例如我们在开关Demo中使用了用<code>@State</code>包裹着的<code>open</code>属性,当触发开关onchange方法的时候会直接改变open属性的值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ToggleDemo</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">open</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Form</span>&#123;</span><br><span class="line">            <span class="type">Toggle</span>(<span class="string">&quot;开关&quot;</span>, isOn: <span class="variable">$open</span>)</span><br><span class="line">                .onChange(of: <span class="keyword">open</span>) &#123; newValue <span class="keyword">in</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;切换了开关状态&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;开关状态: <span class="subst">\(<span class="keyword">open</span>.description)</span>&quot;</span>)</span><br><span class="line">        &#125;.navigationTitle(<span class="string">&quot;Toggle&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通俗的理解为struct内的属性都是不可变的,但是当你的View的body想要监听某个属性的时候可以给这个属性增加@State修饰符,这样的话就可以在struct内部直接修改此变量而不再使用mutating,同时当此变量发生改变的时候会触发View的重载和刷新。</p>
<p>在State单词的语境下理解这个修饰符会更容易–状态变量。实质为当结构体中的属性发生了改变,Swift会创建一个新的Struct来替换原来的Struct。而@State 能够发现这种变化，并自动重新加载视图。</p>
<p>SwiftUI在别的存储位置专门存放使用@State修饰的变量,来绕过结构体的限制。</p>
<p>注意,这种用法破坏了常识中的结构体的规则,@State 是专门为存储在一个结构体中的简单属性而设计的,所以尽量将使用@State修饰的变量设置为私有的(private)。</p>
<p>值得一提的是SwiftUI支持在任何线程安全地修改@State修饰的变量。</p>
<h3 id="Binding"><a href="#Binding" class="headerlink" title="@Binding"></a>@Binding</h3><p>由上一节的@State我们可以做到数据源变化的时候刷新View,当然有时候会出现一些相反的场景,比如一些View的操作变化产生了新的数据需要回传给另一个View显示,例如之前的WebviewDemo中桥接Wkwebview的SWWkWebview类。</p>
<p>在Wkwebview的WKNavigationDelegate代理中发现Webview加载完毕之后执行JS代码来获取页面的标题,然后反向传递到上层页面的导航条上显示。</p>
<p>这种情况适合使用@Binding修饰符来修饰属性让SwiftUI知晓这里需要使用指针传递,而非值传递(Swift中的struct内属性赋值默认是值传递)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WebviewDemo</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> url: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;https://www.36kr.com&quot;</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> pageTitle: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Webview&quot;</span> <span class="comment">// 默认的标题,状态变量</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">       <span class="type">SWWkWebview</span>(url: <span class="variable">$url</span>, pageTitle: <span class="variable">$pageTitle</span>)<span class="comment">// 注意@Binding的属性需要使用$符号来传递指针值</span></span><br><span class="line">            .navigationTitle(pageTitle)<span class="comment">// pageTitle改变时会更新导航栏标题</span></span><br><span class="line">            .navigationBarTitleDisplayMode(.inline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SWWkWebview</span>: <span class="title class_ inherited__">UIViewRepresentable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">UIViewType</span> <span class="operator">=</span> <span class="type">WKWebView</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// @Binding修饰的属性,说明这个属性需要指针传递,不能使用值传递</span></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> url: <span class="type">String</span></span><br><span class="line">    <span class="comment">// 指针传递才能够做到不增加别的操作就能直接改变外部环境的属性值</span></span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> pageTitle: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeUIView</span>(<span class="params">context</span>: <span class="type">Context</span>) -&gt; <span class="type">WKWebView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> <span class="type">WKWebView</span>()</span><br><span class="line">        view.navigationDelegate <span class="operator">=</span> context.coordinator</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: url) &#123;</span><br><span class="line">            view.load(<span class="type">URLRequest</span>(url: url))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUIView</span>(<span class="keyword">_</span> <span class="params">uiView</span>: <span class="type">WKWebView</span>, <span class="params">context</span>: <span class="type">Context</span>) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeCoordinator</span>() -&gt; <span class="type">Coordinator</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> val <span class="operator">=</span>  <span class="type">Coordinator</span>()</span><br><span class="line">        val.updateTitle <span class="operator">=</span> &#123; title <span class="keyword">in</span></span><br><span class="line">            <span class="comment">//这里更新pageTitle指针指向的属性的值</span></span><br><span class="line">            <span class="keyword">self</span>.pageTitle <span class="operator">=</span> title</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Coordinator</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">WKNavigationDelegate</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">var</span> updateTitle: ((<span class="type">String</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">didFinish</span> <span class="params">navigation</span>: <span class="type">WKNavigation</span>!) &#123;</span><br><span class="line">            webView.evaluateJavaScript(<span class="string">&quot;document.title&quot;</span>) &#123; (result, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> title: <span class="type">String</span> <span class="operator">=</span> <span class="type">String</span>(describing: result <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="comment">// 这里每次加载页面都获取页面的标题,然后执行block进行SWWkWebview结构体的更新</span></span><br><span class="line">                <span class="keyword">self</span>.updateTitle<span class="operator">?</span>(title)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然@Binding的链接是双向的,不仅可以从下向上修改数据,在上层View修改的下层View绑定的数据属性的时候,下层View也会受到影响。</p>
<p>可以看到数据流向图:</p>
<p><img src="https://docs-assets.developer.apple.com/published/d98251c2fac9fc4f6843be1e4836cb93/Managing-User-Interface-State-1@2x.png" alt="基本数据流向"></p>
<p>首先我们在上层View中存在一个@State修饰的状态变量,上层View会观察此变量的变化随之刷新界面,相应刷新的View可能是另外一个下层VIew,不过这个并不影响既定的刷新规则。这种数据流向为单向绑定。</p>
<p>其次我们可以把状态变量的指针传递给下层@Binding修饰的属性变量,当任何一方修改此属性的时候都会触发观察者更新全部的View。这种数据流向为双向绑定。</p>
<p>从上图可以观察到,当使用@State属性来修饰的时候可以认为此属性为值的真实来源,当使用@Binding修饰属性的时候可以认为此属性为真实值的指针。</p>
<p>类似的当看到带有State单词的修饰符时都可以认为当前属性为值的真实来源，且当前View是这个属性的原始持有者。</p>
<h3 id="ObservableObject、-Published、-StateObject"><a href="#ObservableObject、-Published、-StateObject" class="headerlink" title="@ObservableObject、@Published、@StateObject"></a>@ObservableObject、@Published、@StateObject</h3><p>虽然Swift中推荐使用Struct,但是Class的使用还是不可缺少的一环。相比于结构体的值传递,class默认进行的就是指针传递。那么指针传递的Class是否就自动获得了类似于@State和@Binding的功能呢?</p>
<p>答案是NO</p>
<p>SwiftUI中并不会因为你传递进来的是一个类变量就默认自动刷新显示。想要达到这样的效果必须使当前类满足ObservableObject协议。</p>
<p>ObservableObject字面意思,可观察对象。在类中可以添加@Published修饰符来告诉SwiftUI这个类中的这个属性可以发布订阅。</p>
<p>例如我们现在有一个可以显示用户信息的文本可一个点击一下增加一岁的按钮：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;Apple&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomViews</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> user <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span>&#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户名:<span class="subst">\(user.name)</span>&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户年龄:<span class="subst">\(user.age)</span>岁&quot;</span>)</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;一年过去了&quot;</span>) &#123;</span><br><span class="line">                    user.age <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;一年后的年龄:<span class="subst">\(user.age)</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;自定义view组件&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3w250asb2j213u0mqwgy.jpg"></image></pre>
</details>

<p>可以看到我们点了很多次按钮,内存中的age字段已经变成了25,界面上却依旧显示为原始的值,这是因为User类是不可观察的,所以当User中的字段发生改变的时候不能触发页面的刷新.</p>
<p>现在我们为User类增加可观察属性</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;Apple&quot;</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomViews</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="comment">// 以前使用@ObservableObject的时候有user属性被异常释放的风险,改为使用@StateObject修饰符</span></span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> user <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span>&#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户名:<span class="subst">\(user.name)</span>&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户年龄:<span class="subst">\(user.age)</span>岁&quot;</span>)</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;一年过去了&quot;</span>) &#123;</span><br><span class="line">                    user.age <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;一年后的年龄:<span class="subst">\(user.age)</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;自定义view组件&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary><font color=gray>点击查看运行效果</font> </summary>
  <pre><image src="https://cdn.zcx.info/e6c9d24ely1h3w27hniv2j213o0luad5.jpg"></image></pre>
</details>

<p>可以看到随着我们的点击增加user的age字段值,界面上显示的年龄文字也随之增加.</p>
<p>当然你需要给可观察的对象增加**@StateObject**修饰符</p>
<p><strong>为什么不使用@ObservedObject修饰符呢?</strong></p>
<ol>
<li><p>这将确保 User 实例在视图更新时不会被破坏。以前可能已经使用 @ObservedObject 来获得相同的结果，但这是有风险的。有时 @ObservedObject 可能会意外释放它正在存储的对象，因为它不是设计为最终的真相来源目的，但 @StateObject 就不会发生这种情况，因此应该改用它。</p>
</li>
<li><p>@StateObject 和 @ObservedObject 之间有一个重要的区别，即<strong>所有权</strong>，哪个视图创建了对象，哪个视图只是在监视它。规则是这样的：首先创建对象的视图必须使用**@StateObject**，告诉 SwiftUI 它是数据的所有者并负责保持它的活动，所有其它视图都必须使用 <strong>@ObservedObject</strong> 来告诉 SwiftUI，它们想要观察对象的变化但不直接拥有它。即每个对象应该只使用一次 @StateObject，它应该在负责创建对象的任何视图中，共享对象的所有其它视图都应使用@ObservedObject。</p>
</li>
</ol>
<p><strong>思考1: 我们能对Class使用@State修饰吗?</strong></p>
<p>可以,只不过使用@State修饰的时候只有当前值发生变化的时候才会触发View变化,当被修饰的是Class类型的变量时,类内容的属性改变并不能改变当前类的值(指针).所以必须触发类的当前值改变的时候才能和观察者产生一样的效果.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;Apple&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age <span class="operator">=</span> <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomViews</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> user <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span>&#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户名:<span class="subst">\(user.name)</span>&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;当前的用户年龄:<span class="subst">\(user.age)</span>岁&quot;</span>)</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;一年过去了&quot;</span>) &#123;</span><br><span class="line">                  <span class="comment">// 直接生成新的类,或者做类的深拷贝后改变age数值</span></span><br><span class="line">                    <span class="keyword">let</span> userB <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line">                    userB.name <span class="operator">=</span> user.name</span><br><span class="line">                    userB.age <span class="operator">=</span> user.age <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">                    user <span class="operator">=</span> userB</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;自定义view组件&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考2: 我们可以对结构体使用@StateObject吗?</strong></p>
<p>很遗憾不能, 因为@StateObject修饰符必须要求属性满足ObservableObject协议,而非class类型不能遵循协议.</p>
<h3 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="@EnvironmentObject"></a>@EnvironmentObject</h3><p>思考一种场景，如果您有视图 A，并且视图 A 有一些视图 E 想要的数据，使用@ObservedObject 视图 A 需要将对象交给视图 B，视图 B 将把它交给视图 C，然后是视图 D，最后是视图 E，所有中间视图都需要发送对象，即使它们实际上并没有需要它。</p>
<p>这个时候我们可以使用@EnvironmentObject ，视图 A 可以创建一个对象并将其放入环境中；然后，其中的任何视图都可以随时通过请求访问该环境对象，而不必显式传递它，这样会使我们的代码更简单。</p>
<p>例如之前的Demo种的列表数据:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SwiftUIDemoApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> features <span class="operator">=</span> <span class="type">FeatureInfoModel</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">DemoHomeView</span>().environmentObject(features)<span class="comment">//这里向环境变量中添加了一个FeatureInfoModel</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FeatureListHomeView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> feature: <span class="type">FeatureInfoModel</span> <span class="comment">//这个view从环境变量中获取了FeatureInfoModel</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">      <span class="type">NavigationView</span>&#123;</span><br><span class="line">          <span class="type">List</span> &#123;</span><br><span class="line">              <span class="type">ForEach</span>(feature.demoFeatures.featureSections, id: \.<span class="keyword">self</span>) &#123; sec <span class="keyword">in</span></span><br><span class="line">                  <span class="type">Section</span>(sec.featureSectionName) &#123;</span><br><span class="line">                      <span class="type">ForEach</span>(sec.featureList, id: \.<span class="keyword">self</span>) &#123; item <span class="keyword">in</span></span><br><span class="line">                          <span class="type">NavigationLink</span> &#123;</span><br><span class="line">                              getDestinationViews(featureItem: item)</span><br><span class="line">                          &#125; label: &#123;</span><br><span class="line">                              <span class="type">DemoRowView</span>(title: item.featureName, subTitle: item.featureDesc)</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;.onDelete &#123; offset <span class="keyword">in</span></span><br><span class="line">                          deleteRow(offset: offset, from: sec)</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;.listStyle(.in<span class="keyword">set</span>)</span><br><span class="line">          .navigationTitle(<span class="string">&quot;基础控件&quot;</span>)</span><br><span class="line">          .navigationBarTitleDisplayMode(.large)</span><br><span class="line">          .toolbar&#123;</span><br><span class="line">              <span class="type">EditButton</span>()</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显DemoHomeView和FeatureListHomeView中间间隔了一些其他View，类似于全局变量可以直接读取使用。</p>
<p>通常EnvironmentObject用于整个应用程序中一些View都依赖和共享的数据，因为所有的视图都指向同一个模型，当被修饰的属性发生变化时，所有的视图都会立即更新，排除了应用程序的不同部分出现不同步的风险。</p>
<h2 id="应用程序行为控制"><a href="#应用程序行为控制" class="headerlink" title="应用程序行为控制"></a>应用程序行为控制</h2><h3 id="UIApplicationDelegate"><a href="#UIApplicationDelegate" class="headerlink" title="UIApplicationDelegate"></a>UIApplicationDelegate</h3><p>作为一个完整的APP，开发者应该可以控制APP的完整生命周期，这个时候我们需要一个<a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate"><code>UIApplicationDelegate</code></a>类型的对象来承载App生命周期内各种行为的相应。</p>
<p>但是创建SwiftUI项目的时候Xcode并没有给我们默认创建Applegate.swift文件。</p>
<p>如果我们需要实现UIApplicationDelegate方法，我们需要手动创建Applegate.swift文件，并且让我们的Applegate类遵循NSObject协议和UIApplicationDelegate协议，然后实现我们需要的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">APPDelegate</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">UIApplicationDelegate</span>, <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>,</span><br><span class="line">                     <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="type">UIApplication</span>.<span class="params">LaunchOptionsKey</span> : <span class="keyword">Any</span>]<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;didFinishLaunchingWithOptions&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// SwiftUI中一些方法不能触发</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">applicationDidReceiveMemoryWarning</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;log-DidReceiveMemoryWarning&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">applicationDidBecomeActive</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;log-applicationDidBecomeActive&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">applicationDidEnterBackground</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;log-applicationDidEnterBackground&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现了代理方法后，我们还需要告诉SwiftUI在哪里增加我们的代理，在@main入口的struct中添加@UIApplicationDelegateAdaptor标记，SwiftUI会自动识别我们的代理类，并在合适的时机调用对应的代理方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SwiftUIDemoApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@UIApplicationDelegateAdaptor</span> <span class="keyword">private</span> <span class="keyword">var</span> appdelegate: <span class="type">APPDelegate</span></span><br><span class="line">    <span class="comment">//@UIApplicationDelegateAdaptor(APPDelegate.self) var appdelegate 这个写法也可以</span></span><br><span class="line">   <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较方便的是如果你的APPDelegate类遵循了ObservableObject协议，SwiftUI会自动把@UIApplicationDelegateAdaptor修饰的属性放到全局环境变量里去，例如这里我们并没有声明全局环境变量，但是在下层的View中依旧可以使用全局环境变量获取。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FeatureListHomeView</span>: <span class="title class_ inherited__">View</span> &#123;  </span><br><span class="line"> <span class="comment">// 这里去获取环境变量</span></span><br><span class="line"> <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> appdelegate: <span class="type">APPDelegate</span></span><br><span class="line"> <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">NavigationView</span> &#123;</span><br><span class="line">      <span class="operator">...</span></span><br><span class="line">    &#125;.onAppear &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我在App内部的view获取到了全局的appdelegate中的name属性<span class="subst">\(appdelegate.name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意一个问题，随着API的更新，有些代理方法不再由UIApplicationDelegate调用。</p>
<p>例如App前后台切换的代理，iOS13以前，由UIApplicationDelegate来控制生命周期，iOS13以后，由UISceneDelegate来控制生命周期。在iOS 13之后为了解决iPadOS展示多窗口的问题，用UIScene替代了之前UIWindow来管理视图。</p>
<p>iOS14以后Apple又给SwiftUI提供了更优雅的API来显示和控制Scene。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SwiftUIDemoApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Environment</span>(\.scenePhase) <span class="keyword">var</span> scenePhase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">      <span class="type">WindowGroup</span> &#123;</span><br><span class="line">          <span class="type">DemoHomeView</span>()</span><br><span class="line">      &#125;.onChange(of: scenePhase) &#123; newValue <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">switch</span> newValue &#123;</span><br><span class="line">          <span class="keyword">case</span> .active:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;active&quot;</span>)</span><br><span class="line">          <span class="keyword">case</span> .background:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;background&quot;</span>)</span><br><span class="line">          <span class="keyword">case</span> .inactive:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;inactive&quot;</span>)</span><br><span class="line">          <span class="keyword">@unknown</span> <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UIWindowSceneDelegate"><a href="#UIWindowSceneDelegate" class="headerlink" title="UIWindowSceneDelegate"></a>UIWindowSceneDelegate</h3><p>多窗口管理和App代理类似，平常用的较少。</p>
<p>如果使用了场景委托UIWindowSceneDelegate，也需要自行创建委托文件SceneDelegate。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SceneDelegate</span>: <span class="title class_ inherited__">NSObject</span>, <span class="title class_ inherited__">UIWindowSceneDelegate</span>, <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">windowScene</span>( <span class="keyword">_</span> <span class="params">windowScene</span>: <span class="type">UIWindowScene</span>,<span class="params">performActionFor</span> <span class="params">shortcutItem</span>: <span class="type">UIApplicationShortcutItem</span> ) <span class="keyword">async</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// Do something with the shortcut...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后直接在Appdelegate类中的方法中返回场景委托类即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">configurationForConnecting</span> <span class="params">connectingSceneSession</span>: <span class="type">UISceneSession</span>, <span class="params">options</span>: <span class="type">UIScene</span>.<span class="type">ConnectionOptions</span>) -&gt; <span class="type">UISceneConfiguration</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">UISceneConfiguration</span>(name: <span class="literal">nil</span>,sessionRole: connectingSceneSession.role)</span><br><span class="line">  <span class="keyword">if</span> connectingSceneSession.role <span class="operator">==</span> .windowApplication &#123;</span><br><span class="line">      configuration.delegateClass <span class="operator">=</span> <span class="type">SceneDelegate</span>.<span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> configuration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，如果你的SceneDelegate类遵循了ObservableObject协议，SwiftUI会自动把当前类型的属性放到环境环境变量里去。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode代码块云同步+本地安装脚本</title>
    <url>/2021/08/25/Xcode%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BA%91%E5%90%8C%E6%AD%A5+%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>今天整理了最近半年内使用频率高的一些代码，做了一些代码块 <code>codesnippet</code>使用，并在github上创建了一个私有仓库用来云端维护和同步，写了一个脚本进行代码块下载和合并。</p>
<p>创建方式：</p>
<ol>
<li><p>选中要创建的代码块，右键选择Create Code Snippte</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gtt9tybj9gj611y0q8djc02.jpg"></p>
</li>
<li><p>右上角 <code>+</code>框快速查看系统和自定义代码块</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gtt9ty5ejxj61gj0u043502.jpg"></p>
</li>
<li><p>填写代码块描述，以及快捷方式，修改代码块</p>
</li>
</ol>
<p><img src="https://cdn.zcx.info/008i3skNly1gtt9txvjapj61c50u00wu02.jpg"></p>
<p>xcode中用户自定义的 代码块保存在~&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;UserData&#x2F;CodeSnippets路径下，每个代码块都是一个.codesnippet格式的配置文件。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span><span class="title class_">Developer</span>/<span class="title class_">Xcode</span>/<span class="title class_">UserData</span>/<span class="title class_">CodeSnippets</span><span class="variable">$:</span> ls -l</span><br><span class="line">total <span class="number">72</span></span><br><span class="line">-rw-r--r--  <span class="number">1</span> zcx  staff  <span class="number">1008</span> <span class="title class_">Aug</span> <span class="number">25</span> <span class="number">19</span><span class="symbol">:</span><span class="number">36</span> 1BF011CF-<span class="number">9292</span>-4B72-9D44-<span class="variable constant_">F7C3BC89AFE0</span>.codesnippet</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zcx  staff  <span class="number">1036</span> <span class="title class_">Aug</span> <span class="number">25</span> <span class="number">16</span><span class="symbol">:</span><span class="number">03</span> 28DDA843-<span class="variable constant_">AD69</span>-4A09-87C4-3D1DB320EDB5.codesnippet</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zcx  staff   <span class="number">864</span> <span class="title class_">Aug</span> <span class="number">25</span> <span class="number">16</span><span class="symbol">:</span><span class="number">37</span> 8BEF45E5-0B98-4CC5-9CB8-86203CA29A69.codesnippet</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zcx  staff  <span class="number">1699</span> <span class="title class_">Aug</span> <span class="number">25</span> <span class="number">19</span><span class="symbol">:</span><span class="number">37</span> <span class="variable constant_">B42EC618</span>-1BF8-<span class="number">4E30</span>-<span class="variable constant_">AC73</span>-12E1282FEAFC.codesnippet</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zcx  staff   <span class="number">994</span> <span class="title class_">Aug</span> <span class="number">25</span> <span class="number">17</span><span class="symbol">:</span><span class="number">48</span> <span class="variable constant_">BA1B105B</span>-<span class="variable constant_">F02A</span>-<span class="number">4925</span>-<span class="variable constant_">A7FD</span>-<span class="variable constant_">B7E6081438E2</span>.codesnippet</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zcx  staff  <span class="number">1099</span> <span class="title class_">Aug</span> <span class="number">25</span> <span class="number">15</span><span class="symbol">:</span><span class="number">30</span> <span class="variable constant_">BB31C5F1</span>-<span class="variable constant_">D74A</span>-4CD4-968D-<span class="variable constant_">F707DADF07C1</span>.codesnippet</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zcx  staff  <span class="number">1144</span> <span class="title class_">Aug</span> <span class="number">25</span> <span class="number">17</span><span class="symbol">:</span><span class="number">48</span> <span class="variable constant_">DDA53283</span>-7F1F-49EC-9D76-87D876EA67FC.codesnippet</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zcx  staff  <span class="number">1557</span> <span class="title class_">Aug</span> <span class="number">25</span> <span class="number">17</span><span class="symbol">:</span><span class="number">48</span> <span class="variable constant_">E12D24FC</span>-<span class="number">2098</span>-413F-<span class="variable constant_">B12E</span>-<span class="variable constant_">CBB79181EBDA</span>.codesnippet</span><br><span class="line">-rw-r--r--  <span class="number">1</span> zcx  staff  <span class="number">1085</span> <span class="title class_">Aug</span> <span class="number">25</span> <span class="number">17</span><span class="symbol">:</span><span class="number">48</span> <span class="variable constant_">E7CFEE5D</span>-<span class="variable constant_">D2F0</span>-42D7-<span class="variable constant_">AD6E</span>-258BC0A67D75.codesnippet</span><br></pre></td></tr></table></figure>

<p>所以对个人的代码块的维护方式也显而易见变成了对此文件夹内的文件的维护。</p>
<hr>
<p><a href="https://github.com/zcx4u/XCode_CodeSnippet">创建私有库用来保存创建的代码块</a></p>
<p>每次下载过文件之后再手动批量向本地复制粘贴挺麻烦（主要是懒…）所以通过脚本命令进行合并再好不过了！</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># GitHub: https://github.com/zcx4u/XCode_CodeSnippet</span></span><br><span class="line"><span class="comment"># 将代码块到本地并安装到xcode</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">SRC_HOME</span>=<span class="string">`pwd`</span></span><br><span class="line">echo <span class="string">&quot;备份旧代码块~/Library/Developer/Xcode/UserData/CodeSnippets_Backup.zip&quot;</span></span><br><span class="line">cd ~<span class="regexp">/Library/</span><span class="title class_">Developer</span>/<span class="title class_">Xcode</span>/<span class="title class_">UserData</span></span><br><span class="line">zip -r <span class="title class_">CodeSnippets</span>_Backup.zip <span class="title class_">CodeSnippets</span></span><br><span class="line">echo <span class="string">&quot;合并代码块&quot;</span></span><br><span class="line">ditto -V <span class="variable">$&#123;</span><span class="variable constant_">SRC_HOME</span>&#125;/<span class="title class_">CodeSnippets</span> ~<span class="regexp">/Library/</span><span class="title class_">Developer</span>/<span class="title class_">Xcode</span>/<span class="title class_">UserData</span>/<span class="title class_">CodeSnippets</span></span><br><span class="line">echo <span class="string">&quot;done&quot;</span></span><br></pre></td></tr></table></figure>

<p> 记得先备份旧的文件夹以防不测😄</p>
<p>以前也零零碎碎的增加过代码块，但是换工作换电脑后就清空了，客户端业务变化较大重复性的编码还是比较多。</p>
<p>积累一些使用的顺手的工具和方法能有效提升效率，高效完成coding早点homing可以gaming还能shopping，岂不美哉！</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 一键唤起APP方案参考</title>
    <url>/2021/12/06/iOS%20Web%E5%94%A4%E8%B5%B7APP%E6%96%B9%E6%A1%88%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h2 id="iOS-一键唤起APP方案参考"><a href="#iOS-一键唤起APP方案参考" class="headerlink" title="iOS 一键唤起APP方案参考"></a>iOS 一键唤起APP方案参考</h2><p>移动端业务发展过程中，几乎每个公司都会有活动宣传或者运营引流的需求。这些需求的实现不外乎开发一些吸引人的HTML页面，在页面的某些事件的响应中引导用户下载APP或者打开已经下载的APP。</p>
<p>基本流程为：</p>
<ol>
<li><p>策划运营投放活动链接（新用户送红包或者PDD砍一刀）</p>
</li>
<li><p>用户点击活动链接进入活动页面</p>
</li>
<li><p>用户被吸引或诱导点击某个按钮触发事件</p>
</li>
<li><p>H5页面调起相关APP</p>
</li>
<li><p>APP响应调起并接力打开对应页面</p>
</li>
</ol>
<p>我们这里主要说一说4、5两步其中的细节处理，也是对最近相关的业务的一个总结。</p>
<h3 id="DeepLink技术"><a href="#DeepLink技术" class="headerlink" title="DeepLink技术"></a>DeepLink技术</h3><p>在<code>iOS9</code>之前只有通过<code>URL Scheme</code>能够唤起一个APP。</p>
<p><code>Scheme</code>可以理解为一个APP的名字，因为是<code>URL Scheme</code>所以遵循URL的书写格式，类比于<code>http://www.baidu.com</code>，其中<code>http</code>就是它的<code>Scheme</code>。</p>
<p>每个APP可以设置自己的Scheme，即给自己起个名字，方便”别人“叫我的时候我可以听得懂。</p>
<p>例如我们起了个<code>Scheme</code>叫<code>kr</code>，那么在H5页面内可以通过 <code>openURL()</code>的方式打开 <code>kr://testPage</code>链接调起我们的APP，当然如果你知道别人的<code>Scheme</code>就可以调起他的APP。</p>
<p>这个时候就需要H5和APP约定好连接的<code>path</code>和<code>parameter</code>，APP端根据调起的链接中的<code>Path</code>来确定要跳转的目的页，根据传参来获取需要的数据比如文章ID、用户ID等，然后根据参数加载原生页面。这样就完成了从H5到原生APP的接力跳转。</p>
<hr>
<h4 id="如何给自己的APP”起名”？"><a href="#如何给自己的APP”起名”？" class="headerlink" title="如何给自己的APP”起名”？"></a>如何给自己的APP”起名”？</h4><p>注册URL Scheme，即配置info.plist 文件</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gv92vcxu6jj60u206ewex02.jpg"></p>
<h4 id="如何响应被调用的跳转"><a href="#如何响应被调用的跳转" class="headerlink" title="如何响应被调用的跳转"></a>如何响应被调用的跳转</h4><p>检测到H5向自己发起了调用请求，我们需要对请求进行响应。在AppDelegate类中通过系统预留方法进行处理。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iOS9之前使用这个方法处理外部URL调用 </span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">handleOpen</span> <span class="params">url</span>: <span class="type">URL</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>iOS9之后使用这个方法处理外部URL调用，示例代码中展示了若干个可以调起APP的途径，根据具体的路径和参数来处理不同的逻辑。 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">app</span>: <span class="type">UIApplication</span>, <span class="params">open</span> <span class="params">url</span>: <span class="type">URL</span>, <span class="params">options</span>: [<span class="type">UIApplication</span>.<span class="params">OpenURLOptionsKey</span> : <span class="keyword">Any</span>]) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="comment">// 三方登录回调</span></span><br><span class="line">  <span class="keyword">if</span> <span class="type">LoginSettings</span>.handleOpenURL(url) <span class="operator">??</span> <span class="literal">false</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 神策SDK回调</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> sensor <span class="operator">=</span> <span class="type">SensorsAnalyticsSDK</span>.sharedInstance(), sensor.handleSchemeUrl(url) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// zfb支付回调</span></span><br><span class="line">  <span class="keyword">if</span> url.host <span class="operator">==</span> <span class="type">Constants</span>.<span class="type">KrOpenAppSource</span>.<span class="type">AliPayHost</span> &#123;</span><br><span class="line">      <span class="type">KrThirdPayManager</span>.default.processOrderWithZfbPaymentResult(url: url)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Today小组件点击</span></span><br><span class="line">  <span class="keyword">if</span> url.host <span class="operator">==</span> <span class="type">Constants</span>.<span class="type">KrOpenAppSource</span>.<span class="type">TodayExtensionHost</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> queryItems <span class="operator">=</span> url.queryItems, <span class="operator">!</span>queryItems.isEmpty &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> query <span class="operator">=</span> url.queryItems<span class="operator">?</span>.first &#123;</span><br><span class="line">              <span class="keyword">if</span> <span class="keyword">let</span> route <span class="operator">=</span> query.value, query.name <span class="operator">==</span> <span class="type">Constants</span>.<span class="type">KrOpenAppSource</span>.<span class="type">TodayExtensionQueryNews</span> &#123;</span><br><span class="line">                  <span class="type">Router2</span>.pushURL(route, <span class="type">TrackInfo</span>(source: <span class="type">TrackSource</span>.todayExtension))</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// widget小组件点击</span></span><br><span class="line">  <span class="keyword">if</span> url.host <span class="operator">==</span> <span class="type">Constants</span>.<span class="type">KrOpenAppSource</span>.<span class="type">WidgetExtensionHost</span> &#123;</span><br><span class="line">      <span class="type">Router2</span>.pushURL(urlStr, <span class="type">TrackInfo</span>(source: <span class="type">TrackSource</span>.widgetExtension))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// URL Scheme 唤起app</span></span><br><span class="line">  <span class="keyword">if</span> canAppHandleURL(url) &#123;</span><br><span class="line">      <span class="keyword">let</span> urlString <span class="operator">=</span> url.description</span><br><span class="line">      <span class="keyword">let</span> tempArray <span class="operator">=</span> urlString.components(separatedBy: <span class="string">&quot;route/&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span> <span class="operator">!</span>tempArray.isEmpty, tempArray.count <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> route <span class="operator">=</span> tempArray[<span class="number">1</span>]</span><br><span class="line">          <span class="type">Router2</span>.pushURL(route, <span class="type">TrackInfo</span>(source: <span class="type">TrackSource</span>.linkedMe))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// app store 唤起</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> sourceApp <span class="operator">=</span> options[<span class="type">UIApplication</span>.<span class="type">OpenURLOptionsKey</span>.sourceApplication] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">     sourceApp <span class="operator">==</span> <span class="type">Constants</span>.<span class="type">KrOpenAppSource</span>.<span class="type">AppStore</span> &#123;</span><br><span class="line">      <span class="type">TrackManager</span>.track(event: .appLaunch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理旧版微信通过URL启动App时传递的数据</span></span><br><span class="line">  <span class="keyword">if</span> url.scheme <span class="operator">==</span> <span class="type">ShareManager</span>.<span class="type">Wechat</span>.appID &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">WXApi</span>.handleOpen(url, delegate:<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DeepLink的局限性"><a href="#DeepLink的局限性" class="headerlink" title="DeepLink的局限性"></a>DeepLink的局限性</h4><h5 id="无法检测目标APP是否安装"><a href="#无法检测目标APP是否安装" class="headerlink" title="无法检测目标APP是否安装"></a>无法检测目标APP是否安装</h5><blockquote>
<p>我知道你叫什么就可以调起你，但是我不知道你在不在。</p>
</blockquote>
<p>H5无法获取APP是否已经安装过，所以大部分的处理方案是在发起调用APP的链接之后几秒直接跳转到对应APP的下载页面。</p>
<p>即如果能够调起APP，用户就不会再关注H5页面， H5页面跳到哪里用户也看不见。</p>
<p>反之就稍等一下跳转到APP的下载页面引导用户下载。</p>
<h5 id="Scheme冲突"><a href="#Scheme冲突" class="headerlink" title="Scheme冲突"></a>Scheme冲突</h5><blockquote>
<p>和你叫周杰伦我也叫周杰伦一样，大家都是周杰伦。</p>
<p>当周杰伦真正回应你的呼唤的时候你才知道你调起的是哪个周杰伦，真~薛定谔的周杰伦…</p>
</blockquote>
<p>由于每家的APP都自己注册自己的URL Scheme，所以有可能出现两家APP的URL Scheme注册的一样的情况。当两个APP都安装之后就会出现问题，不确定调起的是哪个APP。</p>
<h5 id="调起流程冗余且可能被阻断"><a href="#调起流程冗余且可能被阻断" class="headerlink" title="调起流程冗余且可能被阻断"></a>调起流程冗余且可能被阻断</h5><blockquote>
<p>将在xxx中打开页面，是否继续？</p>
</blockquote>
<p>由于是使用js方法openURL来调起的APP，在调起之前系统会询问你是否在xxxAPP中打开连接。</p>
<p>这个询问是一个比较突兀的alert弹窗，所以在不知情的用户看来可能会认为存在一定的风险从而取消打开导致唤起APP中断。如果在这里中断则用户极有可能会直接返回上一页或者直接取消整个操作，前功尽弃！</p>
<h3 id="UniversalLink技术"><a href="#UniversalLink技术" class="headerlink" title="UniversalLink技术"></a>UniversalLink技术</h3><blockquote>
<p>Seamlessly link to content inside your app, or on your website in iOS 9 or later. With universal links, you can always give users the most integrated mobile experience, even when your app isn’t installed on their device.</p>
<p>苹果开发文档</p>
</blockquote>
<p><code>UniversalLink </code>技术是苹果在<code>iOS9</code>之后推出的一种使用<code>HTTPS</code>协议的，可以方便得使用已经存在的链接同时打开网址和唤起APP的新功能。</p>
<p>相对于DeepLink技术来说，UniversalLink在使用体验上是类似的。明显区别在于用户点击了支持的通用链接后会直接调起APP，进入APP内部处理逻辑，而不会再弹起提示信息弹窗以达到从H5页面无缝衔接到APP内部的效果。（可能会在第一次使用UniversalLink时还会弹窗，但是授权之后就不再弹出了）</p>
<h4 id="UniversalLink的优点"><a href="#UniversalLink的优点" class="headerlink" title="UniversalLink的优点"></a>UniversalLink的优点</h4><p>但是相对于<code>DeepLink</code>技术，<code>UniversalLink</code>技术还具有着以下优点：</p>
<p><strong>唯一</strong>：与自定义<code>URL</code>方案不同，其他应用无法声明通用链接，因为通用链接使用的是指向您网站的标准<code>HTTP</code>或<code>HTTPS</code>链接</p>
<blockquote>
<ul>
<li><strong>Unique.</strong> Unlike custom URL schemes, universal links can’t be claimed by other apps, because they use standard HTTP or HTTPS links to your website.</li>
</ul>
</blockquote>
<p>每个APP控制自身可以支持的通用链接的域名，由于域名的注册和解析都具有唯一性，通用链支持的域名一定不会出现和别家APP重复的情况。</p>
<hr>
<p><strong>安全</strong>：当用户安装您的应用程序时，iOS会检查您已上传到Web服务器的文件，以确保您的网站允许您的应用程序代表其打开URL。只有您可以创建和上传此文件，因此您的网站与应用程序的关联是安全的。</p>
<blockquote>
<ul>
<li><strong>Secure.</strong> When users install your app, iOS checks a file that you’ve uploaded to your web server to make sure that your website allows your app to open URLs on its behalf. Only you can create and upload this file, so the association of your website with your app is secure.</li>
</ul>
</blockquote>
<p>通用链接的域名配置写在项目中且每个可以支持通用链的域名都需要上传一份提供判断是否满足通用链接对应的配置文件。</p>
<p>配置文件规定了支持通用链功能的域名后的path和可以调起的APP，比如配置文件中规定了<code>www.abc.com/app/UniversalLink/*</code>这个路径可以打开<code>abcAPP</code>，那么只有访问对应的链接才能调起对应的APP。</p>
<hr>
<p><strong>灵活</strong>：即使未安装您的应用程序，通用链接也可以使用。如果未安装您的应用程序，点击指向您网站的链接可在Safari中打开内容。</p>
<blockquote>
<ul>
<li><strong>Flexible.</strong> Universal links work even when your app is not installed. When your app isn’t installed, tapping a link to your website opens the content in Safari, as users expect.</li>
</ul>
</blockquote>
<p>不用管用户是否安装了对应的APP，如果没有安装对应的APP，用户点击的链接也是一个有效的页面地址，会在浏览器中继续打开所点击的链接呈现出对应的内容。</p>
<p>常规的做法是在某个通用链链接的地址上放APP的下载引导页，如果用户未安装APP而点击了通用链接就会直接跳转到下载页。</p>
<p>对于iOS用户来说这个下载页也可以尝试重定向到<code>App Store</code>的通用链接。<code>App Store</code>对每个APP的下载页面都提供了可用的通用链接，重定向到<code>App Store</code>通用链会直接调起应用商店且打开APP下载页。</p>
<hr>
<p><strong>简单</strong>：一个URL既适用于您的网站，也适用于您的应用程序。</p>
<blockquote>
<ul>
<li><strong>Simple.</strong> One URL works for both your website and your app.</li>
</ul>
</blockquote>
<p>一个正常使用的URL即可当做通用链功能进行配置，同时不影响其本身的页面和功能。</p>
<hr>
<p><strong>私有</strong>：其他应用程序可以与您的应用程序通信，而无需知道您的应用程序是否已安装。</p>
<blockquote>
<ul>
<li><strong>Private.</strong> Other apps can communicate with your app without needing to know whether your app is installed.</li>
</ul>
</blockquote>
<p>通用链可以暴露给别的应用程序使用，像打开普通的webview一样的方式调起APP，而不用关心你是否真正下载了APP。你的通用链的功能和设置对其他APP来说是透明的。</p>
<hr>
<p><strong>短信、备忘录、邮件内部均可使用</strong>：</p>
<blockquote>
<p>使用通用链的一大优势。</p>
</blockquote>
<p>在iOS系统自带的短信、备忘录甚至邮件内的网页链接的点击也可以正常调起APP，这样发送给用户的引流短信或者邮件中均可附带对应活动的链接，如果用户有安装我们的APP，在点击链接时可以直接导向到APP内部对应的活动页面，不再需要Safari做中间人角色。如果用户未安装APP则跳到对应的活动页面，然后重定向到App Store的下载页。</p>
<hr>
<h4 id="如何配置UniversalLink"><a href="#如何配置UniversalLink" class="headerlink" title="如何配置UniversalLink"></a>如何配置UniversalLink</h4><p>网上很多朋友都分享了他们配置UniversalLink的过程，但是我还是建议去苹果官网上按照最新的文档说明进行配置。</p>
<p><a href="https://developer.apple.com/documentation/xcode/supporting-associated-domains">Support Universal Links</a></p>
<blockquote>
<ul>
<li>Create an <code>apple-app-site-association</code> file that contains JSON data about the URLs that your app can handle.</li>
<li>Upload the <code>apple-app-site-association</code> file to your HTTPS web server. You can place the file at the root of your server or in the <code>.well-known</code> subdirectory.</li>
<li>Prepare your app to handle universal links.</li>
</ul>
</blockquote>
<p>大体上分为三个步骤:</p>
<ol>
<li><p>在xcode的Associated Domains配置项中添加你需要映射的链接</p>
<p>一般需要先去开发者账号的管理网站上为APP根证书开通这个功能，然后在XCode上进行域名配置。</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gvw7qzmkjdj30zn07lglw.jpg"></p>
</li>
<li><p>创建<code>apple-app-site-association</code>文件并编辑配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;applinks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;apps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;appID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9JA89QQLNQ.com.apple.wwdc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;/wwdc/news/&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/videos/wwdc/2015/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;appID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ABCD1234.com.apple.wwdc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;*&quot;</span> <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The <code>appIDs</code> and <code>apps</code> keys specify the application identifiers for the apps that are available for use on this website along with their service types. Use the following format for the values in these keys:</p>
<p><Application Identifier Prefix>.<Bundle Identifier></p>
<p>前缀使用APPId 可以在 App Store Connect网站上找到APP的id，后面是APP的Bundle ID，可以在Xcode签名管理的地方找</p>
</blockquote>
</li>
<li><p>将<code>apple-app-site-association</code>文件放在链接的域名服务根目录下</p>
<p>这个文件使用json格式但是并不能设置.json扩展名，仅仅作为纯文本文件放在对应链接域名下的根目录或者<code>.well-known</code>目录下，以方便系统访问到配置。</p>
<p>比如你关联的域名为 <a href="http://www.test.com/">www.test.com</a> ，就需要把<code>apple-app-site-association</code>文件放在服务器的根目录下，在浏览器访问</p>
<p><a href="https://www.test.com/apple-app-site-association">https://www.test.com/apple-app-site-association</a> 链接可以下载此文件或者直接打开此文件。</p>
</li>
</ol>
<h4 id="配置UniversalLink需要注意的问题"><a href="#配置UniversalLink需要注意的问题" class="headerlink" title="配置UniversalLink需要注意的问题"></a>配置UniversalLink需要注意的问题</h4><ol>
<li>配置<code>apple-app-site-association</code>的域名必须支持HTTPS，且访问的链接没有被重定向</li>
<li>每个被链接的域名下都要有自身的配置<code>apple-app-site-association</code>文件，<strong><code>www.test.com</code>和 <code>test.com</code> 不是同一个域名</strong>，如果需要每个域名都需要通用链接功能则需要每个域名下都配置一个对应的文件。<strong>如果这两个域名有重写规则且属于同一台服务器则会优先生效<code>www.test.com</code>而忽略<code>test.com</code></strong>。（虽然大部分公司都是将test.com重写为<a href="http://www.test.com,但是也有为了seo反向重写的例子)/">www.test.com，但是也有为了SEO反向重写的例子）</a></li>
<li>从 macOS 11 和 iOS 14 开始，应用程序不再直接向您的网络服务器请求<code>apple-app-site-association</code>文件。相反，他们将这些请求发送到专用于关联域的 Apple 管理的内容交付网络 (CDN)。所以在APP启动阶段不会抓到对应域名和路径的请求了。</li>
<li>第一次安装APP的时候苹果CDN服务会在24 小时内为您的域请求<code>apple-app-site-association</code>文件进行配置，非第一次安装时每周检查一次通用链配置更新。</li>
</ol>
<h3 id="特殊的微信环境"><a href="#特殊的微信环境" class="headerlink" title="特殊的微信环境"></a>特殊的微信环境</h3><p>鉴于国内的网络社交大环境基本以微信为中心，所以每个APP的引流都绕不开微信生态环境。</p>
<p>而微信属于应用层APP，并不能像操作系统一样开放，基于安全性考虑，微信针对Deeplink和UniversalLink均做了不同程度的屏蔽。</p>
<h4 id="安全域名回调"><a href="#安全域名回调" class="headerlink" title="安全域名回调"></a>安全域名回调</h4><p>在微信内部浏览器中是无法直接调起Deeplink的，一般通过微信分享出链接卡片，打开目的页面后再通过微信开放平台提供的安全域名功能来做Deeplink调用。</p>
<p>js调用安全域名下的DeepLink后会通过微信的onReq回调来接收请求，然后解析传递的数据进而做出页面跳转功能。</p>
<p>大体的逻辑如下</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gw4bj7l2lej31280u0411.jpg" alt="微信环境下使用DeepLink流程"></p>
<h4 id="通用链跳转"><a href="#通用链跳转" class="headerlink" title="通用链跳转"></a>通用链跳转</h4><p>而针对UniversalLink的屏蔽则表现为无法通过UniversalLink调起APP，只能打开对应的落地页。不过最近由于某些政策的调整，微信针对UniversalLink的屏蔽已经被放开了。目前可以正常在微信环境内使用通用链跳转功能（只要你要跳转的目的链接和当前链接是跨域的并且正确安装配置了对应的通用链的APP）。</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gw7uwunklrj31da0u0n07.jpg"></p>
<h4 id="屏蔽链接分享"><a href="#屏蔽链接分享" class="headerlink" title="屏蔽链接分享"></a>屏蔽链接分享</h4><p>鉴于对UniversalLink的放开，微信对某些竞争对手做出了限制链接分享的功能。比如某多多和某宝是无法使用微信卡片分享的，所以针对这种场景他们做出了分享文字到微信的功能，即发送常一大串带标识码的文本到微信，然后通过系统粘贴板作为中转到APP内（常见的“复制这段话到xxxAPP打开即可获得xxx红包”）。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不论是DeepLink技术 还是UniversalLink技术，都可以实现我们的需求。</p>
<p>在使用体验上来说还是UniversalLink技术更胜一筹。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>一键唤起</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-OCR实践</title>
    <url>/2021/08/31/iOS-OCR%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>近期老板提出了某些需求可能需要借助OCR能力来进行图片到文本的转换。</p>
<p>以下几种方案是对当前可用的免费的OCR的调研。</p>
<h2 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h2><blockquote>
<p>Vision 是 Apple 在 WWDC 2017 推出的图像识别框架，它基于 Core ML，所以可以理解成 Apple 的工程师设计了一种算法模型，然后利用 Core ML 训练，最后整合成一个新的框架，相比开源模型然后让开发者自己整合起来，这种方式更安全也更方便我们使用。</p>
</blockquote>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><blockquote>
<p>The Vision framework performs face and face landmark detection, text detection, barcode recognition, image registration, and general feature tracking. Vision also allows the use of custom Core ML models for tasks like classification or object detection.</p>
</blockquote>
<p>从官方文档中可以得到Vision框架能做的事情</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Face Detection and Recognition</td>
<td>面部检测</td>
</tr>
<tr>
<td align="left">Machine Learning Image Analysis</td>
<td>机器学习图像分析</td>
</tr>
<tr>
<td align="left">Barcode Detection</td>
<td>矩阵码&#x2F;条形码检测</td>
</tr>
<tr>
<td align="left">Image Alignment Analysis</td>
<td>图像对齐分析</td>
</tr>
<tr>
<td align="left">Text Detection</td>
<td>文字检测</td>
</tr>
<tr>
<td align="left">Horizon Detection</td>
<td>水平面检测</td>
</tr>
<tr>
<td align="left">Object Detection and Tracking</td>
<td>物体检测和追踪</td>
</tr>
</tbody></table>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>对于我们需要的OCR功能，Text Detection就可以满足我们的需求，至于别的功能有兴趣的可以试一下。</p>
<p>Demo中的代码也比较简单就实现了功能</p>
<ol>
<li>创建一个<code>VNImageRequestHandler</code>来持有传入的图片</li>
<li>创建一个<code>VNRecognizeTextRequest</code>请求&#x2F;请求队列</li>
<li>创建一个<code>VNRequestCompletionHandler</code>函数指针&#x2F;block处理识别成功的回调</li>
<li>Perform the text-recognition request. 执行请求</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public typealias VNRequestCompletionHandler = (VNRequest, Error?) -&gt; Void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 苹果原生识别 准确率高 速度快</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">ocrAction</span>() &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> path <span class="operator">=</span> <span class="keyword">self</span>.path, <span class="keyword">let</span> img <span class="operator">=</span> <span class="type">UIImage</span>(contentsOfFile: path) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> cgImage <span class="operator">=</span> img.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">// 需要注意的写法</span></span><br><span class="line">    <span class="keyword">let</span> requestHandler <span class="operator">=</span> <span class="type">VNImageRequestHandler</span>(cgImage: cgImage)</span><br><span class="line">    <span class="comment">// 参数是一个函数指针/block</span></span><br><span class="line">    <span class="keyword">let</span> request <span class="operator">=</span> <span class="type">VNRecognizeTextRequest</span>(completionHandler: recognizeTextHandler)</span><br><span class="line">    <span class="comment">// 只有ios14以上支持中文识别</span></span><br><span class="line">    request.recognitionLanguages <span class="operator">=</span> [<span class="string">&quot;zh-Hans&quot;</span>,<span class="string">&quot;zh-Hant&quot;</span>,<span class="string">&quot;en-US&quot;</span>]</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Perform the text-recognition request.</span></span><br><span class="line">        <span class="keyword">try</span> requestHandler.perform([request])</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Unable to perform the requests: <span class="subst">\(error)</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 识别成功的回调 </span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">recognizeTextHandler</span>(<span class="params">request</span>: <span class="type">VNRequest</span>, <span class="params">error</span>: <span class="type">Error</span>?) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> observations <span class="operator">=</span> request.results <span class="keyword">as?</span> [<span class="type">VNRecognizedTextObservation</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> recognizedStrings <span class="operator">=</span> observations.compactMap &#123; observation <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// Return the string of the top VNRecognizedText instance.</span></span><br><span class="line">        <span class="keyword">return</span> observation.topCandidates(<span class="number">1</span>).first<span class="operator">?</span>.string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Process the recognized strings.</span></span><br><span class="line"> 	 	<span class="keyword">var</span> res <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> str <span class="keyword">in</span> recognizedStrings &#123;</span><br><span class="line">        res  <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(res)</span><span class="subst">\(str)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    resultLabel.text <span class="operator">=</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>iOS系统内置的API，无需引入多余文件直接调用。</li>
<li>API使用比较简单，不用考虑多线程切换，成功回调已经全部回到了主线程。</li>
<li>实测识别准确度还是比较高的。</li>
</ol>
<p>缺点：</p>
<p>只有iOS14以上的系统版本支持设置识别中文。</p>
<p>可以使用这个方法来判断这个API所支持识别的语言。<code>request.recognitionLanguages</code>属性支持设置ISO标准语言代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     @brief Returns all the supported languages for a given text recognition level. Note that a language supported in one recognition level might not be available in another.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">class</span> <span class="keyword">func</span> <span class="title function_">supportedRecognitionLanguages</span>(<span class="keyword">for</span> recognitionLevel: <span class="type">VNRequestTextRecognitionLevel</span>, revision requestRevision: <span class="type">Int</span>) <span class="keyword">throws</span> -&gt; [<span class="type">String</span>]</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.apple.com/documentation/vision/recognizing_text_in_images">更多Vision识别文字相关文档可参考：Recognizing Text in Images</a></p>
<h2 id="Tesseract"><a href="#Tesseract" class="headerlink" title="Tesseract"></a>Tesseract</h2><blockquote>
<p>Tesseract 是一个 OCR 库,目前由 Google 赞助(Google 也是一家以 OCR 和机器学习技术闻名于世的公司)。Tesseract 是目前公认最优秀、最精确的开源 OCR 系统，除了极高的精确度，Tesseract 也具有很高的灵活性。它可以通过训练识别出任何字体，也可以识别出任何 Unicode 字符。Tesseract OCR 该软件包包含一个 OCR 引擎 – libtesseract 和一个命令行程序 – tesseract。 Tesseract 4 增加了一个基于 OCR 引擎的新神经网络（LSTM），该引擎专注于线路识别，但仍然支持 Tesseract 3 的传统 Tesseract OCR 引擎，该引擎通过识别字符模式来工作。通过使用 Legacy OCR Engine 模式（–oem 0）启用与 Tesseract 3 的兼容性。它还需要训练有素的数据文件，这些文件支持传统引擎，例如来自 tessdata 存储库的文件。</p>
<p><a href="https://github.com/tesseract-ocr/tesseract">GitHub Address</a></p>
</blockquote>
<h3 id="Tesseract-OCR-iOS"><a href="#Tesseract-OCR-iOS" class="headerlink" title="Tesseract-OCR-iOS"></a>Tesseract-OCR-iOS</h3><blockquote>
<p>Tesseract-OCR-iOS 是由<code>gali8</code>使用<code>Objective-C</code>封装的基于<code>Tesseract 3.03-rc1</code>的iOS版本库。<br><a href="https://github.com/gali8/Tesseract-OCR-iOS">GitHub Address</a></p>
</blockquote>
<h3 id="Useage"><a href="#Useage" class="headerlink" title="Useage"></a>Useage</h3><ol>
<li>通过<code>cocopods</code>可以直接引入此库。</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PodFile</span></span><br><span class="line">pod <span class="string">&#x27;TesseractOCRiOS&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>桌面创建一个<code>tessdata</code>文件夹</p>
</li>
<li><p>将训练好的中文语言文字数据集<code>chi_sim.traineddata</code>放入<code>tessdata</code>文件夹</p>
</li>
<li><p>将tessdata文件夹拖到项目根目录，<code>Added folders</code> 选择 <code>Create folder references</code>创建索引关系</p>
<blockquote>
<p>之所以创建索引，是因为Tesseract内部是使用静态路径访问的语言资源文件</p>
</blockquote>
</li>
<li><p>使用中文语言创建<code>G8Tesseract</code></p>
</li>
<li><p>设置<code>G8Tesseract</code>需要识别的<code>image</code></p>
</li>
<li><p>调用<code>recognize()</code>方法，同步方法，会阻塞进程</p>
</li>
<li><p>读取<code>recognizedText</code>属性字段</p>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// google Tesseract识别</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">ocrActionTesseract</span>() &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> path <span class="operator">=</span> <span class="keyword">self</span>.path, <span class="keyword">let</span> img <span class="operator">=</span> <span class="type">UIImage</span>(contentsOfFile: path) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> g8Rec <span class="operator">=</span> <span class="type">G8Tesseract</span>(language: <span class="string">&quot;chi_sim&quot;</span>)</span><br><span class="line">    g8Rec<span class="operator">?</span>.image <span class="operator">=</span> img</span><br><span class="line">    g8Rec<span class="operator">?</span>.engineMode <span class="operator">=</span> .tesseractOnly</span><br><span class="line">    g8Rec<span class="operator">?</span>.pageSegmentationMode <span class="operator">=</span> .autoOnly</span><br><span class="line">    g8Rec<span class="operator">?</span>.recognize()</span><br><span class="line">    resultLabel.text <span class="operator">=</span> g8Rec<span class="operator">?</span>.recognizedText</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集成过程中可能遇到的问题：</p>
<ol>
<li><p><code>actual_tessdata_num_entries_ &lt;= TESSDATA_NUM_ENTRIES:Error: Assert failed: in file ..\..\ccutil\tes...</code></p>
<p>原因：训练数据和sdk版本号不一致<br>解决方法：去 <a href="https://github.com/tesseract-ocr/tessdoc/blob/master/tess3/Data-Files.md#data-files-for-version-302">v3.0.2版本训练数据</a>下载对应版本的训练数据</p>
</li>
<li><p><code>setenv(&quot;TESSDATA_PREFIX&quot;, [_absoluteDataPath stringByAppendingString:@&quot;/&quot;].fileSystemRepresentation, 1);</code> 处崩溃</p>
<p>原因：未知，可能是代码BUG<br>解决方法：不使用作者提供的SwiftDemo中的<code>OperationQueue</code>直接使用<code>G8Tesseract</code>类</p>
</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>Tesseract 可以支持自定义训练数据，可以根据自身的需求进行数据训练。可以实现手写字体或其他不规则字体的识别。</li>
<li>识别准确率参照训练结果，在大量业务数据的支持下可能会达到较高的准确率。</li>
<li>无iOS系统版本要求，或基本满足低版本要求</li>
</ol>
<p>缺点：</p>
<ol>
<li><code>Tesseract-OCR-iOS</code> 库不再维护和更新，代码BUG无人解决，<code>Tesseract</code>版本依旧停留在3.0版本，限制使用3.0版本的训练数据集。若不自行训练，低版本训练数据比较难找。自行fork进行二次开发学习成本较高。</li>
<li><code>Tesseract-OCR-iOS</code>库自行测试结果对简体中文的识别准确率稍低，可能是因为<code>Tesseract</code>版本过低。</li>
<li>引入此三方库的成本过高，基本的简体中文训练数据集大小就为40+MB，引入工程内会显著增加IPA包体积大小，影响APP下载和分发</li>
</ol>
<h2 id="OnLine-OCR"><a href="#OnLine-OCR" class="headerlink" title="OnLine OCR"></a>OnLine OCR</h2><p>服务商较多，也有免费试用版，可衡量业务与需求选择。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果OCR不是App的核心功能还是尽量选择<code>Vision</code>，<code>Apple</code>马上要更新<code>iOS15</code>版本，随着时间发展<code>iOS14</code>以上的用户数量会越来越多，相信系统版本限制不会永远是APP功能发展的瓶颈。</p>
<p>如果OCR是APP的核心功能或业务相关，建议自行对最新的<code>Tesseract</code> 进行c++接口封装或者对<code>Tesseract-OCR-iOS</code>库二次开发更新版本并进行维护。</p>
<p>或者选择使用收费在线业务，大部分场景下花钱都能解决技术问题。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>技术调研</tag>
      </tags>
  </entry>
  <entry>
    <title>__block 关键字探究</title>
    <url>/2020/09/23/block/</url>
    <content><![CDATA[<h3 id="block-是干什么用的"><a href="#block-是干什么用的" class="headerlink" title="__block 是干什么用的"></a>__block 是干什么用的</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int val = 10;   </span><br><span class="line">MyBlock block = ^&#123;</span><br><span class="line">    NSLog(@&quot;val = %d&quot;,val);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">//输出</span><br><span class="line">2020-09-22 14:24:47.018497+0800 MyDemo[2987:2658512] val = 10</span><br></pre></td></tr></table></figure>

<p>从一段简单的<code>code</code>说起，在<code>block</code>中修改val的值该怎么办呢？</p>
<p>直接在<code>block</code>中修改会报编译错误<code>Variable is not assignable (missing __block type specifier)</code> </p>
<p>显而易见我们只需要在<code>val</code>变量前加<code>__block</code>关键字即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__block int val = 10;</span><br><span class="line">MyBlock block = ^&#123;</span><br><span class="line">    val += 10;</span><br><span class="line">    NSLog(@&quot;val = %d&quot;,val);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">//输出</span><br><span class="line">2020-09-22 14:29:38.065700+0800 MyDemo[2991:2660066] val = 20</span><br></pre></td></tr></table></figure>

<p>现在我们简单的在<code>block</code>中修改了<code>val</code>的值。</p>
<h3 id="block-原理思考推测"><a href="#block-原理思考推测" class="headerlink" title="__block 原理思考推测"></a>__block 原理思考推测</h3><p>so why？现在到了探究其所以然的时候了。</p>
<p>由于<code>objc</code>封装的较深，我们可以把<code>objc</code>代码转换成<code>c++</code>代码一探究竟</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</span><br></pre></td></tr></table></figure>

<p>在<code>main.m</code>文件夹内执行这条命令生成一个<code>main.cpp</code>的<code>c++</code>类</p>
<p>在<code>xcode</code>中打开,在该类中搜索<code>main</code>方法.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这个时候使用的是这些code</span></span><br><span class="line"><span class="comment">int val = 10;   </span></span><br><span class="line"><span class="comment">MyBlock block = ^&#123;</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;val = %d&quot;,val);</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">block();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>(((<span class="built_in">Class</span> (*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;AppDelegate&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>)));</span><br><span class="line">				<span class="comment">// 我们声明的auto变量</span></span><br><span class="line">        <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 我们声明的block        </span></span><br><span class="line">        MyBlock block = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, val));</span><br><span class="line">				<span class="comment">// block的调用</span></span><br><span class="line">        ((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, __null, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>__main_block_impl_0</code>这个东西，是我们创建的<code>block</code>在<code>c++</code>里面的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*MyBlock)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="type">int</span> val; <span class="comment">// 这个地方看到block内部有生成一个对象来保存我们创建的val来使用</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _val, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">val</span>(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的<code>__block_impl</code>是block数据结构在c++的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa; <span class="comment">// 由此可见block在底层也是一种objc对象</span></span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr; <span class="comment">// block里保存的函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们还能找到我们的<code>NSLog</code>方法<code>__main_block_func_0</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="type">int</span> val = __cself-&gt;val; <span class="comment">// 从自身的结构体中取出val对象来使用</span></span><br><span class="line">	<span class="built_in">NSLog</span>((NSString*)&amp;__NSConstantStringImpl__var_folders_j2__3l5gw_93rz1_jfmq7r7wwph0000gn_T_main_18d90f_mi_0,</span><br><span class="line">      val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从而知道了<code>block</code>会捕获<code>auto</code>类型的变量到自身的结构体，这时候会生成一个新变量<code>val</code>来使用。</p>
<p>虽然捕获到了变量，但是此变量非彼变量，我们并不能在这里修改外部的值。</p>
<p>回想我们遇见的各种类型的<code>block</code>我们发现声明为<code>static</code>的变量不需要加<code>__block</code>就可以直接修改值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int staticVal = 10;        </span><br><span class="line">MyBlock block = ^&#123;</span><br><span class="line">    staticVal += 10;</span><br><span class="line">    NSLog(@&quot;staticVal = %d&quot;,staticVal);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">//输出</span><br><span class="line">2020-09-22 14:41:08.103780+0800 MyDemo[3004:2662839] staticVal = 20</span><br></pre></td></tr></table></figure>

<p>那么<code>static</code>的变量是怎么实现的呢？相应的我们可以看看他在<code>block</code>结构体里面到底是怎么做的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="type">int</span> *staticVal; <span class="comment">// 由此可以看到block拿到了staticVal的指针</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> *_staticVal, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">staticVal</span>(_staticVal) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// block封装的方法</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="type">int</span> *staticVal = __cself-&gt;staticVal; <span class="comment">// bound by copy</span></span><br><span class="line">	(*staticVal) += <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_j2__3l5gw_93rz1_jfmq7r7wwph0000gn_T_main_68799d_mi_0,(*staticVal));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到了指针就是拿到了他,原来<code>static</code>类型的变量是这么做的，仔细想想明白反正他会一直存在内存中，只要拿到了他的指针就可以在任意时间访问他而不用担心野指针的问题啦。</p>
<p>那么只要我们想办法能在<code>block</code>里面访问<code>auto变量</code>的<code>指针</code>同时保证这个变量不会被<code>释放</code>是不是就能在<code>block</code>里面修改变量了呢？</p>
<h3 id="block-底层实现验证"><a href="#block-底层实现验证" class="headerlink" title="__block 底层实现验证"></a>__block 底层实现验证</h3><p>现在我们看一下<code>__block</code>的<code>c++</code>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// 我们发现这里增加了一个__Block_byref_val_0 的结构体 并命名为val</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">val</span>(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// block封装的方法</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line">  (val-&gt;__forwarding-&gt;val) += <span class="number">10</span>;<span class="comment">// 使用val的__forwarding指针来拿val结构体中的val对象进行赋值</span></span><br><span class="line">  <span class="built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_j2__3l5gw_93rz1_jfmq7r7wwph0000gn_T_main_00193b_mi_0,  	(val-&gt;__forwarding-&gt;val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>__Block_byref_val_0</code>可以找到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*MyBlock)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_val_0</span> &#123;</span><br><span class="line"> <span class="type">void</span> *__isa;</span><br><span class="line"> __Block_byref_val_0 *__forwarding; <span class="comment">// 这个指针指向了自身</span></span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到block使用了一个对象<code>__Block_byref_val_0</code>把<code>val</code>对象包住之后进行使用。</p>
<p>但是这个对象里面的val到底是不是我们定义的那个呢？</p>
<p>这里可以把<code>c++</code>的结构体拷贝到<code>objc</code>中进行一次转换就能拿到这个对象了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__Block_byref_val_0</span> &#123;</span><br><span class="line"> <span class="type">void</span> *__isa; </span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">__Block_byref_val_0</span> *__forwarding; </span><br><span class="line"> <span class="type">int</span> __flags; </span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="type">int</span> val; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in">void</span> (*copy)(<span class="type">void</span>);</span><br><span class="line">  <span class="built_in">void</span> (*dispose)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__Block_byref_val_0</span> *val; <span class="comment">// by ref</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__block <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">MyBlock block = ^&#123;</span><br><span class="line">    val += <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;val = %d&quot;</span>,val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">block</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> * blockImpl = (__bridge <span class="keyword">struct</span> __main_block_impl_0 *) block; <span class="comment">//这里做一个桥接（对象转换）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;val = %p&quot;</span>,&amp;val);</span><br></pre></td></tr></table></figure>

<p>然后我们在<code>debug</code>的断点进来的时候去找<code>blockImpl</code>中val对象的地址,再对比打印出来的<code>val</code>的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-09-22 16:57:00.771793+0800 MyDemo[3028:2688246] val = 20</span><br><span class="line">(lldb) p/x &amp;(blockImpl-&gt;val-&gt;val)</span><br><span class="line">(int *) $0 = 0x00000002811c36f8</span><br><span class="line">2020-09-22 16:57:05.581925+0800 MyDemo[3028:2688246] val = 0x2811c36f8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>__main_block_impl_0</code>对象中的<code>val</code>对象的<code>val</code>字段的地址和我们定义的<code>val</code>的地址相同。</p>
<p>至此,我们明白了__block是如何运作的。</p>
<h3 id="block是如何保证auto变量不被释放的"><a href="#block是如何保证auto变量不被释放的" class="headerlink" title="__block是如何保证auto变量不被释放的"></a>__block是如何保证auto变量不被释放的</h3><p>从上面来看 我们已经能在block内部拿到auto变量的地址了，那么只要能保证block生命周期中这个变量不会被释放掉就可以实现在block中修改他的值了！看起来离我们的目标不远了。</p>
<p>再把目光投向main.cpp文件,我们可以发现三个方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="type">void</span>*)&amp;dst-&gt;val, (<span class="type">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="type">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">  <span class="built_in">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*); </span><br><span class="line">  <span class="built_in">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ARC环境下,系统会自动帮我们把在栈中的访问<code>auto</code>变量的<code>block</code>给<code>copy</code>到堆上去。</p>
<p>在执行<code>copy</code>方法的时候<code>block</code>会执行 <code>__main_block_copy_ </code>方法对<code>__main_block_impl_</code>对象进行一次强引用。该方法中执行了<code>_Block_object_assign</code>对包裹<code>val</code>的对象进行<code>retain</code>操作,这里恍然大悟,明白为什么<code>block</code>容易导致<code>循环引用</code>和<code>内存泄漏</code>了。</p>
<p>对应的,在<code>block</code>将要释放的时候执行<code>__main_block_dispose_</code>方法来释放<code>__main_block_impl_</code>对象。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><code>__forwarding</code>指针为什么会指向自己,指向自身的指针是否多余呢？</p>
<p>反过来看，如果在block外部修改掉<code>__block</code>修饰的变量的值时<code>block</code>内部的<code>__Block_byref_val_0</code>的<code>val</code>值会跟随改变吗？会改变的话又是怎么实现的呢？</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-i18n动态化思考</title>
    <url>/2025/03/27/iOS-i18n%E5%8A%A8%E6%80%81%E5%8C%96%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="一、项目背景"><a href="#一、项目背景" class="headerlink" title="一、项目背景"></a>一、项目背景</h2><p>在全球化业务快速发展的背景下，我们的教育类应用需要支持18+语言、覆盖100+国家地区的本地化需求。</p>
<h2 id="二、现状分析"><a href="#二、现状分析" class="headerlink" title="二、现状分析"></a>二、现状分析</h2><p>目前iOS端在基于系统级的.String文件支持多语能力的基础上又增加了一层动态Json多语。</p>
<p>为了获取动态修复多语的能力，我们额外实现了一套动态拉取多个scope下的18种语言json的功能。支持server、本地文件、内存三级缓存。</p>
<p>在根据多语key提取文本时会先到动态多语模块去查询，如果查不到目标字符串则会回退到系统NSLocalizedString获取文本。</p>
<p>主要实现特点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 内存管理核心逻辑</span><br><span class="line">- (NSDictionary *)getCurrentLanguagesData &#123;</span><br><span class="line">    NSMutableDictionary *stableLanguages = [NSMutableDictionary dictionary];</span><br><span class="line">    [self.subScopes enumerateObjects...]; // 全量合并多语数据</span><br><span class="line">    return stableLanguages; // 产生内存峰值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现存问题 ：</p>
<p>i18n模块在设计阶段为了获取动态化能力投入了较多的资源。但是后期在应用阶段发现其动态化能力并未带来很大的收益。并且在经历了大批量的本地多语修改需求后发现在这种场景下需要考虑双倍的更新成本。</p>
<p>一个版本的APP发布后其内部使用的多语K-V也基本固定，所谓的动态化的能力仅仅是为了支持动态下发多语做热更新。在长时间的迭代和实践中发现多语热更新的次数较少，对文本翻译的调整的优先级也不高，可以接受发版更新。</p>
<p>由于支持热更新，我们在开发阶段对多语翻译的准入标准也逐渐劣化，甚至出现了一个版本发布前不做多语走查直接上线依赖动态能力再热修的情况。</p>
<p>而且随着下发的json逐渐增大，APP的启动周期内加载动态多语的开销也逐渐增大，目前纯json数据已经有5mb左右，全量加载到内存中需要消耗的内存会更多。所以这里考虑将内存加载Json替换为系统级的使用Bundle获取数据以减轻内存压力。</p>
<h2 id="三、技术方案对比"><a href="#三、技术方案对比" class="headerlink" title="三、技术方案对比"></a>三、技术方案对比</h2><h3 id="1-内存JSON方案"><a href="#1-内存JSON方案" class="headerlink" title="1. 内存JSON方案"></a>1. 内存JSON方案</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当前实现方式</span><br><span class="line">- (void)syncSubscopesWithHashId:(NSString *)hashId </span><br><span class="line">                      timestamp:(NSString *)timestamp</span><br><span class="line">                         config:(UGI18NConfigModel *)i18nConfig &#123;</span><br><span class="line">    // 内存合并逻辑...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优势 ：热更新即时生效 劣势 ：内存占用高，无法利用系统优化</p>
<h3 id="2-动态Bundle方案"><a href="#2-动态Bundle方案" class="headerlink" title="2. 动态Bundle方案"></a>2. 动态Bundle方案</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 新增动态Bundle支持</span><br><span class="line">@property (nonatomic, strong) NSMutableArray&lt;NSBundle *&gt; *dynamicBundles;</span><br><span class="line"></span><br><span class="line">- (NSString *)localizedStringForKey:(NSString *)key &#123;</span><br><span class="line">    for (NSBundle *bundle in _dynamicBundles) &#123;</span><br><span class="line">        NSString *value = [bundle localizedStringForKey:key value:nil table:nil];</span><br><span class="line">        if (value) return value;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super localizedStringForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优势 ：</p>
<ul>
<li>系统级内存管理</li>
<li>支持模块化更新</li>
<li>无缝兼容Xcode</li>
</ul>
<h2 id="四、动态Bundle方案设计"><a href="#四、动态Bundle方案设计" class="headerlink" title="四、动态Bundle方案设计"></a>四、动态Bundle方案设计</h2><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><ul>
<li>动态bundle代替内存json缓存</li>
<li>系统bundle做静态兜底</li>
<li>业务模块无感直接调用</li>
</ul>
<h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><p><strong>1. 动态加载器（UGI18NScope扩展）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 动态Bundle管理</span><br><span class="line">- (void)loadDynamicBundles &#123;</span><br><span class="line">    NSString *path = [NSSearchPath...];</span><br><span class="line">    NSArray *langDirs = [fm contentsOfDirectoryAtPath:path];</span><br><span class="line">  </span><br><span class="line">    for (NSString *dir in langDirs) &#123;</span><br><span class="line">        if ([dir.pathExtension isEqualToString:@&quot;lproj&quot;]) &#123;</span><br><span class="line">            NSBundle *bundle = [NSBundle bundleWithPath:...];</span><br><span class="line">            [_dynamicBundles addObject:bundle];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 读写分离机制</strong></p>
<ul>
<li>读路径：MainBundle → DynamicBundles 链式查询</li>
<li>写路径：Python脚本生成标准.lproj结构</li>
</ul>
<ol start="3">
<li>更新流程</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SSZipArchive unzipFileAtPath:zipPath toDestination:cacheDir];</span><br><span class="line">[[UGI18NScope sharedInstance] loadDynamicBundles];</span><br></pre></td></tr></table></figure>

<h2 id="五、性能优化"><a href="#五、性能优化" class="headerlink" title="五、性能优化"></a>五、性能优化</h2><h3 id="1-内存优化对比"><a href="#1-内存优化对比" class="headerlink" title="1. 内存优化对比"></a>1. 内存优化对比</h3><table>
<thead>
<tr>
<th>方案</th>
<th>启动内存</th>
<th>语言切换耗时</th>
<th>峰值内存</th>
</tr>
</thead>
<tbody><tr>
<td>内存Json</td>
<td>82MB</td>
<td>420ms</td>
<td>105MB</td>
</tr>
<tr>
<td>动态Bundle</td>
<td>35MB</td>
<td>150ms</td>
<td>60MB</td>
</tr>
</tbody></table>
<h3 id="2-懒加载机制"><a href="#2-懒加载机制" class="headerlink" title="2. 懒加载机制"></a>2. 懒加载机制</h3><p>系统通过NSBundle的NSCache实现：</p>
<ul>
<li>首次访问字符串时加载对应语言文件</li>
<li>内存压力时自动释放未使用资源</li>
<li>相同key自动复用缓存</li>
</ul>
<h2 id="六、未来展望"><a href="#六、未来展望" class="headerlink" title="六、未来展望"></a>六、未来展望</h2><h3 id="1-架构演进方向"><a href="#1-架构演进方向" class="headerlink" title="1. 架构演进方向"></a>1. 架构演进方向</h3><ul>
<li><strong>智能化加载策略</strong> ：基于用户行为预测的预加载机制</li>
<li><strong>云端协同方案</strong> ：CDN分发+差分更新（Delta Update）</li>
<li><strong>AR国际化支持</strong> ：动态加载3D模型的多语资源</li>
</ul>
<h3 id="2-工具链建设"><a href="#2-工具链建设" class="headerlink" title="2. 工具链建设"></a>2. 工具链建设</h3><ul>
<li><strong>自动化测试工具</strong> ：多语覆盖率检测</li>
<li><strong>可视化监控平台</strong> ：实时查看各语言模块加载状态</li>
</ul>
<h3 id="3-跨平台扩展"><a href="#3-跨平台扩展" class="headerlink" title="3. 跨平台扩展"></a>3. 跨平台扩展</h3><ul>
<li><strong>Flutter混合方案</strong> ：通过MethodChannel共享Bundle资源</li>
<li><strong>React Native适配</strong> ：构建JS-Native的字符串映射桥接</li>
</ul>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>我们的重心应该由支持多语的动态化转为提升多语翻译的准入标准，弱化热更新能力，尽量不依赖热更新来做一个不规范的操作。</p>
<p>未来将持续优化多语资源的加载效率，构建覆盖全平台的国际化解决方案，为全球1.2亿用户提供更流畅的本地化体验</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>i18n</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS Crash类型总结</title>
    <url>/2025/03/12/iOSCrash%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="iOS-Crash类型总结"><a href="#iOS-Crash类型总结" class="headerlink" title="iOS Crash类型总结"></a>iOS Crash类型总结</h1><p>iOS APP系统crash主要分两类：一类是Objective-C Exception，一类是Unix Signal Exception。下面详细介绍。</p>
<blockquote>
<p>崩溃日志路径：~&#x2F;Library&#x2F;Logs&#x2F;CrashReporter&#x2F;MobileDevice</p>
</blockquote>
<h2 id="一、Objective-C-Exception"><a href="#一、Objective-C-Exception" class="headerlink" title="一、Objective-C Exception"></a>一、Objective-C Exception</h2><p>例如NSDictionary加入nil、数组访问越界等。主要有如下类型：</p>
<h3 id="1-NSInvalidArgumentException"><a href="#1-NSInvalidArgumentException" class="headerlink" title="1. NSInvalidArgumentException"></a>1. NSInvalidArgumentException</h3><p>非法参数异常(NSInvalidArgumentException)是Objective-C代码最常出现的错误。平时在写代码时需要多加注意，加强对参数的检查，避免传入非法参数导致异常，其中尤以nil参数为甚。</p>
<p>主要场景包括：</p>
<h4 id="1-1-集合数据的参数传递"><a href="#1-1-集合数据的参数传递" class="headerlink" title="1.1 集合数据的参数传递"></a>1.1 集合数据的参数传递</h4><p>比如NSMutableArray、NSMutableDictionary的数据操作：</p>
<ul>
<li>NSDictionary不能删除nil的key</li>
<li>NSDictionary不能添加nil的对象</li>
<li>不能插入nil的对象</li>
<li>其他一些nil参数</li>
</ul>
<h4 id="1-2-其他API的使用"><a href="#1-2-其他API的使用" class="headerlink" title="1.2 其他API的使用"></a>1.2 其他API的使用</h4><p>APP一般都会有网络操作，免不了使用网络相关接口，比如NSURL的初始化，不能传入nil的http地址。</p>
<h4 id="1-3-未实现的方法"><a href="#1-3-未实现的方法" class="headerlink" title="1.3 未实现的方法"></a>1.3 未实现的方法</h4><ul>
<li>.h文件里函数名，却忘了修改.m文件里对应的函数名</li>
<li>使用第三方库时，没有添加”-ObjC” flag</li>
<li>MRC时，大部分情况下是因为对象被提前release了，在你心里不希望他release的情况下，指针还在，对象已经不在了</li>
</ul>
<h3 id="2-NSRangeException"><a href="#2-NSRangeException" class="headerlink" title="2. NSRangeException"></a>2. NSRangeException</h3><p>越界异常(NSRangeException)也是比较常出现的异常，有如下几种类型：</p>
<ol>
<li>数组最大下标处理错误<ul>
<li>比如数组长度count，index的下标范围[0, count-1]，在开发时，可能index的最大值超过数组的范围</li>
</ul>
</li>
<li>下标的值是其他变量赋值<ul>
<li>这样会有很大的不确定性，可能是一个很大的整数值</li>
</ul>
</li>
<li>使用空数组<ul>
<li>如果一个数组刚刚初始化，还是空的，就对它进行相关操作</li>
</ul>
</li>
</ol>
<blockquote>
<p>为了避免NSRangeException的发生，必须对传入的index参数进行合法性检查，是否在集合数据的个数范围内。</p>
</blockquote>
<h3 id="3-NSGenericException"><a href="#3-NSGenericException" class="headerlink" title="3. NSGenericException"></a>3. NSGenericException</h3><p>NSGenericException这个异常最容易出现在foreach操作中。在for-in循环中如果修改所遍历的数组，无论你是add或remove，都会出错。”for-in”的内部遍历使用了类似Iterator进行迭代遍历，一旦元素变动，之前的元素全部被失效。</p>
<blockquote>
<p>在foreach的循环当中，最好不要去进行元素的修改动作，若需要修改，循环改为for遍历，由于内部机制不同，不会产生修改后结果失效的问题。</p>
</blockquote>
<h3 id="4-NSInternalInconsistencyException"><a href="#4-NSInternalInconsistencyException" class="headerlink" title="4. NSInternalInconsistencyException"></a>4. NSInternalInconsistencyException</h3><p>不一致导致出现的异常，例如：</p>
<ul>
<li>NSDictionary当做NSMutableDictionary来使用，从他们内部的机理来说，就会产生一些错误</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *info = method <span class="keyword">return</span> to <span class="built_in">NSDictionary</span> type;</span><br><span class="line">[info setObject:<span class="string">@&quot;sxm&quot;</span> forKey:<span class="string">@&quot;name&quot;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>xib界面使用或者约束设置不当</li>
</ul>
<h3 id="5-NSFileHandleOperationException"><a href="#5-NSFileHandleOperationException" class="headerlink" title="5. NSFileHandleOperationException"></a>5. NSFileHandleOperationException</h3><p>处理文件时的一些异常，最常见的还是存储空间不足的问题，比如应用频繁的保存文档，缓存资料或者处理比较大的数据。</p>
<blockquote>
<p>在文件处理里，需要考虑到手机存储空间的问题。</p>
</blockquote>
<h3 id="6-NSMallocException"><a href="#6-NSMallocException" class="headerlink" title="6. NSMallocException"></a>6. NSMallocException</h3><p>这也是内存不足的问题，无法分配足够的内存空间。</p>
<h3 id="7-其他常见Crash"><a href="#7-其他常见Crash" class="headerlink" title="7. 其他常见Crash"></a>7. 其他常见Crash</h3><ul>
<li>KVO相关Crash<ul>
<li>移除未注册的观察者</li>
<li>重复移除观察者</li>
<li>添加了观察者但是没有实现 <code>-observeValueForKeyPath:ofObject:change:context:</code>方法</li>
<li>添加移除keypath&#x3D;nil</li>
<li>添加移除observer&#x3D;nil</li>
</ul>
</li>
<li>unrecognized selector sent to instance（这种也经常是野指针问题）</li>
</ul>
<h2 id="二、Unix-Signal-Exception"><a href="#二、Unix-Signal-Exception" class="headerlink" title="二、Unix Signal Exception"></a>二、Unix Signal Exception</h2><h3 id="常见信号类型"><a href="#常见信号类型" class="headerlink" title="常见信号类型"></a>常见信号类型</h3><ol>
<li><p><strong>SIGHUP</strong></p>
<ul>
<li>本信号在用户终端连接(正常或非正常)结束时发出</li>
<li>通常是在终端的控制进程结束时，通知同一session内的各个作业</li>
</ul>
</li>
<li><p><strong>SIGINT</strong></p>
<ul>
<li>程序终止(interrupt)信号</li>
<li>在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程</li>
</ul>
</li>
<li><p><strong>SIGQUIT</strong></p>
<ul>
<li>类似SIGINT，但由QUIT字符(通常是Ctrl-)来控制</li>
<li>进程在因收到SIGQUIT退出时会产生core文件</li>
</ul>
</li>
<li><p><strong>SIGABRT</strong></p>
<ul>
<li>调用abort函数生成的信号</li>
</ul>
</li>
<li><p><strong>SIGBUS</strong></p>
<ul>
<li>非法地址，包括内存地址对齐(alignment)出错</li>
<li>与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的</li>
</ul>
</li>
<li><p><strong>SIGFPE</strong></p>
<ul>
<li>致命的算术运算错误信号</li>
<li>包括浮点运算错误、溢出及除数为0等</li>
</ul>
</li>
<li><p><strong>SIGKILL</strong></p>
<ul>
<li>用来立即结束程序的运行</li>
<li>本信号不能被阻塞、处理和忽略</li>
</ul>
</li>
<li><p><strong>SIGSEGV</strong></p>
<ul>
<li>试图访问未分配给自己的内存</li>
<li>试图往没有写权限的内存地址写数据</li>
</ul>
</li>
<li><p><strong>SIGPIPE</strong></p>
<ul>
<li>管道破裂</li>
<li>通常在进程间通信产生</li>
</ul>
</li>
</ol>
<h3 id="iOS中常见的系统信号"><a href="#iOS中常见的系统信号" class="headerlink" title="iOS中常见的系统信号"></a>iOS中常见的系统信号</h3><p>在iOS crash中主要是SIGKILL、SIGSEGV、SIGABRT、SIGTRAP，引起系统信号crash主要有内存泄露、野指针等。</p>
<h3 id="特殊类型Crash"><a href="#特殊类型Crash" class="headerlink" title="特殊类型Crash"></a>特殊类型Crash</h3><table>
<thead>
<tr>
<th>错误码</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x8badf00d</td>
<td>“ate bad food”</td>
<td>在启动、终止应用或响应系统事件花费过长时间</td>
</tr>
<tr>
<td>0xdeadfa11</td>
<td>“dead fall”</td>
<td>用户强制退出（系统无响应时，用户按电源开关和HOME）</td>
</tr>
<tr>
<td>0xbaaaaaad</td>
<td>-</td>
<td>用户按住Home键和音量键，获取当前内存状态，不代表崩溃</td>
</tr>
<tr>
<td>0xbad22222</td>
<td>-</td>
<td>VoIP应用因为恢复得太频繁导致crash</td>
</tr>
<tr>
<td>0xc00010ff</td>
<td>“cool off”</td>
<td>因为太烫了被干掉</td>
</tr>
<tr>
<td>0xdead10cc</td>
<td>“dead lock”</td>
<td>因为在后台时仍然占据系统资源（比如通讯录）被干掉</td>
</tr>
</tbody></table>
<h2 id="三、Crash解决方案"><a href="#三、Crash解决方案" class="headerlink" title="三、Crash解决方案"></a>三、Crash解决方案</h2><h3 id="1-Objective-C-Exception处理"><a href="#1-Objective-C-Exception处理" class="headerlink" title="1. Objective-C Exception处理"></a>1. Objective-C Exception处理</h3><p>NSInvalidArgumentException、NSRangeException这一类很好重现，能够复现定位就好解决。需要写代码的时候多做验证，也可以把一些验证写出category，统一使用。</p>
<p>例如数组访问安全封装：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)safeObjectAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="keyword">self</span>.count) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)safeAddObject:(<span class="type">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (object) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addObject:object];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样代码统一使用，可以避免一些问题。还可以在有异常的时候加入日志或者上报。</p>
<h3 id="2-信号类Crash处理"><a href="#2-信号类Crash处理" class="headerlink" title="2. 信号类Crash处理"></a>2. 信号类Crash处理</h3><ul>
<li>主要通过分析是否是系统crash，还是内存泄露、多线程问题等</li>
<li>内存泄露可以通过instrument定位，也可以在Xcode开启zombie选项定位</li>
<li>retain-cycle可以使用第三方工具检测</li>
</ul>
<h3 id="3-Crash上报机制"><a href="#3-Crash上报机制" class="headerlink" title="3. Crash上报机制"></a>3. Crash上报机制</h3><p>实际项目中通常会接入crash上报工具，如腾讯Bugly。这些上报原理是注册对应的处理handleUncaughtException和信号handle：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line"><span class="type">void</span> InstallUncaughtExceptionHandler(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;handleUncaughtException);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> handleUncaughtException(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *crashInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Exception name：%@\nException reason：%@\nException stack：%@&quot;</span>,</span><br><span class="line">                          [exception name], </span><br><span class="line">                          [exception reason], </span><br><span class="line">                          [exception callStackSymbols]];</span><br><span class="line">    [CrashReporter saveCrash:crashInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号监听</span></span><br><span class="line"><span class="type">void</span> InstallSignalHandler(<span class="type">void</span>) &#123;</span><br><span class="line">    signal(SIGHUP, handleSignalException);</span><br><span class="line">    signal(SIGINT, handleSignalException);</span><br><span class="line">    signal(SIGQUIT, handleSignalException);</span><br><span class="line">    signal(SIGABRT, handleSignalException);</span><br><span class="line">    signal(SIGILL, handleSignalException);</span><br><span class="line">    signal(SIGSEGV, handleSignalException);</span><br><span class="line">    signal(SIGFPE, handleSignalException);</span><br><span class="line">    signal(SIGBUS, handleSignalException);</span><br><span class="line">    signal(SIGPIPE, handleSignalException);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> handleSignalException(<span class="type">int</span> signal) &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *crashInfo = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">    [crashInfo appendString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;signal:%d\n&quot;</span>, signal]];</span><br><span class="line">    [crashInfo appendString:<span class="string">@&quot;Stack:\n&quot;</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="type">void</span> *callstack[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> frames = backtrace(callstack, <span class="number">128</span>);</span><br><span class="line">    <span class="type">char</span> **strs = backtrace_symbols(callstack, frames);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; frames; ++i) &#123;</span><br><span class="line">        [crashInfo appendFormat:<span class="string">@&quot;%s\n&quot;</span>, strs[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    [CrashReporter saveCrash:crashInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样crash的时候存储crash信息，然后再次启动对应上报。</p>
<blockquote>
<p>注意：还有一些激进的处理方法，hook系统对应函数不让app crash。但即便不crash，出了问题app体验也不好了，也可能用不了了。建议谨慎使用这种方案。</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>调试</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS使用Cursor开发配置指南</title>
    <url>/2024/05/20/iOS%E4%BD%BF%E7%94%A8Cursor%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h2><p>公司采购了Cursor IDE，其中的Composer功能十分强大。目前Xcode缺乏对应的AI功能，尝试迁移到Cursor。</p>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><h3 id="2-1-必要插件安装"><a href="#2-1-必要插件安装" class="headerlink" title="2.1 必要插件安装"></a>2.1 必要插件安装</h3><ul>
<li>安装Swift扩展插件<br><img src="https://gcore.jsdelivr.net/gh/zcx4u/images/images/iShot_2025-04-01_10.53.03.png" alt="iShot_2025-04-01_10.53.03"></li>
<li>安装SweetPad扩展插件<br><img src="https://gcore.jsdelivr.net/gh/zcx4u/images/images/iShot_2025-04-01_10.28.35.png" alt="iShot_2025-04-01_10.28.35"></li>
<li>在SweetPad插件中安装TOOLS<br><img src="https://gcore.jsdelivr.net/gh/zcx4u/images/images/iShot_2025-04-01_10.27.36.png" alt="iShot_2025-04-01_10.27.36"></li>
<li>xcode-build-server 必须安装 别的按需安装即可</li>
</ul>
<h3 id="2-2-可选插件安装"><a href="#2-2-可选插件安装" class="headerlink" title="2.2 可选插件安装"></a>2.2 可选插件安装</h3><ul>
<li>安装Chinese简体中文插件将Cursor语言改成中文</li>
<li>安装Xcode Keymap扩展插件将Xcode的快捷键映射到Cursor</li>
</ul>
<h3 id="2-3-界面优化"><a href="#2-3-界面优化" class="headerlink" title="2.3 界面优化"></a>2.3 界面优化</h3><p>新下载的Cursor功能菜单默认布局是横向的，空间很小，建议改成纵向布局：</p>
<ol>
<li>Cursor - 首选项 - 设置 - 工作台 - 外观</li>
<li>搜索 workbench.activityBar.orientation，改为vertical</li>
<li>重启即可<img src="https://gcore.jsdelivr.net/gh/zcx4u/images/images/iShot_2025-04-01_11.14.20.png" alt="iShot_2025-04-01_11.14.20"></li>
</ol>
<h2 id="三、编译与运行"><a href="#三、编译与运行" class="headerlink" title="三、编译与运行"></a>三、编译与运行</h2><h3 id="3-1-设备选择"><a href="#3-1-设备选择" class="headerlink" title="3.1 设备选择"></a>3.1 设备选择</h3><p>在SweetPad插件中找到DESTINATIONS(设备列表)项：</p>
<ul>
<li>只能找到iOS17以上的设备，最好使用模拟器</li>
<li>此插件不支持真机Debug</li>
<li>右键点击模拟器后弹出选择设备</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/zcx4u/images/images/iShot_2025-04-01_10.28.03.png" alt="iShot_2025-04-01_10.28.03"></p>
<h3 id="3-2-构建项目"><a href="#3-2-构建项目" class="headerlink" title="3.2 构建项目"></a>3.2 构建项目</h3><p>找到BUILD项，找到需要编译的target：</p>
<ul>
<li>右键点击弹出菜单选择Build</li>
<li>或者点击右侧快捷按钮</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/zcx4u/images/images/iShot_2025-04-01_10.56.48.png" alt="iShot_2025-04-01_10.56.48"></p>
<h2 id="四、代码索引配置"><a href="#四、代码索引配置" class="headerlink" title="四、代码索引配置"></a>四、代码索引配置</h2><h3 id="4-1-生成代码树"><a href="#4-1-生成代码树" class="headerlink" title="4.1 生成代码树"></a>4.1 生成代码树</h3><ol>
<li>Cursor顶部快捷栏搜索 &gt;Build Server Config<br><img src="https://gcore.jsdelivr.net/gh/zcx4u/images/images/iShot_2025-04-01_10.32.42.png" alt="iShot_2025-04-01_10.32.42"></li>
<li>通过SweetPad生成代码索引树</li>
<li>注意这一步一定要在全量编译之后执行</li>
</ol>
<p>完成后在Cursor中可以点按command进行代码调用回溯。</p>
<h2 id="五、调试配置"><a href="#五、调试配置" class="headerlink" title="五、调试配置"></a>五、调试配置</h2><h3 id="5-1-设置调试环境"><a href="#5-1-设置调试环境" class="headerlink" title="5.1 设置调试环境"></a>5.1 设置调试环境</h3><ol>
<li>打开Cursor和SweetPad在同一级的Debug项目</li>
<li>点击绿色按钮创建launch.json</li>
<li>选择中间顶部弹出的菜单通过SweetPad创建LLDB</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/zcx4u/images/images/iShot_2025-04-01_10.30.46.png" alt="iShot_2025-04-01_10.30.46"></p>
<h3 id="5-2-启动调试"><a href="#5-2-启动调试" class="headerlink" title="5.2 启动调试"></a>5.2 启动调试</h3><ol>
<li>手动点击Attach to running app (SweetPad)或者F5快捷键启动Debug</li>
<li>注意只能选择模拟器，目前还不支持真机调试</li>
<li>等待模拟器启动APP后，LLDB会命中断点</li>
<li>在Debug项目下可以看到各种Debug信息，在调试控制台可以使用LLDB命令</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/zcx4u/images/images/iShot_2025-04-01_10.26.12.png" alt="iShot_2025-04-01_10.26.25"><br><img src="https://gcore.jsdelivr.net/gh/zcx4u/images/images/iShot_2025-04-01_10.26.25.png" alt="iShot_2025-04-01_10.26.25"></p>
<h2 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h2><h3 id="6-1-索引依赖"><a href="#6-1-索引依赖" class="headerlink" title="6.1 索引依赖"></a>6.1 索引依赖</h3><p>相比与Xcode常驻的代码索引来说，此插件的索引强依赖一次成功的全量编译，如果发现不能定位方法调用栈时可能是编译缓存失效了，需要再次全量编译。</p>
<h3 id="6-2-工具依赖"><a href="#6-2-工具依赖" class="headerlink" title="6.2 工具依赖"></a>6.2 工具依赖</h3><ul>
<li>此插件强依赖Xcode提供的Xcode Command Line工具</li>
<li>所有的编译&amp;运行工作其实都是在终端中调用Xcode命令行工具</li>
<li>debug会有任务依赖，需要等待前置lunch任务执行</li>
</ul>
<h2 id="七、待解决问题"><a href="#七、待解决问题" class="headerlink" title="七、待解决问题"></a>七、待解决问题</h2><h3 id="7-1-系统兼容性"><a href="#7-1-系统兼容性" class="headerlink" title="7.1 系统兼容性"></a>7.1 系统兼容性</h3><p>目前这种方式只支持iOS17以上的系统设备，且只支持模拟器调试。我们的项目有些三方库去掉了模拟器架构，需要调整三方库架构。</p>
<h3 id="7-2-项目配置"><a href="#7-2-项目配置" class="headerlink" title="7.2 项目配置"></a>7.2 项目配置</h3><p>.xcodeproj、BuildSetting等项目配置还依赖Xcode进行编辑，需使用XcodeGen进行改造，有一些成本。</p>
<h3 id="7-3-文件组织方式"><a href="#7-3-文件组织方式" class="headerlink" title="7.3 文件组织方式"></a>7.3 文件组织方式</h3><p>目前Xcode组织文件使用Group格式，通过Cursor创建的文件是Folder格式，需要将当前的组织方式从Group全部转成Folder，成本也比较高。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>AI</tag>
        <tag>Cursor</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS字符串安全截取及任意位置插入</title>
    <url>/2021/04/22/iOS%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%B4%A0%E7%B0%87/</url>
    <content><![CDATA[<h2 id="一个小问题引起的思考"><a href="#一个小问题引起的思考" class="headerlink" title="一个小问题引起的思考"></a>一个小问题引起的思考</h2><p>最近做一个输入框粘贴插入文字的需求时遇到了一个问题：</p>
<p>输入框中输入了文字和表情符😃😃😃（emoji）计算出的光标location和实际感官上的字符个数不一致，最后导致文字插入的位置不对。</p>
<p>这是为什么呢？</p>
<p>查阅资料发现是Unicode编码和UTF-16编码的设计特点导致的此现象。</p>
<h2 id="字符和字素簇定义说明"><a href="#字符和字素簇定义说明" class="headerlink" title="字符和字素簇定义说明"></a>字符和字素簇定义说明</h2><blockquote>
<p>Characters and Grapheme Clusters</p>
</blockquote>
<blockquote>
<p>It’s common to think of a string as a sequence of characters, but when working with <code>NSString</code> objects, or with Unicode strings in general, in most cases it is better to deal with substrings rather than with individual characters. The reason for this is that what the user perceives as a character in text may in many cases be represented by multiple characters in the string. <code>NSString</code> has a large inventory of methods for properly handling Unicode strings, which in general make Unicode compliance easy, but there are a few precautions you should observe.</p>
</blockquote>
<p>我们通常将<code>String</code>视为<code>Characters</code>序列，用户能看到的文本中的<code>String</code>可能由字符串中的多个<code>Characters</code>表示，所以在处理<code>NSString</code>对象或一般的<code>Unicode</code>字符串时，处理子字符串大多数情况下比处理单个字符更好。尽管<code>NSString</code>有大量正确处理<code>Unicode</code>字符串的方法清单，但是仍有一些你需要注意的预防措施。</p>
<hr>
<blockquote>
<p><code>NSString</code> objects are conceptually UTF-16 with platform endianness. That doesn’t necessarily imply anything about their internal storage mechanism; what it means is that <code>NSString</code> lengths, character indexes, and ranges are expressed in terms of UTF-16 units, and that the term “character” in <code>NSString</code> method names refers to 16-bit platform-endian UTF-16 units. This is a common convention for string objects. In most cases, clients don’t need to be overly concerned with this; as long as you are dealing with substrings, the precise interpretation of the range indexes is not necessarily significant.</p>
</blockquote>
<p>从概念上讲<code>NSString</code>是<code>UTF-16</code>平台字节序编码,但这并不一定意味着其内部存储机制。这意味着**<code>NSString</code>长度，字符索引和范围以<code>UTF-16</code>单位表示**，<code>NSString</code>方法名称中的<code>“character”</code>一词是指16位平台字节序的<code>UTF-16</code>单位。这是字符串对象的通用约定。在大多数情况下不必对此太在意，只要您正在处理子字符串，范围索引的精确解释就不一定很重要。(精确索引常用在处理emoji相关，常规一个字符型对应的长度是1，emoji不同的表情对应的是2或3)</p>
<hr>
<blockquote>
<p>The vast majority of Unicode code points used for writing living languages are represented by single UTF-16 units. However, some less common Unicode code points are represented in UTF-16 by surrogate pairs. A surrogate pair is a sequence of two UTF-16 units, taken from specific reserved ranges, that together represent a single Unicode code point. CFString has functions for converting between surrogate pairs and the UTF-32 representation of the corresponding Unicode code point. When dealing with <code>NSString</code> objects, one constraint is that substring boundaries usually should not separate the two halves of a surrogate pair. This is generally automatic for ranges returned from most Cocoa methods, but if you are constructing substring ranges yourself you should keep this in mind. However, this is not the only constraint you should consider.</p>
</blockquote>
<blockquote>
<p>名词解释</p>
<p><strong>surrogate pairs: 代理对</strong></p>
<p>UTF-16是早期Unicode遗留下的历史产物，原本被设计成具有固定宽度的16位编码格式。为支持超过U+FFFF的增补字符，设立了代理机制</p>
<p>在BMP内的字符，仍然按照<a href="https://baike.baidu.com/item/UTF-16">UTF-16</a>的编码规则，使用两个字符来表示。 [1] （注：BMP内的字符编码，不包含从U+D800到U+DFFF的预留码位。这些预留码位就恰好用于扩展字符编码）</p>
<p>增补字符的编码值已经超过了BMP的编码范围，所以，需要使用一对UTF-16字符来表示一个字符。UTF-16编码以16位无符号整数为单位。我们把Unicode编码记作U。编码规则如下：</p>
<ul>
<li><p>如果U&lt;0x10000，U的UTF-16编码就是U对应的16位无符号整数。</p>
</li>
<li><p>如果U≥0x10000，</p>
</li>
<li><ul>
<li>我们先计算U’&#x3D;U-0x10000，</li>
<li>然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，</li>
<li>U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。</li>
</ul>
</li>
</ul>
<p>这两个字符就称为surrogate pair（代理对）。第一个代理字符为16位编码，范围为U+D800到U+DFFF，第二个代理字符也是一个16位编码，范围为U+DC00 to U+DFFF。</p>
</blockquote>
<p>世界上存在的语言中绝大多数的<code>Unicode </code>编码都由单个<code>UTF-16</code>单元表示，但是仍然有少部分<code>Unicode</code>编码是使用代理对<code>surrogate pairs</code>来表示。代理对是从特定保留范围中提取的两个<code>UTF-16</code>单元的序列，它们一起代表一个<code>Unicode</code>代码点。<code>CFString</code>具有在代理对和相应<code>Unicode</code>代码点的<code>UTF-32</code>表示之间进行转换的功能。处理<code>NSString</code>时，子字符串边界不应将代理对的两半分开，<strong>大多数<code>Cocoa </code>方法会自动返回正确的<code>Range</code></strong>，但是如果您自己构造子字符串范围，则应牢记这一点。但是，这不是您应该考虑的唯一约束。</p>
<hr>
<blockquote>
<p>In many writing systems, a single character may be composed of a base letter plus an accent or other decoration. The number of possible letters and accents precludes Unicode from representing each combination as a single code point, so in general such combinations are represented by a base character followed by one or more combining marks. For compatibility reasons, Unicode does have single code points for a number of the most common combinations; these are referred to as precomposed forms, and Unicode normalization transformations can be used to convert between precomposed and decomposed representations. However, even if a string is fully precomposed, there are still many combinations that must be represented using a base character and combining marks. For most text processing, substring ranges should be arranged so that their boundaries do not separate a base character from its associated combining marks.</p>
</blockquote>
<p>在许多书写系统中，单个字符可以由一个基本字母加上一个重音符号或其他装饰组成。可能的字母和重音的数量使Unicode无法将每个组合表示为单个代码点，因此，通常，此类组合用基本字符表示，后跟一个或多个组合标记。出于兼容性原因，Unicode确实为许多最常见的组合提供了单个代码点。这些被称为预组合形式，并且Unicode规范化转换可用于在预组合和分解表示之间进行转换。但是，即使完全预先组成了字符串，对于大多数文本处理，<strong>也应该使子字符串范围的边界不会将基字符与其相关的组合标记分开</strong>。</p>
<hr>
<blockquote>
<p>In addition, there are writing systems in which characters represent a combination of parts that are more complicated than accent marks. In Korean, for example, a single Hangul syllable can be composed of two or three subparts known as jamo. In the Indic and Indic-influenced writing systems common throughout South and Southeast Asia, single written characters often represent combinations of consonants, vowels, and marks such as viramas, and the Unicode representations of these writing systems often use code points for these individual parts, so that a single character may be composed of multiple code points. For most text processing, substring ranges should also be arranged so that their boundaries do not separate the jamo in a single Hangul syllable, or the components of an Indic consonant cluster.</p>
</blockquote>
<p>此外，有些书写系统中，字符代表的是比重音符号更复杂的部分的组合。例如，在韩语中，一个单字音节可以由两个或三个被称为jamo的子音节组成。在遍及南亚和东南亚的印度语和受印度语影响的书写系统中，单个书写字符通常代表辅音、元音和诸如viramas等标记的组合，而这些书写系统的Unicode表示通常使用代码点来表示这些单独的部分，使单个字符可以由多个代码点组成。对于大多数文本处理，还应该使子字符串范围的边界不会将jamo分隔在单个韩文音节中，也不会将印度语辅音集群的组成部分分开。<strong>（相对于重音符号还有更复杂的编码结构，例如韩文和印度文，对于这些更复杂的结构也应该保持代理对不能被拆分）</strong></p>
<hr>
<p>In general, these combinations—surrogate pairs, base characters plus combining marks, Hangul jamo, and Indic consonant clusters—are referred to as grapheme clusters. In order to take them into account, you can use <code>NSString</code>’s <code>rangeOfComposedCharacterSequencesForRange:</code> or <code>rangeOfComposedCharacterSequenceAtIndex:</code> methods, or <code>CFStringGetRangeOfComposedCharactersAtIndex</code>. These can be used to adjust string indexes or substring ranges so that they fall on grapheme cluster boundaries, taking into account all of the constraints mentioned above. These methods should be the default choice for programmatically determining the boundaries of user-perceived characters.:</p>
<p>通常，这些组合（代理对，基本字符加组合标记，Hangul jamo和印度辅音簇）被称为字素簇。为了将它们考虑在内，您可以使用<code>NSString</code>的<a href="https://developer.apple.com/documentation/foundation/nsstring/1410993-rangeofcomposedcharactersequence"><code>rangeOfComposedCharacterSequencesForRange:</code></a>或<code>rangeOfComposedCharacterSequenceAtIndex:</code>方法，或<code>CFStringGetRangeOfComposedCharactersAtIndex</code>。考虑到上述所有约束，这些可用于调整字符串索引或子字符串范围，使它们落在字素簇边界上。这些方法应该是通过编程确定用户感知字符边界的默认选择。</p>
<hr>
<blockquote>
<p>In some cases, Unicode algorithms deal with multiple characters in ways that go beyond even grapheme cluster boundaries. Unicode casing algorithms may convert a single character into multiple characters when going from lowercase to uppercase; for example, the standard uppercase equivalent of the German character “ß” is the two-letter sequence “SS”. Localized collation algorithms in many languages consider multiple-character sequences as single units; for example, the sequence “ch” is treated as a single letter for sorting purposes in some European languages. In order to deal properly with cases like these, it is important to use standard <code>NSString</code> methods for such operations as casing, sorting, and searching, and to use them on the entire string to which they are to apply. Use <code>NSString</code> methods such as <code>lowercaseString</code>, <code>uppercaseString</code>, <code>capitalizedString</code>, <code>compare:</code> and its variants, <code>rangeOfString:</code> and its variants, and <code>rangeOfCharacterFromSet:</code> and its variants, or their CFString equivalents. These all take into account the complexities of Unicode string processing, and the searching and sorting methods in particular have many options to control the types of equivalences they are to recognize.</p>
</blockquote>
<p>在某些情况下，Unicode算法以甚至超出字素簇边界的方式处理多个字符。从小写变为大写时，Unicode大小写算法可以将单个字符转换为多个字符。例如，德语字符“ß”的标准大写字母等同于两个字母的序列“ SS”。</p>
<p>许多语言中的本地化排序规则算法将多字符序列视为单个单元。例如在某些欧洲语言中，出于排序目的，序列“ ch”被视为单个字母。</p>
<p>在整个字符串上使用标准<code>NSString</code>方法进行诸如大小写，排序和搜索之类的操作可以正确处理此类情况。使用<code>NSString</code>方法，如<code>lowercaseString</code>，<code>uppercaseString</code>，<code>capitalizedString</code>，<code>compare:</code>和其变体，<code>rangeOfString:</code>和其变体，和<code>rangeOfCharacterFromSet:</code>其变体，或它们的等价CFString字符串方法。</p>
<p>所有这些都考虑到了Unicode字符串处理的复杂性，特别是搜索和排序方法具有许多选项来控制它们要识别的等价类型。</p>
<hr>
<blockquote>
<p>In some less common cases, it may be necessary to tailor the definition of grapheme clusters to a particular need. The issues involved in determining and tailoring grapheme cluster boundaries are covered in detail in <a href="http://unicode.org/reports/tr29/">Unicode Standard Annex #29</a>, which gives a number of examples and some algorithms. The Unicode standard in general is the best source for information about Unicode algorithms and the considerations involved in processing Unicode strings.</p>
<p>If you are interested in grapheme cluster boundaries from the point of view of cursor movement and insertion point positioning, and you are using the Cocoa text system, you should know that on OS X v10.5 and later, <code>NSLayoutManager</code> has API support for determining insertion point positions within a line of text as it is laid out. Note that insertion point boundaries are not identical to glyph boundaries; a ligature glyph in some cases, such as an “fi” ligature in Latin script, may require an internal insertion point on a user-perceived character boundary. See <em><a href="https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009459">Cocoa Text Architecture Guide</a></em> for more information.</p>
</blockquote>
<p>在一些不太常见的情况下，可能有必要根据特定需要定制字素簇的定义。<a href="http://unicode.org/reports/tr29/">Unicode标准附件＃29</a>中详细介绍了确定和调整字素簇边界的问题，该<a href="http://unicode.org/reports/tr29/">附件</a>提供了许多示例和一些算法。通常，Unicode标准是有关Unicode算法以及处理Unicode字符串所涉及的注意事项的最佳信息来源。</p>
<p>如果您从光标移动和插入点定位的角度对字形簇边界感兴趣，并且您正在使用Cocoa文本系统，则应该知道在OS X v10.5和更高版本中，<code>NSLayoutManager</code>API支持确定插入点布置在一行文本中的位置。请注意，插入点边界与字形边界不同；在某些情况下，连字字形（例如拉丁语脚本中的“ fi”连字）可能需要在用户感知的字符边界上的内部插入点。有关更多信息，请参见《<em><a href="https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009459">Cocoa文本体系结构指南》</a></em>。</p>
<h2 id="一种安全截取的方法"><a href="#一种安全截取的方法" class="headerlink" title="一种安全截取的方法"></a>一种安全截取的方法</h2><p>由上文可知 String 提供系统方法来识别完整的可见字符</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">rangeOfComposedCharacterSequencesForRange:</span><br><span class="line">rangeOfComposedCharacterSequenceAtIndex:</span><br><span class="line">这两个方法返回了给定range内包含的完整字符的索引地址</span><br><span class="line">给定初始 range <span class="operator">=</span> <span class="number">0</span> <span class="number">0</span>（location <span class="operator">=</span> <span class="number">0</span>， length <span class="operator">=</span> <span class="number">0</span>）</span><br><span class="line">“hello” 返回 <span class="number">0</span> <span class="number">1</span> 截取为 “h”</span><br><span class="line">“😀hello” 返回 <span class="number">0</span> <span class="number">2</span> 截取为 “😀”</span><br></pre></td></tr></table></figure>

<p><strong>字符串截取或者在光标处插入字符应默认使用这两个方法来获取可视字符边界来避免代理对被拆开导致的显示bug</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 在字符串中光标位置插入子字符串的方法 </span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - baseString: 被插入的字符串</span></span><br><span class="line"><span class="comment">///   - location: 光标位置 selectedRange.location</span></span><br><span class="line"><span class="comment">///   - insertString: 要插入的字符串</span></span><br><span class="line"><span class="comment">/// - Returns: 插入后完整字符串</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">insertStringTo</span>(<span class="params">baseString</span>: <span class="type">String</span>, <span class="params">location</span>: <span class="type">Int</span>, <span class="params">insertString</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> leadingString <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">var</span> trailingString <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">var</span> range <span class="operator">=</span> <span class="type">NSRange</span>(location: <span class="number">0</span>, length: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> range.length <span class="operator">&lt;</span> baseString.count &#123;</span><br><span class="line">            <span class="keyword">let</span> r <span class="operator">=</span> baseString.rangeOfComposedCharacterSequence(at: baseString.index(baseString.startIndex,</span><br><span class="line">                                                                                     offsetBy: range.length))</span><br><span class="line">            leadingString <span class="operator">=</span> <span class="type">String</span>(baseString[<span class="operator">..&lt;</span>r.upperBound])</span><br><span class="line">            trailingString <span class="operator">=</span> <span class="type">String</span>(baseString[r.upperBound<span class="operator">...</span>])  </span><br><span class="line">            <span class="keyword">if</span> location <span class="operator">&lt;=</span> leftString.count &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(leadingString)</span><span class="subst">\(insertString)</span><span class="subst">\(trailingString)</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            range <span class="operator">=</span> <span class="type">NSRange</span>(location: <span class="number">0</span>, length: leadingString.unicodeScalars.count)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关链接及资料"><a href="#相关链接及资料" class="headerlink" title="相关链接及资料"></a>相关链接及资料</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html">原文链接字符和字素簇</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Strings/introStrings.html#//apple_ref/doc/uid/10000035-SW1">字符串编程指南</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>多读文档</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS文件系统编程指南</title>
    <url>/2025/03/12/iOS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="iOS文件系统编程指南"><a href="#iOS文件系统编程指南" class="headerlink" title="iOS文件系统编程指南"></a>iOS文件系统编程指南</h1><p><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/NaN">iOS文件系统编程指南</a></p>
<blockquote>
<p>文件系统处理数据文件、应用程序以及与操作系统本身关联的文件的持久存储。因此，文件系统是所有进程使用的基本资源之一。</p>
<p>APFS 是 macOS、iOS、watchOS 和 tvOS 中的默认文件系统。APFS 取代 HFS+ 作为 iOS 10.3 及更高版本以及 macOS High Sierra 及更高版本的默认文件系统。</p>
</blockquote>
<h2 id="关于-iOS-文件系统"><a href="#关于-iOS-文件系统" class="headerlink" title="关于 iOS 文件系统"></a>关于 iOS 文件系统</h2><p>iOS 文件系统面向独立运行的应用程序。为了保持系统简单，iOS 设备的用户无法直接访问文件系统，应用应遵循此约定。</p>
<img src="https://cdn.zcx.info/202303291747602.png" style="zoom:50%;" />

<h2 id="iOS-标准目录：文件所在的位置"><a href="#iOS-标准目录：文件所在的位置" class="headerlink" title="iOS 标准目录：文件所在的位置"></a>iOS 标准目录：文件所在的位置</h2><table>
<thead>
<tr>
<th align="left">目录</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AppName.app</code></td>
<td align="left">这是应用程序的捆绑包。此目录包含应用程序及其所有资源。您不能写入此目录。为防止篡改，捆绑目录在安装时进行了签名。写入此目录会更改签名并阻止您的应用程序启动。但是，您可以获得对存储在应用程序包中的任何资源的只读访问权限。此目录的内容未由 iTunes 或 iCloud 备份。但是，iTunes 会对从 App Store 购买的任何应用程序执行初始同步。</td>
</tr>
<tr>
<td align="left"><code>Documents/</code></td>
<td align="left">使用此目录存储用户生成的内容。该目录的内容可以通过文件共享提供给用户；因此，该目录应该只包含您可能希望向用户公开的文件。此目录的内容由 iTunes 和 iCloud 备份。</td>
</tr>
<tr>
<td align="left"><code>Documents/Inbox</code></td>
<td align="left">使用此目录可访问外部实体要求您的应用程序打开的文件。具体来说，Mail 程序将与您的应用相关联的电子邮件附件放在该目录中。文档交互控制器也可以在其中放置文件。您的应用程序可以读取和删除此目录中的文件，但不能创建新文件或写入现有文件。如果用户试图编辑此目录中的文件，您的应用程序必须在进行任何更改之前静默将其移出目录。此目录的内容由 iTunes 和 iCloud 备份。</td>
</tr>
<tr>
<td align="left"><code>Library/</code></td>
<td align="left">这是所有非用户数据文件的顶级目录。您通常将文件放在几个标准子目录之一中。iOS 应用通常使用<code>Application Support</code>和<code>Caches</code>子目录；但是，您可以创建自定义子目录。将<code>Library</code>子目录用于您不想向用户公开的任何文件。您的应用不应将这些目录用于用户数据文件。目录的内容<code>Library</code>（子目录除外<code>Caches</code>）由 iTunes 和 iCloud 备份。</td>
</tr>
<tr>
<td align="left"><code>tmp/</code></td>
<td align="left">使用此目录写入不需要在应用程序启动之间保留的临时文件。当不再需要时，您的应用程序应从该目录中删除文件；但是，当您的应用程序未运行时，系统可能会清除此目录。此目录的内容未由 iTunes 或 iCloud 备份。</td>
</tr>
</tbody></table>
<h2 id="APP-文件应该存放的位置"><a href="#APP-文件应该存放的位置" class="headerlink" title="APP 文件应该存放的位置"></a>APP 文件应该存放的位置</h2><p>为防止 iOS 设备上的同步和备份过程花费很长时间，请选择放置文件的位置。</p>
<p>存储大文件的应用程序会减慢备份到 iTunes 或 iCloud 的过程。</p>
<p>这些应用程序还会占用用户的大量可用存储空间，这可能会促使用户删除该应用程序或禁止将该应用程序的数据备份到 iCloud。</p>
<p>考虑到这一点，您应该根据以下准则存储应用程序数据：</p>
<ul>
<li>将用户数据放入<code>Documents/</code>. 用户数据通常包括您可能希望向用户公开的任何文件——您可能希望用户创建、导入、删除或编辑的任何文件。对于绘图应用程序，用户数据包括用户可能创建的任何图形文件。对于文本编辑器，它包括文本文件。视频和音频应用程序甚至可能包含用户下载以供稍后观看或收听的文件。</li>
<li>将应用程序创建的支持文件放在该<code>Library/Application support/</code>目录中。通常，此目录包含应用程序用来运行但应该对用户隐藏的文件。此目录还可以包含数据文件、配置文件、模板和从应用程序包加载的资源的修改版本。</li>
<li>请记住，默认情况下会备份<code>Documents/</code>和中的文件。您可以通过使用键<code>Application Support/</code>调用从备份中排除文件。任何可以重新创建或下载的文件都必须从备份中排除。这对于大型媒体文件尤为重要。如果您的应用程序下载视频或音频文件，请确保它们不包含在备份中。<code> -[NSURL setResourceValue:forKey:error:]``NSURLIsExcludedFromBackupKey</code></li>
<li>将临时数据放在<code>tmp/</code>目录中。临时数据包括您不需要长时间保留的任何数据。请记住在完成这些文件后将其删除，以免它们继续占用用户设备上的空间。当您的应用程序未运行时，系统会定期清除这些文件；因此，您不能指望这些文件在您的应用程序终止后仍然存在。</li>
<li>将数据缓存文件放在<code>Library/Caches/</code>目录中。缓存数据可用于需要比临时数据保留更长时间但不如支持文件那么长的任何数据。一般而言，应用程序不需要缓存数据即可正常运行，但可以使用缓存数据来提高性能。缓存数据的示例包括（但不限于）数据库缓存文件和暂时的可下载内容。请注意，<strong>系统可能会删除该<code>Caches/</code>目录以释放磁盘空间</strong>，因此您的应用必须能够根据需要重新创建或下载这些文件。</li>
</ul>
<h2 id="iCloud-文件储存容器"><a href="#iCloud-文件储存容器" class="headerlink" title="iCloud 文件储存容器"></a>iCloud 文件储存容器</h2><p>iCloud 为使用 iCloud 的应用程序提供了一个结构化的文件存储系统：</p>
<ul>
<li>应用程序有一个主要的 iCloud 容器目录，用于存储它们的本机文件。他们还可以访问在其应用程序授权中列出的辅助 iCloud 容器目录。</li>
<li>在每个容器目录中，文件被分为“文档”和数据。位于<code>Documents</code>子目录（或其子目录之一）中的每个文件或文件包都作为可以单独删除的单独文档呈现给用户（通过 macOS 和 iOS 中的 iCloud UI）。任何不在<code>Documents</code>其子目录中或其子目录之一的内容都被视为数据，并在 iCloud UI 中显示为单个条目。</li>
</ul>
<p>用户在应用程序的用户界面中创建和查看的文档（例如 Pages、Numbers 和 Keynote 中的文档浏览器）应存储在该<code>Documents</code>目录中。</p>
<p>另一个可能进入<code>Documents</code>目录的文件示例是保存的游戏，同样是因为它们是应用程序可能提供某种选择方法的东西。</p>
<p>应用程序不希望用户直接查看或修改的任何内容都应放在<code>Documents</code>目录之外。应用程序可以在容器目录中创建任何子目录，因此它们可以根据需要排列私有文件。</p>
<p>应用程序在 iCloud 容器目录中创建文件和目录的方式与它们创建本地文件和目录的方式完全相同。并且所有文件的属性都被保存，如果他们向文件添加扩展属性，这些属性也会被复制到 iCloud 和用户的其他设备上。</p>
<p>iCloud 容器还允许存储无需创建文档格式即可轻松访问的键值对。</p>
<h2 id="系统如何识别文件中的内容类型"><a href="#系统如何识别文件中的内容类型" class="headerlink" title="系统如何识别文件中的内容类型"></a>系统如何识别文件中的内容类型</h2><p>识别文件内容类型的主要技术有两种：</p>
<ul>
<li>统一类型标识符 (UTI)</li>
<li>文件扩展名</li>
</ul>
<p><em>统一类型标识符</em>是一个字符串，它唯一地标识被认为具有“类型”的一类实体。UTI 为所有应用程序和服务可以识别和依赖的数据提供一致的标识符。它们也比大多数其他技术更灵活，因为您可以使用它们来表示任何类型的数据，而不仅仅是文件和目录。UTI 的例子包括：</p>
<ul>
<li><code>public.text</code>— 标识文本数据的公共类型。</li>
<li><code>public.jpeg</code>— 标识 JPEG 图像数据的公共类型。</li>
<li><code>com.apple.bundle</code>— 标识捆绑包目录的 Apple 类型。</li>
<li><code>com.apple.application-bundle</code>— 标识捆绑应用程序的 Apple 类型。</li>
</ul>
<p>每当基于 UTI 的接口可用于指定文件类型时，您应该优先选择该接口而不是其他任何接口。</p>
<p>许多 macOS 界面允许您指定与您要使用的文件或目录相对应的 UTI。</p>
<p>例如，在“打开”面板中，您可以将 UTI 用作文件过滤器，并将用户选择的文件类型限制为您的应用可以处理的文件类型。</p>
<p>几个 AppKit 类，包括<code>NSDocument</code>、<code>NSPasteboard</code>和<code>NSImage</code>，都支持 UTI。在 iOS 中，UTI 仅用于指定粘贴板类型。</p>
<p>系统确定给定文件的 UTI 的一种方法是查看其文件扩展名。</p>
<p><em>文件扩展名</em>是附加到文件末尾的一串字符，并用句点与主文件名分隔。每个唯一的字符串标识一个特定类型的文件。</p>
<p>例如，<code>.strings</code>扩展名标识具有可本地化字符串数据的资源文件，而<code>.png</code>扩展名标识具有便携式网络图形格式的图像数据的文件。</p>
<blockquote>
<p>**注意：**由于句点字符在 macOS 和 iOS 文件名中是有效字符，因此只有文件名中最后一个句点之后的字符才被视为文件扩展名的一部分。最后一个句点左侧的所有内容都被视为文件名本身的一部分。</p>
</blockquote>
<p>如果您的应用程序定义了自定义文件格式，您应该在您的应用程序文件中注册这些格式和任何关联的文件扩展名<code>Info.plist</code>。</p>
<p>该<code>CFBundleDocumentTypes</code>密钥指定您的应用可识别并能够打开的文件格式。</p>
<p>任何自定义文件格式的条目都应包括文件扩展名和与文件内容对应的 UTI。</p>
<p>系统使用该信息将具有适当类型的文件定向到您的应用程序。</p>
<h2 id="文件、并发和线程安全"><a href="#文件、并发和线程安全" class="headerlink" title="文件、并发和线程安全"></a>文件、并发和线程安全</h2><p>由于与文件相关的操作涉及与硬盘的交互，因此与大多数其他操作相比速度较慢，因此 iOS 和 macOS 中的大多数与文件相关的界面在设计时都考虑到了并发性。一些技术将异步操作结合到它们的设计中，大多数其他技术可以从调度队列或辅助线程安全地执行。</p>
<table>
<thead>
<tr>
<th align="left">类&#x2F;技术</th>
<th align="left">笔记</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>NSFileManager</code></td>
<td align="left"><code>NSFileManager</code>对于大多数任务，从多个后台线程同时使用默认对象是安全的。此规则的唯一例外是与文件管理器的委托交互的任务。将文件管理器对象与委托一起使用时，建议您创建该类的唯一实例<code>NSFileManager</code>并将委托与该实例一起使用。然后，您应该一次从一个线程使用您的唯一实例。</td>
</tr>
<tr>
<td align="left"><code>GCD</code></td>
<td align="left">GCD 本身可以安全地从任何线程使用。但是，您仍然有责任以线程安全的方式编写您的块。</td>
</tr>
<tr>
<td align="left"><code>NSFileHandle</code>, <code>NSData</code>, <code>Cocoa streams</code></td>
<td align="left">大多数用于读取和写入文件数据的 Foundation 对象都可以在任何单个线程中使用，但不应同时在多个线程中使用。</td>
</tr>
<tr>
<td align="left">Open and Save panels</td>
<td align="left">因为它们是用户界面的一部分，所以您应该始终从应用程序的主线程中显示和操作打开和保存面板。</td>
</tr>
<tr>
<td align="left">POSIX 线程</td>
<td align="left">用于操作文件的 POSIX 线程通常被设计为从任何线程安全地操作。有关详细信息，请参阅相应的手册页。</td>
</tr>
<tr>
<td align="left"><code>NSURL</code>和<code>NSString</code></td>
<td align="left">用于指定路径的不可变对象可以安全地从任何线程使用。因为它们是不可变的，所以您也可以同时从多个线程引用它们。当然，这些对象的可变版本一次只能在一个线程中使用。</td>
</tr>
<tr>
<td align="left"><code>NSEnumerator</code>及其子类</td>
<td align="left">枚举器对象可以安全地从任何单个线程使用，但不应同时从多个线程使用。</td>
</tr>
</tbody></table>
<p>即使您使用线程安全接口来操作文件，当多个线程或多个进程试图对同一个文件进行操作时，问题仍然会出现。</p>
<p>尽管有防止多个客户端同时修改文件的保护措施，但这些保护措施并不总是保证始终对文件进行独占访问。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>多读文档</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS端 ASR优化</title>
    <url>/2024/05/20/iOS%E7%AB%AF%20ASR%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="iOS端-ASR优化"><a href="#iOS端-ASR优化" class="headerlink" title="iOS端 ASR优化"></a>iOS端 ASR优化</h1><h2 id="一、ASR-Automatic-Speech-Recognition-简介"><a href="#一、ASR-Automatic-Speech-Recognition-简介" class="headerlink" title="一、ASR(Automatic Speech Recognition)简介"></a>一、ASR(Automatic Speech Recognition)简介</h2><p>ASR是一种将语音信号转换为文本的技术，它可以帮助人们更方便地与计算机进行交互。我们的AI作业小节在录制过程中会同步调用ASR服务商实时将用户录制的语音转成为文字，在录制完成后根据ASR结果计算流畅度、语速评分，在上传作业的时候将ASR结果同时上传到服务端进行AI分析。</p>
<p>可见AI作业的流畅度维度评分、语速维度评分和AI分析报告中的关键词分析、口头禅分析、停顿分析都是建立在获得准确的ASR结果上的。所以构建一个准确可靠的语音识别服务是AI作业小节的基本要求，也是AI作业小节的分析准确度和用户满意度的关键。</p>
<h2 id="二、ASR存在的问题"><a href="#二、ASR存在的问题" class="headerlink" title="二、ASR存在的问题"></a>二、ASR存在的问题</h2><h3 id="2-1-热词-词库问题"><a href="#2-1-热词-词库问题" class="headerlink" title="2.1 热词&#x2F;词库问题"></a>2.1 热词&#x2F;词库问题</h3><p>ASR服务需要手工校准一些生僻专业词语的发音或同音词识别，这也就意味着需要ASR服务商提供词库&#x2F;热词功能，同时对不同的用户&#x2F;企业甚至每一次ASR识别过程都可能需要不同的热词。</p>
<p><strong>解决方案:</strong></p>
<p>针对CN、CO、COM&#x2F;TW&#x2F;IO 这三个环境平台，调研支持热词的服务商并测试效果。CN 采用了阿里听悟，CO采用了AmiVoice，COM&#x2F;TW&#x2F;IO 会采用微软。</p>
<h3 id="2-2-Socket连接稳定性问题"><a href="#2-2-Socket连接稳定性问题" class="headerlink" title="2.2 Socket连接稳定性问题"></a>2.2 Socket连接稳定性问题</h3><h4 id="2-2-1-并发控制"><a href="#2-2-1-并发控制" class="headerlink" title="2.2.1 并发控制"></a>2.2.1 并发控制</h4><p>目前采用的几家服务商对实时语音识别的技术方案都是使用Socket将录制采集的音频数据推流到厂商的服务端进行实时识别。每家厂商对并发数控制都是不同的，如果新的Socket请求达到最大并发数量会无法连接到服务商。（这个问题可以通过联系服务商提高并发数量上限来解决，但是并不能无限提高）。</p>
<h4 id="2-2-2-网络波动"><a href="#2-2-2-网络波动" class="headerlink" title="2.2.2 网络波动"></a>2.2.2 网络波动</h4><p>端上发起的Socket连接的稳定性是不可靠的容易受到短时通讯质量波动影响导致超时断连。</p>
<h4 id="2-2-3-断线重连问题"><a href="#2-2-3-断线重连问题" class="headerlink" title="2.2.3 断线重连问题"></a>2.2.3 断线重连问题</h4><p>由于流畅度以及停顿分析强依赖ASR返回的断句结果和Word偏移时间，断连之后重连的断句结果中的起始时间重置为0从而导致停顿分析和流畅度打分不准。并且服务商有并发数控制，重连也不一定能连上。</p>
<p>如果不考虑并发控制直接重连，本地维护录制的绝对时间，仅依赖ASR结果中的相对时间去拼接完整时间轴也是有问题的。因为ASR结果中存在整句和单词的断句，这个断句依赖连续的音频输入。如果服务断开连接后我们本地存储音频数据，重连后再次进行识别，这样拿到的结果的断句一定是错误的（一定会有物理中断的特征断句）。</p>
<p>所以Google Voice v1的识别一直存在一个问题，Google v1（iOS）目前会每60s中断重连一次，即使用户在此时间点无停顿，其识别结果也会在每个60s处都有一个断句。非连续的数据一定会出现异常的停顿，对结果影响非常大会导致流畅度分析不可用。后续会针对COM&#x2F;TW&#x2F;IO站点切换微软语音识别来解决这个问题。</p>
<h4 id="2-2-4-用户体验问题"><a href="#2-2-4-用户体验问题" class="headerlink" title="2.2.4 用户体验问题"></a>2.2.4 用户体验问题</h4><p>目前ASR发生了断连或不可用问题用户是较难感知的（只有文字识别是否显示的区别），并且直接影响此次录制的流畅度和语速评分（无数据会显示一团迷雾）。如果讲师开启了提交作业最低分限制会直接导致该次录制无法提交，用户回到”上传视频作业”流程比较远，可能会间接导致该次录制作废，业务主流程卡死，十分影响用户体验。</p>
<p><strong>解决方案</strong></p>
<p>考虑通过增加一些兜底的交互将出现ASR连接错误的作业从实时录制流程快速导向到上传流程。使用服务端异步分析为端上实时连接做一次兜底（用户如果对当次录制的作业比较满意可以选择直接提交到服务端走上传流程，如果不满意可能会自行重录）。</p>
<h2 id="三、优化方案"><a href="#三、优化方案" class="headerlink" title="三、优化方案"></a>三、优化方案</h2><h3 id="3-1-支持热词功能"><a href="#3-1-支持热词功能" class="headerlink" title="3.1 支持热词功能"></a>3.1 支持热词功能</h3><ul>
<li>中文：听悟 支持临时热词列表</li>
<li>日文：Ami 支持临时热词列表和热词词库</li>
<li>英文及其他：微软 支持临时热词</li>
</ul>
<p>当前支持以企业为维度配置热词列表，在服务端维护。未来可以支持以作业为维度配置热词列表。</p>
<h3 id="3-2-可观测性增强"><a href="#3-2-可观测性增强" class="headerlink" title="3.2 可观测性增强"></a>3.2 可观测性增强</h3><p>在往期的基础上丰富了日志上报：</p>
<ul>
<li>在常规的各个服务商Socket或者SDK的关键生命周期（初始化、开始识别、停止识别等）和返回错误信息的关键节点增加kibana日志上报</li>
<li>增加一个30s为周期的心跳日志，记录识别到的稳态结果文本长度，表示ASR服务仍然在正常运行</li>
</ul>
<h3 id="3-3-错误降级机制"><a href="#3-3-错误降级机制" class="headerlink" title="3.3 错误降级机制"></a>3.3 错误降级机制</h3><p>如上方断线的解决方案，增加检测到ASR报错时增加服务端兜底机制。</p>
<h3 id="3-4-支持切换站点和语言使用不同ASR服务"><a href="#3-4-支持切换站点和语言使用不同ASR服务" class="headerlink" title="3.4 支持切换站点和语言使用不同ASR服务"></a>3.4 支持切换站点和语言使用不同ASR服务</h3><h4 id="切换语言"><a href="#切换语言" class="headerlink" title="切换语言"></a>切换语言</h4><p>目前的技术方案已经支持根据不同站点的阿波罗配置下的根据语言下发ASR服务平台类型，APP根据对应的类型启动ASR服务。</p>
<h4 id="切换站点"><a href="#切换站点" class="headerlink" title="切换站点"></a>切换站点</h4><p>当前iOS项目中ASR服务按照包来区分，每个站点引入的SDK是不同的：</p>
<ul>
<li>CN包：阿里，AMi</li>
<li>CO包：AMi，Google，微软</li>
<li>COM包：AMi，Google，微软</li>
</ul>
<p>有些SDK因为合规问题不可以接入特定包，如711只有Google ASR。</p>
<p>UASR、腾讯、AMI、微软这四个ASR服务支持切换站点，根据对应站点下发的类型即可调起对应的服务。</p>
<p>在CN包还保留了阿里ASR兜底，别的包使用微软ASR兜底。如果下发的ASR服务在当前包是缺失的则会使用兜底。</p>
<p>iOS会在2024.10尝试将不同站点用到的ASR SDK全部引入当前包中，实现切换站点就可以切换服务的功能（安卓已经合并到一个包中）。</p>
<p>风险点在于新引入腾讯ASRSDK加引入多个SDK会使包体积增大，但经测试合并前后包体积基本无影响。</p>
<h2 id="四、日志设计"><a href="#四、日志设计" class="headerlink" title="四、日志设计"></a>四、日志设计</h2><p>ASR服务提升可观测性，在以下生命周期进行日志监测。所有ASR的日志都以<strong>UMUASRService</strong>为key，在kibana搜索这个key过滤ASR问题。</p>
<h3 id="4-1-准备阶段"><a href="#4-1-准备阶段" class="headerlink" title="4.1 准备阶段"></a>4.1 准备阶段</h3><p>获取ASR配置失败时会上报 refreshASRGlobalConfig fail</p>
<h3 id="4-2-启动服务"><a href="#4-2-启动服务" class="headerlink" title="4.2 启动服务"></a>4.2 启动服务</h3><ul>
<li>buildASRService的时候打一次日志，携带服务端下发的平台类型</li>
<li>初始化服务失败会打一次日志，不同Service根据SDK初始化方式打的时机不同</li>
<li>buildASRService完成后打一次日志，携带APP实际采用的ASR类型（根据类名区分）</li>
</ul>
<h3 id="4-3-服务进行中"><a href="#4-3-服务进行中" class="headerlink" title="4.3 服务进行中"></a>4.3 服务进行中</h3><ul>
<li>正常场景：在收到稳态识别结果后每30s上报一次ASR服务心跳日志，携带当次识别结果的文本长度。增加心跳的目的是监控ASR服务是否正常持续运行</li>
<li>异常场景：收到ASR服务商SDK、Server回调的错误上报错误代码和信息日志</li>
</ul>
<h3 id="4-4-服务结束"><a href="#4-4-服务结束" class="headerlink" title="4.4 服务结束"></a>4.4 服务结束</h3><p>打一次结束日志</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>性能优化</tag>
        <tag>架构设计</tag>
        <tag>asr</tag>
        <tag>语音识别</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS签名机制</title>
    <url>/2022/11/05/iOS%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="iOS签名机制"><a href="#iOS签名机制" class="headerlink" title="iOS签名机制"></a>iOS签名机制</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在iOS开发中，配置证书总是一件繁琐的工作，网上的教程有很多，基本都是手把手的教操作，但是如果不了解为什么要配置这些东西，对配置流程就不会有深刻的印象。</p>
<p>配置证书最大的作用就是保证安全性，安全性主要表现在以下的几个方面：</p>
<p>1.保证苹果手机下载的App是从<strong>苹果官网认证</strong>的途径下载</p>
<p>2.保证App在苹果官方注册过的设备上运行</p>
<p>3.保证App在特定的设备中运行（开发需要）</p>
<h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p>苹果采用的是<strong>数字签名</strong>进行加密，它是基于<strong>非对称加密算法和摘要算法</strong>实现的，和对称加密算法不同的是**，**对称加密通过同一份密钥加密和解密数据，而非对称加密有两个密钥，分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密；用私钥加密的数据，要用公钥才能解密。这里的非对称加密就是我们熟知的RSA，想要深入理解的童鞋可以自主了解。</p>
<p>为了更好的理解非对称加密的好处，我举一个场景例子：A要发送邮件给B，这个过程中要确保在传输中邮件内容没有被篡改，也就是只有B可以查看邮件的内容；还要确保这个邮件是A发送过来的，不是其他人发送的。我们用非对称加密的方式来处理：首先存A和B各有一对公私钥，A持有他自己的私钥和B的公钥，B持有A的公钥和B的私钥，公钥一般是给别人的，私钥在自己手里。A先用B的公钥给邮件加密，这样这个邮件只能被B的私钥解开，保证在传输过程中不会被篡改；A用自己的私钥将邮件加密，B要用A的公钥将邮件解密，来确保这是A发送过来的。这就是双向验证。</p>
<h2 id="基于iOS开发的签名机制"><a href="#基于iOS开发的签名机制" class="headerlink" title="基于iOS开发的签名机制"></a>基于iOS开发的签名机制</h2><h3 id="从App-Store安装App"><a href="#从App-Store安装App" class="headerlink" title="从App Store安装App"></a>从App Store安装App</h3><p>这个签名的方式相对简单，只需要验证App是从AppStore上下载的即可。苹果官方生成一对公私钥，在苹果设备上内置一个公钥，私钥由后台保管，我们上传App到AppStore时，苹果后台用私钥对App进行签名，设备在在App包后，用内置公钥验证签名。</p>
<p>思考：每个设备和苹果后台都有对应的一对公私钥还是只有一对公私钥，每个设备的公钥都是一样的，如果是前者，给App用私钥加密的时候是什么时候？</p>
<p><strong>结论：所有苹果设备上的公钥都是一样的。</strong></p>
<h3 id="其他方式安装App"><a href="#其他方式安装App" class="headerlink" title="其他方式安装App"></a>其他方式安装App</h3><ul>
<li>通过Xcode将App运行在设备上，调试用</li>
<li>企业内部分发，可以直接安装企业证书签名后的App</li>
<li>AD-Hoc相当于企业分发的限制版，限制安装设备数量</li>
</ul>
<p>以上几种场景就比较复杂了，我们需要确保这个App包的来源是苹果官方认证的，还要指定设备信息（不能随便的苹果设备都可以运行）。在了解这些场景的签名过程之前我们先思考一些问题：</p>
<p>1.App包不能上传到App Store上进行私钥加密了，需要通过其他介质间接验证；</p>
<p>2.iPhone上只有一个公钥可用，如何验证这么多信息；</p>
<p>3.如何限制设备、权限等额外信息。</p>
<p>我们需要除了App包以外的信息来进行验证，就是各种加密之后的文件，所以我们需要配置很多的证书。</p>
<h3 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h3><p>1.在mac上生成一对公私钥，公钥M，私钥M，苹果后台和苹果设备有一对公私钥，公钥A，私钥A。</p>
<p>2.将公钥M上传到苹果后台，用苹果后台的私钥A签名公钥M得到了公钥M的签名，代称hashM(私A)，hashM(私A)和公钥M组成的数据称为<strong>证书</strong>。（证书携带苹果官方认证信息，需要和App到达设备上）</p>
<p>3.开发完成后，用私钥M对App进行签名，同时将证书一起打包进App中，安装到手机。</p>
<p>4.安装时，iOS系统获得证书，用公钥A验证hashM(私A），得到的信息和证书中的公钥是否一致。</p>
<p><strong>以上的流程可以完成验证App是否经过了苹果官方认可的需求，没有解决滥用的问题。<strong>这里的滥用问题包括任何App都可以用这个证书在任何设备上安装运行，这是不允许的。我们可以把这些限制信息如AppID、设备ID等和证书</strong>再用私钥A进行加密</strong>，在最后的iOS系统验证的时候就可以判断这些限制数据是否符合要求。可以理解为又进行了一次加密。得到的数据就是我们知道的<strong>Provisioning file</strong>，Provisioning file里面就包含了证书和以上提到的额外信息，以及所有信息的签名。</p>
<p>在编译一个App后，用本地的的私钥M对这个App进行签名，同时把Provisioning file文件打包到App中，文件名为embeded.mobileprovision，把App安装到手机上。以上的过程就是加密的过程，看起来加密了很多层，让我们来梳理一下：</p>
<p><img src="https://cdn.zcx.info/1553500434698-48c63da0-2fac-490f-9b24-a5944fb17ae8.png"></p>
<h2 id="配置证书简要流程"><a href="#配置证书简要流程" class="headerlink" title="配置证书简要流程"></a>配置证书简要流程</h2><h3 id="请求根证书"><a href="#请求根证书" class="headerlink" title="请求根证书"></a>请求根证书</h3><p>在mac上生成一对公私钥，并将公钥上传到苹果后台，用苹果后台的私钥加密mac公钥，得到证书</p>
<p>CSR生成一对公私钥，私钥始终在Mac OS的Keychain Access中，用于签名（CodeSign）对外发布的App，公钥一般随着证书（随Provisioning Profile，随App）散布出去，对App签名进行校验认证。用户要保护好本地Keychain中的private key。</p>
<p>创建CSR文件：打开钥匙串-&gt;证书助理-&gt;从证书颁发机构请求证书。注：CRS文件是Cerificate Signing Request的英文缩写，即证书请求文件，<strong>CerificateSigningRequest就是本地公钥，.p12就是本地私钥，可以导入其他电脑，同时其他电脑也应该安装下载下来的证书。所以这一步团队开发人员很少操作。</strong></p>
<h3 id="添加设备"><a href="#添加设备" class="headerlink" title="添加设备"></a>添加设备</h3><p>苹果严格限制了真机调试的设备，如果需要真机调试需要在<a href="https://developer.apple.com/account/resources/devices/list">开发者后台</a>添加测试机的UDID</p>
<p><img src="https://cdn.zcx.info/202302211647247.png"></p>
<h3 id="新增描述文件"><a href="#新增描述文件" class="headerlink" title="新增描述文件"></a>新增描述文件</h3><p>描述文件(Provisioning Profile)是一个记录了你这个App的功能和权限的证书。</p>
<p>一般会用到以下三种：</p>
<p><strong>develop:调试证书，包含调试信息，安装时需要证书已加入设备UDID或者越狱设备才能安装。</strong></p>
<p><strong>distribution：正式证书，屏蔽了调试信息，发布到AppStore所用。</strong></p>
<p><strong>ad-hoc：测试证书，需要给别人测试用到，允许用户从第三方下载应用，如蒲公英。</strong></p>
<h2 id="刷新证书及描述文件"><a href="#刷新证书及描述文件" class="headerlink" title="刷新证书及描述文件"></a>刷新证书及描述文件</h2><p>一般在重新请求根证书之后需要更新所有的描述文件内的根证书配置。</p>
<p>根证书和证书对应的私钥都需要有人进行维护(或者使用fastlane维护)，在团队新增成员、设备时需发放到对应的机器中的钥匙串内，否则无法进行构建和上传IPA。</p>
<p>描述文件更新后需要在Xcode的User设置中找到开发者刷新一下Profile，或者到Profile的保存文件夹内清空重新下载，以避免描述文件更新不及时问题导致CI&#x2F;CD构建失败。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS编译优化方案探索与实践-组件篇</title>
    <url>/2021/09/18/iOS%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%BB%84%E4%BB%B6%E7%AF%87/</url>
    <content><![CDATA[<h1 id="iOS编译优化方案探索与实践-组件篇"><a href="#iOS编译优化方案探索与实践-组件篇" class="headerlink" title="iOS编译优化方案探索与实践-组件篇"></a>iOS编译优化方案探索与实践-组件篇</h1><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>目前主流的项目构建方案中几乎都使用cocoapods进行组件库管理，不论是第三方开源库还是自研的私有库，都会生成.podspec文件使用cocoapods工具进行维护。</p>
<p>为了便于进行调试，第三方开源库或私有代码库 我们都以源码的方式进行引入。</p>
<p>每次在本机进行全量编译或者ci机器进行打包的时候都会先编译pod仓库中的源代码，然后链接到主项目中。</p>
<p>这个流程没有问题，但是随着项目的的大量迭代和长时间维护，引入的仓库会越来越多。以我们的项目为例，项目迭代了3年左右，引入的第三方仓库达到了30+个。在我的mac上进行一次全量编译时间达到了500s，性能稍差的设备编译消耗的时间更长。</p>
<p>针对组件库的编译时长的优化方案很简单，把cocoapods仓库中引入的需要编译的源码改成不需要编译的二进制库即可。</p>
<p>当然一刀切的引入方式切换是不可取的，根据自身的实际情况，对一些基本不会进入调试的代码和一些稳定版本的常用的仓库进行二进制化较为合适。</p>
<p>针对以上想法有了一些cocoapods插件可以使用。</p>
<h3 id="Cocoapods-Binary"><a href="#Cocoapods-Binary" class="headerlink" title="Cocoapods-Binary"></a>Cocoapods-Binary</h3><p>cocoapods 1.6.x版本的时候常用的一个仓库，大家可能都用过，其思路是在cocoapods进行install操作时通过将 dependencies 预编译成 binary 后缓存至本地，然后将原有的 Source Code link 到 binary 以几乎零成本的方式实现编译效率的提高。</p>
<p>也就是说在pod install的过程中先进行预编译，预编译之后每次pod install都将编译完的二进制link到项目，这样就完成了源码到二进制的转化。</p>
<p>规模较小的团队非常适合这种方案，没有什么额外的成本，成员协作之间也不会产生冲突，通过简单的 :binary &#x3D;&gt; true指令即可设置仓库的二进制和源码的切换。</p>
<blockquote>
<p>但是目前这个库不再维护了，同时在swift方面也存在着一些问题<br>由于 CocoaPods 在 1.7.x 以上版本，修改了 framework 生成逻辑，不会把 bundle copy 至 framework，因此我们需要将 Pod 环境固定到 1.6.2<br>pod 要支持 binary，header ref 需要变更为 #import &lt;&gt;或者 @import 以符合 moduler 标准<br>统一 CI 和开发的 compiler 环境，如果项目支持 Swift，不同 compiler 编译产物有 Swift 版本兼容问题<br>最终的 binary size 会比使用源码的时候大一点，不建议最终上传 Store<br>建议 Git ignore Pods 文件夹，否则在 source code 与 binary 切换过程会有大量的 file change，增加 git 负担<br>—引用自<a href="https://juejin.cn/post/6844904025624674311">浅析 Cocoapods-Binary 实现</a></p>
</blockquote>
<h3 id="cocoapods-imy-bin"><a href="#cocoapods-imy-bin" class="headerlink" title="cocoapods-imy-bin"></a>cocoapods-imy-bin</h3><p>cocoapods-imy-bin 插件是美柚团队开源的cocoapods二进制管理方案。</p>
<p>其核心思想是先制作二进制文件，然后上传到文件服务器进行保存，在pod install 阶段动态判断三方库是否在本地私有源有二进制记录，如果有就会将此库的源替换成二进制源然后下载二进制文件，进而link到项目中完成源码和二进制的切换。</p>
<p><a href="https://juejin.cn/post/6903407900006449160#heading-3">iOS编译速度如何稳定提高10倍以上之一</a></p>
<p><a href="https://juejin.cn/post/6903408514778497031#heading-1">iOS编译速度如何稳定提高10倍以上之二</a></p>
<p>所谓实践出真知，咱就试一试看看效果。</p>
<h3 id="cocoapods-imy-bin实践"><a href="#cocoapods-imy-bin实践" class="headerlink" title="cocoapods-imy-bin实践"></a>cocoapods-imy-bin实践</h3><p><a href="https://github.com/MeetYouDevs/cocoapods-imy-bin/blob/master/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.md">cocoapods-imy-bin使用教程</a></p>
<p><a href="https://github.com/su350380433/cocoapods-imy-bin-demo">cocoapods-imy-bin-demo工程</a></p>
<p><a href="https://github.com/su350380433/binary-server">binary-server 静态资源服务器</a></p>
<p>按照使用教程开始操作：</p>
<h4 id="1、首先创建二进制仓库私有源"><a href="#1、首先创建二进制仓库私有源" class="headerlink" title="1、首先创建二进制仓库私有源"></a>1、首先创建二进制仓库私有源</h4><p>可以选择私有的github&#x2F;gitlab仓库，这个仓库负责二进制源cocoapods repo的维护。</p>
<p>添加到本地repo</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod repo add example_spec_bin_dev git<span class="variable">@github</span>.<span class="symbol">com:</span>su350380433/example_spec_bin_dev.git</span><br></pre></td></tr></table></figure>

<p>坑点：cocoapods-imy-bin配置私有源时只支持ssh，因此要修改以前的https的源，对ssh操作不熟练的需要google出现的问题及解决方案。</p>
<blockquote>
<p><a href="mailto:&#103;&#x69;&#116;&#x40;&#120;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;">git@xxx.com</a> ssh一直报错，之前的公钥有密码,通过ssh连接私有库的时候一直报错让输入密码，但是输入之后还是不行,报错无授权,重新生成rsa秘钥对之后尝试还是不行，报同样的错误。最后发现是git地址没有给对，从cocoapods file中拷贝出来的时候带了一个source字符串，所以ssh授权一直失败（地址都错了授权肯定失败啊）</p>
</blockquote>
<p>创建repo不能仅仅拉一个git仓库就行了，还得找一个已有的仓库进行.podspec文件push ，否则添加此源之后 执行pod repo update 会一直失败。</p>
<blockquote>
<p>新增空的pod repo 之后 pod repo update 一直失败,尝试push一次已有的.podspec文件再更新repo才成功</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pod push 命令</span></span><br><span class="line">pod repo push demo_binary_source <span class="title class_">APPLog</span>.podspec --allow-warnings</span><br></pre></td></tr></table></figure>


<h4 id="2、搭建静态资源服务器"><a href="#2、搭建静态资源服务器" class="headerlink" title="2、搭建静态资源服务器"></a>2、搭建静态资源服务器</h4><p>本质是一个可以接收和下载文件的服务器，使用Node承载服务，使用MongoDB存储数据。 可自行选择ECS或者其他文件服务器，做测试的话可以在本地搭建。</p>
<p>先搭建数据库(Mac)</p>
<p>文档上MongoDB是在官网下载安装的，但是实测有很多文件夹权限问题，改用homebrew安装。<br>brew install mongodb 命令失效，且官网不再开源，这里改用homebrew的社区版。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">brew tap mongodb/brew <span class="comment">#先执行这个</span></span><br><span class="line">brew install mongodb-community<span class="variable">@4</span>.<span class="number">2</span> <span class="comment">#等一小会执行这个 安装4.2版本的 </span></span><br></pre></td></tr></table></figure>
<p>安装完毕后需要设置环境变量才能使用，根据终端使用的zsh还是bash各自在配置文件设置</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">export <span class="variable constant_">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:/usr/local/Cellar/mongodb-community</span><span class="variable">@4</span>.<span class="number">2</span>/<span class="number">4.2</span>.<span class="number">9</span>/bin</span><br></pre></td></tr></table></figure>
<p>安装完毕后测试结果，然后使用Mac系统服务的方式打开数据库，这样不用依托终端窗口，即使终端窗口关闭了数据库也不会关闭。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">mongod -version <span class="comment">#测试是否安装成功</span></span><br><span class="line"><span class="comment">#除了安装包文件，安装还创建了以下文件和目录：</span></span><br><span class="line"><span class="comment">#配置文件（/usr/local/etc/mongod.conf）</span></span><br><span class="line"><span class="comment">#日志目录（/usr/local/var/log/mongodb）</span></span><br><span class="line"><span class="comment">#数据目录（/usr/local/var/mongodb）</span></span><br><span class="line"><span class="comment">#将MongoDB作为系统服务启动 不再依托终端窗口</span></span><br><span class="line">brew services start mongodb-community<span class="variable">@4</span>.<span class="number">2</span> /<span class="regexp">/启动</span></span><br><span class="line"><span class="regexp">brew services stop mongodb-community@4.2 /</span><span class="regexp">/停止</span></span><br><span class="line"><span class="regexp">brew services restart mongodb-community@4.2 /</span><span class="regexp">/重启</span></span><br></pre></td></tr></table></figure>
<p>也可以执行mongo shell命令查看数据库启动状态</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.zcx.info/008i3skNly1gukuhvxnh2j613i0u0gr602.jpg" alt="mongodb启动shell"></p>
<p>到这里 你的数据库就搭好了也启动起来了。</p>
<p>然后搭建静态资源服务器</p>
<p>先下载服务源码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>su350380433/binary-server.git</span><br><span class="line">cd /binary-server <span class="comment">#进入到你下载binary-server的根目录去</span></span><br><span class="line">npm install <span class="comment">#安装依赖包</span></span><br><span class="line">npm start <span class="comment"># 启动node</span></span><br></pre></td></tr></table></figure>
<p>这是文件服务器App.js源码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./server/routes&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;koa-logger&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">&#x27;koa-body&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span></span><br><span class="line"></span><br><span class="line">mongoose.<span class="title function_">connect</span>(<span class="string">&#x27;mongodb://localhost/binary_database&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">koaBody</span>(&#123; <span class="attr">multipart</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">logger</span>())</span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>())</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<p>由此可见，文件服务器创建了binary_database数据库，并且占用了8080端口。</p>
<p>执行了npm start之后可能会出现两个问题</p>
<p>8080端口已经被占用：出现这个问题有可能是你之前安装过其他服务也占用这个端口，可以切换静态资源文件的使用端口修改app.listen(8080)即可，或者和我一样直接把不用的其他服务关掉。</p>
<p>数据库连接失败：出现这个问题可以看一下具体的报错内容，根据不同的内容处理。如果出现</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">getaddrinfo <span class="variable constant_">ENOTFOUND</span> localhost     at <span class="title class_">GetAddrInfoReqWrap</span>.onlookup</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样的报错的话很可能是你的设备没有做localhost的127.0.0.1的映射。db使用的链接是ip地址，但是静态资源服务中的代码里连接数据库使用的是localhost，且端口是db的默认端口，如果你数据库改过端口号，那这里一定要修改数据库连接地址。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; binary-server<span class="variable">@0</span>.<span class="number">1.0</span> start /<span class="title class_">Users</span>/zcx/binary-server</span><br><span class="line">&gt; node app.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果一切顺利，这里node服务器就启动起来了，监听8080(或你设置的)端口，提供http服务。</p>
<h4 id="3-安装和初始化cocoapods-imy-bin插件"><a href="#3-安装和初始化cocoapods-imy-bin插件" class="headerlink" title="3 安装和初始化cocoapods-imy-bin插件"></a>3 安装和初始化cocoapods-imy-bin插件</h4><p>安装这一步比较简单 直接执行gem命令安装插件即可</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">sudo gem install cocoapods-imy-bin</span><br></pre></td></tr></table></figure>
<p>初始化插件配置：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">xx:</span><span class="title class_">Demo</span> slj<span class="variable">$ </span>pod bin init <span class="comment">#执行这个命令 根据提示信息进行下一步的操作</span></span><br><span class="line"></span><br><span class="line">======  dev 环境 ========</span><br><span class="line"></span><br><span class="line">开始设置二进制化初始信息.</span><br><span class="line">所有的信息都会保存在 /<span class="title class_">Users</span>/slj/.cocoapods/bin_dev.yml 文件中.</span><br><span class="line"><span class="string">%w[bin_dev.yml bin_debug_iphoneos.yml bin_release_iphoneos.yml]</span> </span><br><span class="line">你可以在对应目录下手动添加编辑该文件. 文件包含的配置信息样式如下：</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="symbol">configuration_env:</span> dev</span><br><span class="line"><span class="comment"># 上面这个是环境切换选项 先不改 目前先配一套环境</span></span><br><span class="line"><span class="symbol">code_repo_url:</span> git<span class="variable">@github</span>.<span class="symbol">com:</span>su350380433/example_spec_source.git</span><br><span class="line"><span class="comment"># 上面这个是正在使用的私有源地址</span></span><br><span class="line"><span class="symbol">binary_repo_url:</span> git<span class="variable">@github</span>.<span class="symbol">com:</span>su350380433/example_spec_bin_dev.git</span><br><span class="line"><span class="comment"># 上面这个是新增的二进制私有源地址</span></span><br><span class="line"><span class="symbol">binary_download_url:</span> <span class="symbol">http:</span>/<span class="regexp">/localhost:8080/frameworks</span><span class="regexp">/%s/</span>%s/zip</span><br><span class="line"><span class="comment"># 上面这个是新创建的服务器地址 默认使用的本地 %s是动态替换三方库的名称的 这里不要改</span></span><br><span class="line"><span class="symbol">download_file_type:</span> zip</span><br><span class="line"><span class="comment"># 上面这个是二进制传输用的压缩格式 一般都zip也不用改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上的配置都可以在配置文件里进行更改</span></span><br><span class="line">open /<span class="title class_">Users</span>/zcx/.cocoapods/bin_dev.yml  <span class="comment">#文件保存 插件的配置信息</span></span><br></pre></td></tr></table></figure>
<p>到这里准备工作就算是就绪了，可以开始制作二进制文件了。</p>
<h4 id="4-制作二进制文件"><a href="#4-制作二进制文件" class="headerlink" title="4 制作二进制文件"></a>4 制作二进制文件</h4><p>想要制作一系列的三方库二进制组件，必须得有个文件存储三方库的列表吧，所以这里还得准备一个.podspec文件来维护你想要制作的库。</p>
<p>在项目根目录新增一个<code>demo_binary_source.podspec</code>文件,内容如下（一个基本的依赖文件）</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MARK: converted automatically by spec.py. <span class="doctag">@hgy</span></span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Pod::Spec</span>.new <span class="keyword">do</span> |<span class="params">s</span>|</span><br><span class="line">	s.name = <span class="string">&#x27;demo_binary_source&#x27;</span></span><br><span class="line">	s.version = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">	s.description = <span class="string">&#x27;demo_binary_source&#x27;</span></span><br><span class="line">	s.license = <span class="string">&#x27;MIT&#x27;</span></span><br><span class="line">	s.summary = <span class="string">&#x27;demo_binary_source&#x27;</span></span><br><span class="line">	s.homepage = <span class="string">&#x27;https://gitlab-media.corp.demo.com/iOS/krmedium_binary_source&#x27;</span></span><br><span class="line">	s.authors = &#123; <span class="string">&#x27;zcx&#x27;</span> =&gt; <span class="string">&#x27;zhouchuanxiang@demo.com&#x27;</span> &#125;</span><br><span class="line">	s.source = &#123; <span class="symbol">:git</span> =&gt; <span class="string">&#x27;git@gitlab-media.corp.demo.com:iOS/krmedium_binary_source.git&#x27;</span>, <span class="symbol">:branch</span> =&gt; <span class="string">&#x27;master&#x27;</span> &#125;</span><br><span class="line">        s.requires_arc = <span class="literal">true</span></span><br><span class="line">        s.ios.deployment_target = <span class="string">&#x27;11.0&#x27;</span></span><br><span class="line">        s.source_files = <span class="string">&#x27;Source/**/*.&#123;h,m,c,swift&#125;&#x27;</span></span><br><span class="line">        s.public_header_files = <span class="string">&#x27;Source/**/*.&#123;h,swift&#125;&#x27;</span></span><br><span class="line">        <span class="comment">#objc依赖</span></span><br><span class="line">        s.dependency <span class="string">&#x27;Masonry&#x27;</span>, <span class="string">&#x27;1.1.0&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;MJRefresh&#x27;</span>, <span class="string">&#x27;3.3.1&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;SDWebImage&#x27;</span>, <span class="string">&#x27;5.3.1&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;YYCategories&#x27;</span>, <span class="string">&#x27;1.0.4&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;MJExtension&#x27;</span>, <span class="string">&#x27;3.2.2&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;MBProgressHUD&#x27;</span>, <span class="string">&#x27;1.1.0&#x27;</span></span><br><span class="line">        <span class="comment">#demo项目依赖</span></span><br><span class="line">        s.dependency <span class="string">&#x27;KeychainAccess&#x27;</span>, <span class="string">&#x27;4.1.0&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;Moya/RxSwift&#x27;</span>, <span class="string">&#x27;13.0.1&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;ObjectMapper&#x27;</span>, <span class="string">&#x27;3.4.2&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;IQKeyboardManagerSwift&#x27;</span>, <span class="string">&#x27;6.5.1&#x27;</span> <span class="comment">#键盘管理</span></span><br><span class="line">        s.dependency <span class="string">&#x27;RTRootNavigationController&#x27;</span>, <span class="string">&#x27;0.5.19&#x27;</span> <span class="comment">#UI</span></span><br><span class="line">        s.dependency <span class="string">&#x27;Kingfisher&#x27;</span>, <span class="string">&#x27;5.15.4&#x27;</span> <span class="comment">#图片处理</span></span><br><span class="line">        s.dependency <span class="string">&#x27;Zip&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;SnapKit&#x27;</span>, <span class="string">&#x27;5.0.1&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;Stencil&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;iCarousel&#x27;</span>, <span class="string">&#x27;1.8.3&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;YYText&#x27;</span>, <span class="string">&#x27;1.0.5&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;lottie-ios&#x27;</span>, <span class="string">&#x27;3.1.9&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;YYCache&#x27;</span>, <span class="string">&#x27;1.0.4&#x27;</span></span><br><span class="line">        <span class="comment">#debug调试工具</span></span><br><span class="line">        s.dependency <span class="string">&#x27;NetSwitch&#x27;</span></span><br><span class="line">        s.dependency <span class="string">&#x27;LookinServer&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>文件中所有的<code>dependency</code>依赖都会被尝试制作二进制文件。制作二进制文件之前需要保证所有的<code>repo</code>都是正常的，每个三方库的源都指向原始源（源代码源），我们制作的时候会先获取源码进行编译。<br>把这个文件放在和<code>Podfile</code>同一个目录下，进入此目录，然后执行</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod bin auto --all-make <span class="comment"># 开始制作二进制</span></span><br></pre></td></tr></table></figure>
<p>这个过程可能会根据你依赖的库报各种错误，比如我遇到的</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Installing</span>...</span><br><span class="line"><span class="title class_">Installing</span> <span class="title class_">Realm</span> (<span class="number">3.19</span>.<span class="number">0</span>)</span><br><span class="line"><span class="title class_">Installing</span> <span class="title class_">RealmSwift</span> (<span class="number">3.19</span>.<span class="number">0</span>)</span><br><span class="line"><span class="title class_">Installing</span> demo_binary_source (<span class="number">1</span>)</span><br><span class="line">[!] /bin/bash -c</span><br><span class="line">set -e</span><br><span class="line">sh build.sh cocoapods-setup</span><br><span class="line"></span><br><span class="line"><span class="symbol">sh:</span> build.<span class="symbol">sh:</span> <span class="title class_">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行pod bin auto --all-make 报错 不知道啥原因</span></span><br><span class="line"><span class="comment">#经排查 使用插件后 swiftRealm库附带的下载依赖脚本无法执行</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Running</span> prepare command</span><br><span class="line"><span class="variable">$ </span>/bin/bash -c  set -e sh build.sh cocoapods-setup</span><br><span class="line"><span class="title class_">Downloading</span> <span class="symbol">dependency:</span> <span class="number">10.3</span>.<span class="number">2</span> from <span class="symbol">https:</span>/<span class="regexp">/static.realm.io/downloads</span><span class="regexp">/core/realm</span>-monorepo-xcframework-v10.<span class="number">3.2</span>.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方案</span></span><br><span class="line">单独的库无法处理，这里因为<span class="string">&#x27;Realm&#x27;</span>编译源码也很慢，所以改成<span class="string">&#x27;xcframework&#x27;</span>方式进行引入了。</span><br><span class="line">解决问题的过程中可能遇见<span class="string">&#x27;pod repo&#x27;</span>混乱的问题，</span><br><span class="line">之前尝试的 <span class="string">&#x27;--all-make&#x27;</span>命令 生成了一部分二进制和<span class="string">&#x27;repo&#x27;</span>信息引起混乱</span><br><span class="line">那就全部删掉，删掉<span class="string">&#x27;repo&#x27;</span>源，删掉已经上传的二进制文件从头再来一遍 </span><br></pre></td></tr></table></figure>
<p>解决完问题后再尝试进行二进制文件制作。如果顺利的话会看到制作结果。</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gukvojcuwpj60u015rjxk02.jpg"></p>
<p>同时可以检验一下新创建的 私有源中是否记录的二进制文件的地址信息。</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gukvrtyptvj61h30u0td202.jpg"></p>
<p>二进制文件制作好了，就差link到项目中了。</p>
<p>既然我们更新了私有源，这里最好把<code>cocoapods repo </code>更新一下再安装。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod repo update --verbose <span class="comment">#更新源</span></span><br><span class="line">pod install --verbose <span class="comment">#你懂得</span></span><br><span class="line"><span class="comment">#然后你会看到执行的结果，部分三方库被替换成了打包好的静态库</span></span><br><span class="line">======  dev 环境 ========</span><br><span class="line"><span class="variable constant_">CDN</span>: trunk <span class="title class_">Relative</span> <span class="symbol">path:</span> <span class="title class_">CocoaPods</span>-version.yml exists! <span class="title class_">Returning</span> local because checking is only performed <span class="keyword">in</span> repo update</span><br><span class="line">cocoapods-imy-bin 插件</span><br><span class="line">- 开始处理 <span class="title class_">Alamofire</span> <span class="number">4.9</span>.<span class="number">1</span> 组件.</span><br><span class="line">specification =<span class="title class_">Alamofire</span> (<span class="number">4.9</span>.<span class="number">1</span>)</span><br><span class="line">#&lt;Pod::Resolver::ResolverSpecification:0x00007fc8369c9630&gt;</span><br><span class="line">cocoapods-imy-bin 插件</span><br><span class="line">- 开始处理 <span class="title class_">AliPlayer</span>SDK_iOS <span class="number">5.4</span>.<span class="number">0</span> 组件.</span><br><span class="line">cocoapods-imy-bin 插件</span><br><span class="line">- 开始处理 <span class="title class_">AliPlayer</span>SDK_iOS/<span class="title class_">AliPlayer</span>SDK <span class="number">5.4</span>.<span class="number">0</span> 组件.</span><br><span class="line">cocoapods-imy-bin 插件</span><br><span class="line">- 开始处理 <span class="title class_">Alipay</span>SDK-iOS <span class="number">15.7</span>.<span class="number">9</span> 组件.</span><br><span class="line">cocoapods-imy-bin 插件</span><br><span class="line">- 开始处理 <span class="title class_">Bugly</span> <span class="number">2.5</span>.<span class="number">90</span> 组件.</span><br><span class="line">........</span><br><span class="line">#&lt;Pod::Resolver::ResolverSpecification:0x00007fc8370b0f48&gt;</span><br><span class="line">【<span class="title class_">AliPlayer</span>SDK_iOS |<span class="params"> 5.4.0】组件无对应二进制版本 , 将采用源码依赖.</span></span><br><span class="line"><span class="params">【AliPlayerSDK_iOS/AliPlayerSDK </span>| <span class="number">5.4</span>.<span class="number">0</span>】组件无对应二进制版本 , 将采用源码依赖.</span><br><span class="line">【<span class="title class_">Alipay</span>SDK-iOS |<span class="params"> 15.7.9】组件无对应二进制版本 , 将采用源码依赖.</span></span><br><span class="line"><span class="params">【Bugly </span>| <span class="number">2.5</span>.<span class="number">90</span>】组件无对应二进制版本 , 将采用源码依赖.</span><br><span class="line">【<span class="title class_">CocoaAsyncSocket</span> |<span class="params"> 7.6.5】组件无对应二进制版本 , 将采用源码依赖.</span></span><br><span class="line"><span class="params">【GTSDK </span>| <span class="number">2.5</span>.<span class="number">5.0</span>】组件无对应二进制版本 , 将采用源码依赖.</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>最后查看<code>xcode</code>中的<code>pod</code>文件夹，从源码切换成了<code>framework</code><br><img src="https://cdn.zcx.info/008i3skNly1gukw1ce7iej60kq0fmq3x02.jpg"><br>如果没有出现<code>framework</code>的话可以尝试再更新一次<code>pod repo </code>和<code>执行 pod install</code></p>
<p><code>clean</code> 一下进行全量编译可以看到变化，优化前编译需要500s</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gukw4a4ri8j61tc0lijvv02.jpg"></p>
<p>优化后<code>tasks</code>减少到2500左右</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gukw3brvajj60x0038gly02.jpg"></p>
<p>编译时间减少到300s</p>
<p><img src="https://cdn.zcx.info/008i3skNly1gukw38z5bdj60nu05eq3w02.jpg"></p>
<h4 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h4><p>暂时没有测试ci打包机上的命令修改和真正realse发包过程。如果要上生产环境的话需要进行大面积的覆盖测试。切记谨慎行事。</p>
<h3 id="拓展与思考"><a href="#拓展与思考" class="headerlink" title="拓展与思考"></a>拓展与思考</h3><p>组件库的编译时间减少较为可观，这也许是大家推行项目组件化的原因。随着业务的发展，项目会越来越大，业务拓展后也可能会划分更多的部门。</p>
<p>每个部门做自己的业务，不关注其他部门的代码。所以如果指定一定的代码规范，制作比如网络请求组件、路由组件等公用组件的基础上，每个业务部门输出自身的业务组件，使用<code>cocoapods</code>进行二进制化管理。代码整体的编译上就可以节省不少时间，提升编译效率，团队间合作也会降低一些成本。</p>
<p>未来我们的项目也可以考虑分割各个组件，总体做一个壳工程，采用组件化的方案进行代码维护。但是组件化任重而道远，还得得根据自身的实际情况来选择技术方案。组件化和其他设计模式一样，都是为了解决实际问题，不要为了设计而设计。</p>
<p>当然一些前瞻性的思考还是不能缺少的，未雨绸缪总好过于亡羊补牢！</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>技术调研</tag>
      </tags>
  </entry>
  <entry>
    <title>module importing failed invalid pathname 问题解决</title>
    <url>/2021/09/09/module-importing%20failed-invalid%20pathname/</url>
    <content><![CDATA[<p>最近Xcode编译完成后在命令行框里第一行总会报一个错误：</p>
<blockquote>
<p>error: module importing failed: invalid pathname</p>
</blockquote>
<p>不论是<code>clean</code>还是删除<code>support文件</code>还是<code>重启Xcode</code>都无法解决这个问题。</p>
<p>于是去google了一番：</p>
<p><a href="https://stackoverflow.com/questions/59800936/Xcode-11-shows-a-missing-module-error-when-compiling-python-3-8">把target的scheme中的debug executable的选项取消掉就不报这个错了</a></p>
<p><img src="https://raw.githubusercontent.com/zcx4u/images/master/Hexo/Xcode/008i3skNly1guaiuljmlhj60qi0gmwfh02.jpg" alt="关闭调试器"></p>
<p>试了一下，有效！但是这个选项不能去掉啊，去掉了这个选项就不能打断点进行调试了。😂</p>
<hr>
<p>Realm删除残留导致的问题？](<a href="https://stackoverflow.com/questions/59090655/removed-realm-but-still-getting-this-error-module-importing-failed-invalid-to/59094519#59094519?newreg=5c6ce4372354468b9449dfc34406e472">https://stackoverflow.com/questions/59090655/removed-realm-but-still-getting-this-error-module-importing-failed-invalid-to/59094519#59094519?newreg=5c6ce4372354468b9449dfc34406e472</a>)</p>
<p>看到朋友们删除Realm之后会出现这个问题，但是我又没有安装过Realm，为何也有这个问题呢。</p>
<p>回答中提到解决这个问题需要去编辑<code>~/.lldbinit</code>文件，看的我一脸懵逼，对于这种没见过的配置文件我可不敢去乱删乱改。又想起来被错改配置文件支配的恐惧，吃一堑长一智…</p>
<p>仔细看<code>lldbinit</code>文件命名，好像在哪见过，是LLDB调试器初始化的配置文件，于是在mac根目录下去找了找这个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个文件的全部内容</span><br><span class="line">### Reveal LLDB commands support - DO NOT MODIFY</span><br><span class="line">    command script import /Applications/Reveal.app/Contents/SharedSupport/Scripts/RevealServerCommands.py</span><br><span class="line">###</span><br></pre></td></tr></table></figure>
<p>当我看到<code>Reveal.app</code>这个东西的时候便明白是什么问题了，我这台mac之前下载过破解版的Reveal软件用来调试界面。</p>
<p><code>Reveal</code>的插件需要在LLDB启动的时候加载用来获取UI栈信息，后来改用了<code>Lookin</code>就把<code>Reveal</code>给卸载了，但是<code>.lldbinit</code>中的命令没有改掉。LLDB启动的时候找不到<code>Reveal插件</code>便会报<code>module importing failed: invalid pathname</code>错误。</p>
<p><img src="https://raw.githubusercontent.com/zcx4u/images/master/Hexo/Xcode/008i3skNly1guaium1xjzj60n805q74o02.jpg"></p>
<p>同时这也验证了为什么在Xcode中关闭调试就不报这个错了(那肯定是Xcode在debug模式下运行时自动启动了内置的LLDB调试器啦)。</p>
<p>为了验证是LLDB的问题我把Xcode关闭，打开了终端，输入LLDB命令，然后终端中也报出了相同的错误提示。为了更加理解这个文件的作用，我便又去搜索了一番.lldbinit的作用。</p>
<blockquote>
<p>~&#x2F;.lldbinit是每次LLDB启动时会加载的文件。所以一些初始化的事儿，我们可以写入其中中，比如给命令定义别名等。但是由于这时候程序还没有真正运行，也有部分操作无法在里面玩，比如设置断点。</p>
</blockquote>
<p>到此我解决了Xcode中每次启动都报错的问题，也明白了这个问题出现的原因，同时也了解到了LLDB相关的新知识。所以当看到一些莫名其妙的报错的时候不要着急也不要焦虑，一定是在你不熟悉的地方出现了异常，当你慢慢理解那些内容的时候，这些报错也许只是一个很小很小的问题。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>AI作业背景模糊实现技术方案</title>
    <url>/2024/11/29/iOS%E8%83%8C%E6%99%AF%E6%A8%A1%E7%B3%8A%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="iOS背景模糊实现技术方案"><a href="#iOS背景模糊实现技术方案" class="headerlink" title="iOS背景模糊实现技术方案"></a>iOS背景模糊实现技术方案</h1><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>晖致日本提出很多代表在家里录制AI作业，希望可以将背景模糊，保护代表隐私。</p>
<p>类似于腾讯会议的背景虚化功能，录制视频作业 的时候将背景模糊化，只保留用户人像区域。</p>
<h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p>业界对这个需求的实现方案基本一致。</p>
<p>首先录制过程中将视频帧做高斯模糊形成背景模糊中”背景”部分。</p>
<p>然后在实时的将每一帧图像中包含人像的部分“扣”出来形成一张黑白分明的灰度图（mask）。一般是人像区域为白色，非人像区域为黑色。</p>
<p>最后使用自定义三输入的滤镜，分别传入模糊后的背景视频帧+灰度mask图+原始视频帧，通过片元着色器对每一个像素点进行遴选。根据灰度图的颜色，白色取原始视频帧，黑色取模糊视频帧。</p>
<p>这样就形成了背景区域是模糊的，人像区域是正常的视频，达到要求。</p>
<p>在视频帧处理这方面我们采用项目中已经引入的GPUImage库来实现。</p>
<h3 id="人像分割"><a href="#人像分割" class="headerlink" title="人像分割"></a>人像分割</h3><p>这个抠图的技术我们称为人像分割，人像分割算法有很多种，常见的包括：基于颜色和纹理的方法、基于边缘检测的方法、基于深度学习的方法、基于图割的方法等。</p>
<p>目前这一步交由AI组伙伴提供基于TensorFlowLiteObjC的深度学习人像分割模型来实现。</p>
<h3 id="自研模型"><a href="#自研模型" class="headerlink" title="自研模型"></a>自研模型</h3><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><p>目前chaochao提供了2个模型。</p>
<p>128x128_fp32.tflite 支持输入128*128像素的图片</p>
<p>256x144_fp32.tflite 支持输入256*144像素的图片</p>
<p>核心识别代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;UGPortraitTFliteProcessor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UGPortraitTFliteProcessor</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) cv::Mat cachedMat; <span class="comment">// 缓存的一帧</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDictionary</span> *cachedOutput; <span class="comment">//缓存的一帧计算结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UGPortraitTFliteProcessor</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt; <span class="built_in">NSNumber</span> * &gt; *)getTensorShape &#123;</span><br><span class="line"><span class="built_in">CGSize</span> modelSize = <span class="keyword">self</span>.model.modelSize;</span><br><span class="line"><span class="built_in">NSNumber</span> *dimNum1 = [<span class="built_in">NSNumber</span> numberWithInt:modelSize.width];</span><br><span class="line"><span class="built_in">NSNumber</span> *dimNum2 = [<span class="built_in">NSNumber</span> numberWithInt:modelSize.height];</span><br><span class="line"><span class="built_in">NSArray</span>&lt; <span class="built_in">NSNumber</span> * &gt; *shape = @[ @<span class="number">1</span>, dimNum2, dimNum1, @<span class="number">3</span> ];</span><br><span class="line"><span class="keyword">return</span> shape;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (UGPortraitTFliteProcessor *)processor &#123;</span><br><span class="line"><span class="comment">// CGSize kTFliteModelSize = CGSizeMake(128, 128);</span></span><br><span class="line"><span class="built_in">CGSize</span> kTFliteModelSize = <span class="built_in">CGSizeMake</span>(<span class="number">256</span>, <span class="number">144</span>);</span><br><span class="line"><span class="built_in">NSBundle</span> *targetBundle = [<span class="built_in">NSBundle</span> bundleForClass:<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;UGPortraitTFliteProcessor&quot;</span>)];</span><br><span class="line"><span class="built_in">NSURL</span> *bundleUrl = [targetBundle URLForResource:<span class="string">@&quot;Detection&quot;</span> withExtension:<span class="string">@&quot;bundle&quot;</span>];</span><br><span class="line"><span class="built_in">NSBundle</span> *finalBundle = [<span class="built_in">NSBundle</span> bundleWithURL:bundleUrl];</span><br><span class="line"><span class="comment">// NSString *filePath = [finalBundle pathForResource:@&quot;128x128_fp32&quot; ofType:@&quot;tflite&quot;];</span></span><br><span class="line"><span class="built_in">NSString</span> *filePath = [finalBundle pathForResource:<span class="string">@&quot;256x144_fp32&quot;</span> ofType:<span class="string">@&quot;tflite&quot;</span>];</span><br><span class="line">UGTFliteModel *model = [UGTFliteModel modelWithPath:filePath size:kTFliteModelSize];</span><br><span class="line">UGPortraitTFliteProcessor *processor = [UGPortraitTFliteProcessor processorWithModel:model];</span><br><span class="line"><span class="keyword">return</span> processor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行推理</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)detectWithSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer orientation:(<span class="built_in">UIInterfaceOrientation</span>)orientation isMirror:(<span class="type">BOOL</span>)isMirror &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转成mat</span></span><br><span class="line">cv::Mat matOrigin = [UGTFliteUtil matFromCVPixelBuffer:<span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差值优化 如果两帧画面相差小于3% 则直接使用上一帧的结果(这里保持缓存的data和mat是成对的)</span></span><br><span class="line"><span class="keyword">if</span>([<span class="keyword">self</span> isCacheAvailable] &amp;&amp; [UGTFliteUtil isChangeMinimalWithCurrentFrame:matOrigin lastFrame:_cachedMat threshold:<span class="number">0.035</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.cachedOutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算原始size</span></span><br><span class="line"><span class="built_in">CGSize</span> sizeOrigin = orientation == <span class="built_in">UIInterfaceOrientationLandscapeRight</span> ? <span class="built_in">CGSizeMake</span>(matOrigin.cols, matOrigin.rows) : <span class="built_in">CGSizeMake</span>(matOrigin.rows, matOrigin.cols);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 镜像和orientation翻转</span></span><br><span class="line">cv::Mat matProcess = [UGTFliteUtil processMatWithOrientation:orientation isMirror:isMirror originMat:matOrigin];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放到模型接收的size， chaochao说这个模型不用等比缩放，可以拉伸变形进行推理，推理结果再反向拉伸获取即可</span></span><br><span class="line">cv::Mat mat;</span><br><span class="line">cv::resize(matProcess, mat, cv::Size(<span class="keyword">self</span>.model.modelSize.width, <span class="keyword">self</span>.model.modelSize.height));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意模型需求输入的是归一化二进制数据</span></span><br><span class="line"><span class="built_in">NSData</span> *imageData = [UGTFliteUtil normalizedFloat32ImageDataFromCVMat:mat]; <span class="comment">// 归一化处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模型开始执行推理</span></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line">[<span class="keyword">self</span>.interpreter resizeInputTensorAtIndex:<span class="number">0</span> toShape:[<span class="keyword">self</span> getTensorShape] error:&amp;error];</span><br><span class="line">TFLTensor *inputTensor = [<span class="keyword">self</span>.interpreter inputTensorAtIndex:<span class="number">0</span> error:&amp;error];</span><br><span class="line">[inputTensor copyData:imageData error:&amp;error];</span><br><span class="line">[<span class="keyword">self</span>.interpreter invokeWithError:&amp;error];</span><br><span class="line">TFLTensor *outputTensor = [<span class="keyword">self</span>.interpreter outputTensorAtIndex:<span class="number">0</span> error:&amp;error];</span><br><span class="line"><span class="built_in">NSData</span> *outputData = [outputTensor dataWithError:&amp;error];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续解析数据</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *resultDict = [<span class="keyword">self</span> detectWithTensorOutputData:outputData imageSize:sizeOrigin];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Error++: %@&quot;</span>, error);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">self</span>.cachedOutput = resultDict;</span><br><span class="line"><span class="keyword">self</span>.cachedMat = matOrigin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resultDict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 解析推理数据</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)detectWithTensorOutputData:(<span class="built_in">NSData</span> *)outputData imageSize:(<span class="built_in">CGSize</span>)imageSize &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算像素总数</span></span><br><span class="line"><span class="type">int</span> inputWidth = <span class="keyword">self</span>.model.modelSize.width;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> inputHeight = <span class="keyword">self</span>.model.modelSize.height;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num_pixels = inputHeight * inputWidth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意OpenCV 里面Mat的初始化是 高 * 宽 * 通道数</span></span><br><span class="line">cv::Mat out_mask(inputHeight, inputWidth, CV_8UC1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> *output = (<span class="keyword">const</span> <span class="type">float</span> *)outputData.bytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历每个像素并填充 out_mask 这个计算有问题的 实际是会有不同概率分布的数据 不是非0即1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_pixels; i++) &#123;</span><br><span class="line">out_mask.data[i] = (output[<span class="number">2</span> * i + <span class="number">1</span>] &gt; <span class="number">0.1</span>f) ? <span class="number">255</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 腐蚀 这个优化改为交给GPUImage处理 不再使用cv</span></span><br><span class="line"><span class="comment">// cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));</span></span><br><span class="line"><span class="comment">// cv::erode(outputMat, outputMat, element);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯模糊 进行边缘优化 这个优化改为交给GPUImage处理 不再使用cv</span></span><br><span class="line"><span class="comment">// cv::GaussianBlur(out_mask, out_mask, cv::Size(3, 3), 0, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mask图再放大</span></span><br><span class="line">cv::Mat outputMat;</span><br><span class="line">cv::resize(out_mask, outputMat, cv::Size(imageSize.width, imageSize.height));</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIImage</span> *outputImage = [UGTFliteUtil imageFromCVMat:outputMat];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> @&#123;<span class="string">@&quot;image&quot;</span>:outputImage, <span class="string">@&quot;imageWidth&quot;</span>:@(imageSize.width),<span class="string">@&quot;imageHeight&quot;</span>:@(imageSize.height)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isCacheAvailable &#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">self</span>.cachedMat.empty() &amp;&amp; <span class="keyword">self</span>.cachedOutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>核心渲染代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 背景模糊滤镜组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;GPUImage.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;GPUImageThreeInputFilter.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;UGImageBackgroundBlurFilter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> kUGImagePortraitMaskBlendFragmentShaderString = SHADER_STRING</span><br><span class="line">(</span><br><span class="line">precision highp <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line">varying highp vec2 textureCoordinate;</span><br><span class="line">varying highp vec2 textureCoordinate2;</span><br><span class="line">varying highp vec2 textureCoordinate3;</span><br><span class="line"></span><br><span class="line">uniform sampler2D inputImageTexture;</span><br><span class="line">uniform sampler2D inputImageTexture2;</span><br><span class="line">uniform sampler2D inputImageTexture3;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);</span><br><span class="line">vec4 blurredColor = texture2D(inputImageTexture2, textureCoordinate2);</span><br><span class="line">vec4 maskColor = texture2D(inputImageTexture3, textureCoordinate3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预乘Alpha</span></span><br><span class="line">baseColor.rgb *= baseColor.a;</span><br><span class="line">blurredColor.rgb *= blurredColor.a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 maskColor 的灰度值计算混合的透明度通道</span></span><br><span class="line"><span class="type">float</span> maskValue = dot(maskColor.rgb, vec3(<span class="number">0.299</span>, <span class="number">0.587</span>, <span class="number">0.114</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平滑处理边界像素值</span></span><br><span class="line"><span class="type">float</span> smoothMaskValue = smoothstep(<span class="number">0.0</span>, <span class="number">1.0</span>, maskValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合颜色</span></span><br><span class="line">vec4 mixedColor = mix(blurredColor, baseColor, smoothMaskValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除预乘Alpha</span></span><br><span class="line"><span class="keyword">if</span> (mixedColor.a &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">mixedColor.rgb /= mixedColor.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gl_FragColor = mixedColor;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UGImagePortraitMaskBlendFilter</span> : <span class="title">GPUImageThreeInputFilter</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UGImagePortraitMaskBlendFilter</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="variable language_">super</span> initWithFragmentShaderFromString:kUGImagePortraitMaskBlendFragmentShaderString];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="comment">// 初始化滤镜</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UGImageBackgroundBlurFilter</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) GPUImageGaussianBlurFilter *blurFilter;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) UGImagePortraitMaskBlendFilter *blendInputFilter;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UGImageBackgroundBlurFilter</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line"><span class="comment">// 初始化高斯模糊滤镜</span></span><br><span class="line"><span class="keyword">self</span>.blurFilter = [[GPUImageGaussianBlurFilter alloc] init];</span><br><span class="line"><span class="keyword">self</span>.blurFilter.blurRadiusInPixels = <span class="number">31</span>;</span><br><span class="line">[<span class="keyword">self</span> addFilter:<span class="keyword">self</span>.blurFilter];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化混合三输入滤镜</span></span><br><span class="line"><span class="keyword">self</span>.blendInputFilter = [[UGImagePortraitMaskBlendFilter alloc] init];</span><br><span class="line">[<span class="keyword">self</span> addFilter:<span class="keyword">self</span>.blendInputFilter];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置滤镜链</span></span><br><span class="line">[<span class="keyword">self</span>.blurFilter addTarget:<span class="keyword">self</span>.blendInputFilter atTextureLocation:<span class="number">1</span>];</span><br><span class="line">[<span class="keyword">self</span> setInitialFilters:@[<span class="keyword">self</span>.blurFilter, <span class="keyword">self</span>.blendInputFilter]];</span><br><span class="line">[<span class="keyword">self</span> setTerminalFilter:<span class="keyword">self</span>.blendInputFilter];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setMaskImage:(<span class="built_in">UIImage</span> *)maskImage &#123;</span><br><span class="line"><span class="comment">// 腐蚀 + 高斯模糊进行边缘优化</span></span><br><span class="line">GPUImagePicture *maskImageSource = [[GPUImagePicture alloc] initWithImage:maskImage];</span><br><span class="line">GPUImageErosionFilter *erosionFilter = [[GPUImageErosionFilter alloc] initWithRadius:<span class="number">3</span>];</span><br><span class="line">GPUImageGaussianBlurFilter *blurFilter = [[GPUImageGaussianBlurFilter alloc] init];</span><br><span class="line">blurFilter.blurRadiusInPixels = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">[maskImageSource addTarget:erosionFilter];</span><br><span class="line">[erosionFilter addTarget:blurFilter];</span><br><span class="line">[blurFilter addTarget:<span class="keyword">self</span>.blendInputFilter atTextureLocation:<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">[erosionFilter useNextFrameForImageCapture];</span><br><span class="line">[blurFilter useNextFrameForImageCapture];</span><br><span class="line">[maskImageSource processImage];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="端侧优化"><a href="#端侧优化" class="headerlink" title="端侧优化"></a>端侧优化</h4><p>在实现的过程中发现一些问题，从APP侧做了一些优化。</p>
<h5 id="边缘优化"><a href="#边缘优化" class="headerlink" title="边缘优化"></a>边缘优化</h5><p>模型计算出来的mask图像的黑白分界比较明显（像素点非1即0），视觉效果上在背景和人像的分界处有较清晰的边界落差。</p>
<p>针对这个问题我们在使用推理出来的mask进入片元着色器遴选像素之前先过了一次7个像素的高斯模糊滤镜，将mask图的边缘的锋利区域抹平。</p>
<p>边缘高斯模糊后分界不再过于明显，人像周围会存在一圈透明和半透明交织的光圈。</p>
<p>光圈的半径大小取决于模型推理出来的mask图的尺寸，掩码图越大越精细，光圈越小越贴近真实的人像。（和小图片放大会变马赛克同样原理）</p>
<h5 id="边缘腐蚀"><a href="#边缘腐蚀" class="headerlink" title="边缘腐蚀"></a>边缘腐蚀</h5><p>经过边缘优化人像区域分界点弱化后发现人像周围的透明光圈会漏出一些背景信息。</p>
<p>为了降低漏出的背景信息，我们在高斯模糊之前对掩码图做了一次3像素的腐蚀，将人像区域向内收缩。</p>
<h5 id="插值优化"><a href="#插值优化" class="headerlink" title="插值优化"></a>插值优化</h5><p>结合我们的AI作业的录制场景，APP端对两帧之间变化不超过96.5%的不再执行推理，可以一定程度上提高录制的帧率。</p>
<p>该阈值经过一些测试得出，其效果为别的部位和背景不变，仅面部口型发生变化，其两帧之间的差距小于3.5%。</p>
<h5 id="帧缓存"><a href="#帧缓存" class="headerlink" title="帧缓存"></a>帧缓存</h5><p>推理模型存在报错的可能，每一帧推理成功完成后都会缓存该推理结果。</p>
<p>如果当前帧推理报错则会使用上一帧的结果，避免出现模糊失效暴露完整背景信息的情况。</p>
<h4 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h4><p><strong>向内腐蚀导致人像边缘缺失</strong></p>
<p>手指区域有时候会出现识别误差导致手指区域比较细小，因为向内腐蚀而出现手指被腐蚀掉的问题。</p>
<p><strong>帧率低</strong></p>
<p>端上录制的同时做了过多滤镜方面的工作，同时处理背景模糊和人脸美颜，性能较低。</p>
<p>不开背景模糊能跑满30pfs，开了背景模糊会降低到10-15fps。</p>
<p><strong>模型识别精度不足</strong></p>
<p>识别精度难以达到产品预期。当前模型尺寸较小，如果换高精度模型会进一步降低帧率，视频会卡。</p>
<h3 id="Vision-模型"><a href="#Vision-模型" class="headerlink" title="Vision 模型"></a>Vision 模型</h3><p>Vision 是 Apple 在 WWDC 2017 推出的图像识别框架。Vision库里本身就已经自带了很多训练好的Core ML模型，人脸识别、条形码检测等等功能。</p>
<p>如果你要实现的功能刚好是Vision库本身就能实现的，那么你直接使用Vision库自带的一些类和方法就行，但是如果想要更强大的功能，那么还是需要结合其它Core ML模型。</p>
<p>Apple 官方也提供了人像分割的模型VNGeneratePersonSegmentationRequest，需要iOS 15.0 以上系统可以使用该API。</p>
<h4 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">15.0</span>, *)) &#123;</span><br><span class="line">CVPixelBufferRef pixelBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer);</span><br><span class="line"><span class="keyword">if</span> (!pixelBuffer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VNGeneratePersonSegmentationRequest *request = [[VNGeneratePersonSegmentationRequest alloc] init];</span><br><span class="line"><span class="comment">// 决定使用高质量的mask还是高速度的mask</span></span><br><span class="line">request.qualityLevel = VNGeneratePersonSegmentationRequestQualityLevelAccurate;</span><br><span class="line">request.outputPixelFormat = kCVPixelFormatType_OneComponent8;</span><br><span class="line"><span class="comment">// 推理产生mask</span></span><br><span class="line">VNImageRequestHandler *requestHandler = [[VNImageRequestHandler alloc] initWithCVPixelBuffer:pixelBuffer options:@&#123;&#125;];</span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">[requestHandler performRequests:@[request] error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Failed to perform segmentation request: %@&quot;</span>, error);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VNPixelBufferObservation *mask = (VNPixelBufferObservation *)request.results.firstObject;</span><br><span class="line"><span class="keyword">if</span> (mask) &#123;</span><br><span class="line"><span class="built_in">CIImage</span> *ciImage = [<span class="built_in">CIImage</span> imageWithCVPixelBuffer:mask.pixelBuffer];</span><br><span class="line"><span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> context];</span><br><span class="line"><span class="built_in">CGImageRef</span> cgImage = [context createCGImage:ciImage fromRect:ciImage.extent];</span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:cgImage];</span><br><span class="line"><span class="built_in">CGImageRelease</span>(cgImage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">self</span>.getDevicePostion == <span class="built_in">AVCaptureDevicePositionFront</span>) &#123;</span><br><span class="line">image = [<span class="keyword">self</span> flipImageVertically:image];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行渲染</span></span><br><span class="line">[<span class="keyword">self</span>.filter setBlurBackgroundMaskImage:image];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;VNGeneratePersonSegmentationRequest is not available on this iOS version.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们项目支持到iOS 10.0 所以使用原生模型是有局限性的。</p>
<p>另外如果使用高精度模型VNGeneratePersonSegmentationRequestQualityLevelAccurate，其运行速度也比较慢。</p>
<p>如果使用精度和速度相平衡的模型则其识别效果未经过产品验证无法确定是否达到需求。</p>
<h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><h3 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h3><p>AI考虑提升模型运算效率和推理精度，由AI团队调研和研发。</p>
<h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><p>根据模型推理精度来决定是否移除掉腐蚀逻辑，保证人像区域完整。</p>
<p>检测多个滤镜链合并时候的效率，根据结果决定是否需要分离美颜和背景模糊滤镜。</p>
<p>使用帧采样做mask基准，尽量减少模型推理次数。</p>
<p>采样多个模型，根据帧率动态降级。</p>
<h3 id="采用iOS-Vision-推理框架-工程化优化"><a href="#采用iOS-Vision-推理框架-工程化优化" class="headerlink" title="采用iOS Vision 推理框架 工程化优化"></a>采用iOS Vision 推理框架 工程化优化</h3><p>采用 VNGeneratePersonSegmentationRequestQualityLevelBalanced 档位的人像分割模型，效果可以接受。</p>
<p>测试机 iOS 15.2 iPhone 11</p>
<p>2024-11-29 15:53:32.273863+0800 [5274:3232793] 开始推理 1732866812.273805</p>
<p>2024-11-29 15:53:32.300939+0800 [5274:3232793] 推理完成 1732866812.300908</p>
<p>2024-11-29 15:53:32.309572+0800 [5274:3232793] 转图片完成 1732866812.309538</p>
<p>人像分割推理用时 27.1 ms  转图片用时 8.5 ms</p>
<p>当前FPS 为 15 每一帧视频用时 66.67ms</p>
<p>人像分割大概需要在原始耗时的基础上增加35 ms</p>
<p>不开人像分割可以达到设置的最佳帧率 30 FPS。</p>
<p>排查其他用时详情：</p>
<p>2024-11-29 16:54:07.306245+0800 [5358:3254717] 开始应用滤镜 1732870447.306170</p>
<p>2024-11-29 16:54:07.310206+0800 [5358:3254717] 应用滤镜完成 1732870447.310165</p>
<p>合成图像及边缘优化的滤镜用时 4ms 优化空间较小</p>
<p>主要优化方向还是在人像分割推理上</p>
<p>采用差值优化，帧相似度小于某个值才进行检测</p>
<p>差值计算带来额外的性能消耗，如果计算出来需要检测，则检测用时需要追加差值计算的时间消耗，如果计算出来不需要检测，就节省了一次推理时间。</p>
<p>如果差值计算消耗数量级远远小于人像分割推理 则效果比较明显。</p>
<p>2024-11-29 18:01:49.232560+0800 [5457:3292643] 开始计算差值 1732874509.232429</p>
<p>2024-11-29 18:01:49.237739+0800 [5457:3292643] 完成计算差值 1732874509.237706</p>
<p>计算差值需要 5ms</p>
<p>在差值2.5%的基准上，如果人像动作幅度较小则帧率提升到20-25左右。</p>
<p>插值基准越大，则帧率提升越明显，但是对人像分割的效果会有负面影响（<strong>有残影</strong>）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/Jason_Lee155/article/details/121216691">OpenGL ES几个概念-顶点着色器、片元着色器、EG</a></p>
<p><a href="https://learnopengl-cn.github.io/">OpenGL学习教程</a></p>
<p><a href="https://www.nxrte.com/jishu/38561.html">人像分割技术有哪些？</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1077019">Vision 图像识别框架</a></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>AI</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>runloop 学习笔记</title>
    <url>/2020/09/25/runloop/</url>
    <content><![CDATA[<h3 id="从一个问题开始"><a href="#从一个问题开始" class="headerlink" title="从一个问题开始"></a>从一个问题开始</h3><p>Runloop 和线程有什么关系？</p>
<p><code>Runloop</code> 和 <code>线程</code>是密不可分的，可以说Runloop是为线程而生的。线程和runloop是<code>一一对应的</code>，我们只可以在当前线程内操控当前线程对应的Runloop。</p>
<p>Runloop是懒加载的在线程<code>第一次</code>获取他的时候创建，在线程<code>结束</code>的时候销毁。</p>
<p>主线程的runloop是默认启动的，因为主线程需要一直监听事件。子线程的Runloop默认是不启动的，需要手动开启循环。</p>
<h3 id="Runloop-的作用？"><a href="#Runloop-的作用？" class="headerlink" title="Runloop 的作用？"></a>Runloop 的作用？</h3><p>保持程序的运行，主线程的runloop使得APP不会退出</p>
<p>响应并处理APP中的事件，用户交互、定时任务等</p>
<p>节省cpu资源，按需运行，提升程序性能</p>
<h3 id="Runloop的运行过程"><a href="#Runloop的运行过程" class="headerlink" title="Runloop的运行过程"></a>Runloop的运行过程</h3><p>Run Loop本质是一个处理事件源的循环。我们对Run Loop的运行时具有控制权，如果当前没有时间发生，Run Loop会让当前线程进入睡眠模式，来减轻CPU压力。如果有事件发生，Run Loop就处理事件并通知相关的Observer。具体的顺序如下:</p>
<ol>
<li><p>Run Loop进入的时候，会通知Observer</p>
</li>
<li><p>Timer即将被触发时，会通知Observer</p>
</li>
<li><p>有其它非Port-Based Input Source即将被触发时，会通知Observer</p>
</li>
<li><p>启动非Port-Based Input Source的事件源</p>
</li>
<li><p>如果基于Port的Input Source事件源即将触发时，立即处理该事件，并跳转到9</p>
</li>
<li><p>通知Observer当前线程进入睡眠状态</p>
</li>
<li><p>将线程置入睡眠状态直到有以下事件发生：1. Port-Based Input Source被触发。2.Timer被触发。 3.Run Loop设置的时间已经超时。 4.Run Loop被显式唤醒。</p>
</li>
<li><p>通知Observer线程将要被唤醒</p>
</li>
<li><p>处理被触发的事件：1. 如果是用户自定义的Timer，处理Timer事件后重启Run Loop并直接进入步骤2。 2.如果线程被显示唤醒又没有超时，那么进入步骤2。 3.如果是其他Input Source事件源有事件发生，直接传递这个消息。</p>
</li>
<li><p>通知Observer Run Loop结束，Run Loop退出。</p>
</li>
</ol>
<h3 id="Runloop的mode"><a href="#Runloop的mode" class="headerlink" title="Runloop的mode"></a>Runloop的mode</h3><p>runloop有下可以有多个模式，但是同一时间只能有一个模式在运行；</p>
<p>常用的模式有以下3种:</p>
<ol>
<li><p>NSDefaultRunLoopMode: 大多数工作中默认的运行方式。</p>
</li>
<li><p>UITrackingRunLoopMode: 使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）。</p>
</li>
<li><p>NSRunLoopCommonModes: 这是一个伪模式，其为一组run loop mode的集合。如果将Input source加入此模式，意味着关联Input source到Common Modes中包含的所有模式下。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、UITrackingRunLoopMode.</p>
</li>
</ol>
<p>runloop运行在某一指定模式下，就意味着input源或者time源只能在该模式下运行</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基于AI助手的多语言翻译系统开发实践</title>
    <url>/2025/03/19/%E5%9F%BA%E4%BA%8EAI%E5%8A%A9%E6%89%8B%E7%9A%84%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%BF%BB%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="基于AI助手的多语言翻译系统开发实践"><a href="#基于AI助手的多语言翻译系统开发实践" class="headerlink" title="基于AI助手的多语言翻译系统开发实践"></a>基于AI助手的多语言翻译系统开发实践</h1><h2 id="一、项目背景"><a href="#一、项目背景" class="headerlink" title="一、项目背景"></a>一、项目背景</h2><p>在全球化产品开发背景下，我们基于Python构建支持Google翻译与LLM大模型的双引擎翻译系统。核心模块通过 <code>translate_api.py</code>实现，日均处理iOS&#x2F;Android&#x2F;Web多端50+语言的百万级字符翻译需求。</p>
<p>在全球化产品开发中，我们构建了基于Python的多语言翻译系统，支持Google翻译和大模型翻译双引擎，通过 <code>translate_api.py</code>实现核心翻译逻辑。系统需要处理iOS&#x2F;Android&#x2F;Web多端超过50种语言的实时翻译需求，日均处理量达百万级字符。</p>
<h2 id="二、架构设计亮点"><a href="#二、架构设计亮点" class="headerlink" title="二、架构设计亮点"></a>二、架构设计亮点</h2><h3 id="1-双引擎容错机制"><a href="#1-双引擎容错机制" class="headerlink" title="1. 双引擎容错机制"></a>1. 双引擎容错机制</h3><p>通过 <code>TranslatorFactory</code> class in <code>translate_api.py</code>实现翻译引擎的动态切换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TranslatorType</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    LLM = <span class="string">&quot;LLM&quot;</span></span><br><span class="line">    GOOGLE = <span class="string">&quot;GOOGLE&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TranslatorFactory</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_translator</span>(<span class="params">translator_type: TranslatorType</span>) -&gt; BaseTranslator:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        翻译器工厂方法</span></span><br><span class="line"><span class="string">        :param translator_type: 翻译器类型枚举</span></span><br><span class="line"><span class="string">        :return: 对应类型的翻译器实例</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> translator_type == TranslatorType.LLM:</span><br><span class="line">            <span class="keyword">return</span> LLMTranslate()</span><br><span class="line">        <span class="keyword">elif</span> translator_type == TranslatorType.GOOGLE:</span><br><span class="line">            <span class="keyword">return</span> GoogleTranslate()</span><br></pre></td></tr></table></figure>

<h3 id="2-异步并发模型"><a href="#2-异步并发模型" class="headerlink" title="2. 异步并发模型"></a>2. 异步并发模型</h3><p>在 <code>LLMTranslate.translate_all_async</code> function中实现高效并发：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">translate_all_async</span>(<span class="params">self, zh_cn_json: <span class="type">Dict</span></span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">    tasks = [<span class="variable language_">self</span>.translate_batch_async(...) <span class="keyword">for</span> lan <span class="keyword">in</span> lang_tasks]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="comment"># 结果合并逻辑...</span></span><br></pre></td></tr></table></figure>

<h3 id="3-智能重试机制"><a href="#3-智能重试机制" class="headerlink" title="3. 智能重试机制"></a>3. 智能重试机制</h3><p>Google翻译模块实现三级重试策略：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_google_translate</span>(<span class="params">self, input_dict, from_lang, to_lang, retry_count=<span class="number">3</span></span>):</span><br><span class="line">    <span class="keyword">if</span> retry_count &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="variable language_">self</span>.logger.error(<span class="string">&quot;超过最大重试次数&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    <span class="comment"># 分块处理与异常重试逻辑...</span></span><br></pre></td></tr></table></figure>

<h2 id="三、AI助手编程实践心得"><a href="#三、AI助手编程实践心得" class="headerlink" title="三、AI助手编程实践心得"></a>三、AI助手编程实践心得</h2><h3 id="1-代码生成效率提升"><a href="#1-代码生成效率提升" class="headerlink" title="1. 代码生成效率提升"></a>1. 代码生成效率提升</h3><p>在实现异步翻译时，AI助手快速生成正确的事件循环结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">translate_all</span>(<span class="params">self, zh_cn_json: <span class="type">Dict</span></span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">    <span class="keyword">return</span> asyncio.run(<span class="variable language_">self</span>.translate_all_async(zh_cn_json))</span><br></pre></td></tr></table></figure>

<h3 id="2-设计模式应用指导"><a href="#2-设计模式应用指导" class="headerlink" title="2. 设计模式应用指导"></a>2. 设计模式应用指导</h3><p>当需要扩展翻译引擎时，AI助手建议采用工厂模式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TranslatorType</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    LLM = <span class="string">&quot;LLM&quot;</span></span><br><span class="line">    GOOGLE = <span class="string">&quot;GOOGLE&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TranslatorFactory</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_translator</span>(<span class="params">translator_type: TranslatorType</span>) -&gt; BaseTranslator:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        翻译器工厂方法</span></span><br><span class="line"><span class="string">        :param translator_type: 翻译器类型枚举</span></span><br><span class="line"><span class="string">        :return: 对应类型的翻译器实例</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-性能优化建议"><a href="#3-性能优化建议" class="headerlink" title="3. 性能优化建议"></a>3. 性能优化建议</h3><p>AI助手帮助识别同步阻塞点，将 <code>GoogleTranslate.translate_all</code> function改造为异步：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">translate_all_async</span>(<span class="params">self, zh_cn_json: <span class="type">Dict</span></span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">    <span class="comment"># 两阶段并发翻译流程...</span></span><br></pre></td></tr></table></figure>

<h3 id="4-异常处理增强"><a href="#4-异常处理增强" class="headerlink" title="4. 异常处理增强"></a>4. 异常处理增强</h3><p>在 <code>translate_and_check</code> function中实现智能降级：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">translate_and_check</span>(<span class="params">zh_cn_json: <span class="type">Dict</span>, max_retries=<span class="number">3</span></span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">    <span class="keyword">for</span> engine <span class="keyword">in</span> [TranslatorType.LLM, TranslatorType.GOOGLE]:</span><br><span class="line">        <span class="keyword">while</span> retries &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 尝试翻译...</span></span><br></pre></td></tr></table></figure>

<h3 id="5-自动生成脚手架及相关配置"><a href="#5-自动生成脚手架及相关配置" class="headerlink" title="5.自动生成脚手架及相关配置"></a>5.自动生成脚手架及相关配置</h3><p>自动生成setup.py填写依赖包。</p>
<p>自动生成README.md总结项目内容，生成初始化方法。</p>
<h2 id="四、开发工具链"><a href="#四、开发工具链" class="headerlink" title="四、开发工具链"></a>四、开发工具链</h2><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ol>
<li><strong>Trae代码编辑器</strong>：通过静态分析实时检测 <code>await</code>关键字缺失问题</li>
<li><strong>AI辅助调试</strong>：通过异常堆栈分析精准定位网络超时问题</li>
<li><strong>性能测试工具</strong>：使用pytest-asyncio进行并发压力测试</li>
</ol>
<h2 id="五、实践建议"><a href="#五、实践建议" class="headerlink" title="五、实践建议"></a>五、实践建议</h2><ol>
<li>使用类型注解提升代码可读性：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">translate_batch_async</span>(<span class="params">self, data: TranslationRequest</span>) -&gt; <span class="type">Dict</span>:</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>建立完善的监控指标：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监控平均翻译耗时（毫秒）</span></span><br><span class="line">grep <span class="string">&#x27;翻译任务完成&#x27;</span> application.log \</span><br><span class="line">  | awk -F<span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;&#123;sum+=$NF; count++&#125; END &#123;print &quot;平均耗时:&quot;, sum/count, &quot;ms&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置管理规范化：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> TRANSLATE_BY_EN, TRANSLATE_BY_ZH</span><br></pre></td></tr></table></figure>

<h2 id="六、总结与展望"><a href="#六、总结与展望" class="headerlink" title="六、总结与展望"></a>六、总结与展望</h2><h3 id="6-1-项目成果"><a href="#6-1-项目成果" class="headerlink" title="6.1 项目成果"></a>6.1 项目成果</h3><p>通过AI助手与Trae编辑器的配合，我们实现了：开发效率提升40%，翻译性能从单次请求2s优化到200ms。</p>
<p>关键收获：</p>
<ol>
<li>AI助手能快速实现技术方案验证，但需要开发者把控架构合理性</li>
<li>良好的代码抽象是AI生成有效代码的前提</li>
<li>测试驱动开发（TDD）模式与AI生成代码具有良好协同效应</li>
</ol>
<p>未来计划将AI助手应用于：</p>
<ol>
<li>自动生成单元测试用例</li>
<li>智能识别性能瓶颈</li>
<li>多语言翻译质量自动校验</li>
</ol>
<p>AI编程助手正在成为现代软件开发的新生产力工具，但如何与开发者形成「人机协同」的最佳实践，仍是我们需要持续探索的方向。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>AIGC</tag>
        <tag>i18n</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>一帖看透iOS14 小组件</title>
    <url>/2021/02/23/%E4%B8%80%E5%B8%96%E7%9C%8B%E9%80%8FiOS14%20%E5%B0%8F%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>自iOS8之后，苹果支持了扩展（Extension）的开发，开发者可以通过系统提供给我们的扩展接入点 (Extension point) 来为系统特定的服务提供某些附加的功能。<br>但iOS14后，苹果更新了扩展组件，引入了新的UI组件：<code>WidgetKit</code> 而舍弃了iOS14以下版本的Today Extension组件</p>
</blockquote>
<h3 id="Widget介绍"><a href="#Widget介绍" class="headerlink" title="Widget介绍"></a>Widget介绍</h3><p><a href="https://support.apple.com/zh-cn/HT207122">这里有一份官方的小组件使用指南</a></p>
<p>简单来说：小组件相当于一个动态程序入口，在有限的空间内展示你想看到的重要的信息</p>
<img src="https://cdn.zcx.info/008eGmZEly1gnu0x3a5faj305g05p0tr.jpg" alt="电池小组件" style="zoom:50%;" />

<p>苹果自带的日历使用起来非常不适，下载第三方日历又不想被捆绑的无用功能打扰。有了小组件之后这个问题就很好的解决了，比如上面的日历小组件，清晰的展示了今天的日期和农历以及周几，打开手机锁屏就能看见。</p>
<p>此外系统自带的电量小组件，方便的展示了需要下滑去状态栏才能看到的耳机电量：</p>
<img src="https://cdn.zcx.info/008eGmZEly1gnu0y70jk5j30ae0bgjuv.jpg" alt="电池小组件" style="zoom:50%;" />

<p>之前发布的时候觉得这都是安卓系统玩剩下的东西，没什么卵用，不过现在是真香！</p>
<hr>
<h3 id="Widget设计指南"><a href="#Widget设计指南" class="headerlink" title="Widget设计指南"></a>Widget设计指南</h3><p><a href="https://developer.apple.com/design/human-interface-guidelines/ios/system-capabilities/widgets/">这里有一份官方的设计指南</a></p>
<p>简而言之，设计一个简单漂亮吸引人并且快速显示内容的小组件。</p>
<hr>
<h3 id="Widget-HelloWorld"><a href="#Widget-HelloWorld" class="headerlink" title="Widget: HelloWorld"></a>Widget: HelloWorld</h3><p><a href="https://developer.apple.com/documentation/widgetkit/creating-a-widget-extension">这里有一份官方的开发文档可以参考</a></p>
<p>一个小组件需要经过</p>
<p><code>FIle</code> &gt; <code>New</code> &gt;<code>Target</code> &gt;<code>Wiget Extension</code>  来创建</p>
<img src="https://cdn.zcx.info/008eGmZEly1gnu1b833goj30g90gdadn.jpg" style="zoom:100%;" />

<p>找到我们需要的 <code>Widget Extension</code></p>
<p><img src="https://cdn.zcx.info/008eGmZEly1gnu1b7z83jj30kb0eodh5.jpg"></p>
<p>命名小组件</p>
<p><img src="https://cdn.zcx.info/008eGmZEly1gnu1b7vu85j30ke0eoq3v.jpg"></p>
<p>图中圈着的选项控制了我们的小组件能否配置属性，例如天气相关的小组件就可能需要你手动配置地址来获取你想要知道的城市的天气数据。</p>
<p>这样就创建好了一个小组件。小组件的文件结构如下：</p>
<p><img src="https://gitee.com/zcx_bruin/gitee-images/blob/master/Hexo/iOS14Widget/008eGmZEgy1gnu587og7mj30e902s3yi.jpg" alt="不带配置项的小组件结构"></p>
<p>这里我们选则了不带配置项的小组件</p>
<p><img src="https://cdn.zcx.info/008eGmZEly1gnu1ge3kbuj30eb03hglp.jpg" alt="带配置项的结构"></p>
<p>带配置项的小组件的结构 主要区别在于 <code>TestWidget.intentdefinition</code>文件上，这个文件内部可以添加配置选项。</p>
<p>TestWidget代码如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WidgetKit</span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Provider</span>: <span class="title class_ inherited__">TimelineProvider</span> &#123;</span><br><span class="line">   	<span class="comment">/// 默认显示（无自定数据情况下显示）</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">placeholder</span>(<span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>) -&gt; <span class="type">SimpleEntry</span> &#123;</span><br><span class="line">        <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>())</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">///getSnapshot方法是提供一个预览数据，可以让用户看到该组件的一个大致情况，是长什么样、显示什么数据的，可以写成固定数据，国外的			文章里叫它“fake information”</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getSnapshot</span>(<span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">SimpleEntry</span>) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">let</span> entry <span class="operator">=</span> <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>())</span><br><span class="line">        completion(entry)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		<span class="comment">///包含要显示的所有条目：预期显示的时间（条目的日期）以及时间轴“过期”的时间</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getTimeline</span>(<span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Timeline</span>&lt;<span class="type">Entry</span>&gt;) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">var</span> entries: [<span class="type">SimpleEntry</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate a timeline consisting of five entries an hour apart, starting from the current date.</span></span><br><span class="line">        <span class="keyword">let</span> currentDate <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line">        <span class="keyword">for</span> hourOffset <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> <span class="number">5</span> &#123;</span><br><span class="line">            <span class="comment">//需要在这里从网络加载数据回来 同步进行初始化</span></span><br><span class="line">            <span class="keyword">let</span> entryDate <span class="operator">=</span> <span class="type">Calendar</span>.current.date(byAdding: .hour, value: hourOffset, to: currentDate)<span class="operator">!</span></span><br><span class="line">            <span class="keyword">let</span> entry <span class="operator">=</span> <span class="type">SimpleEntry</span>(date: entryDate)</span><br><span class="line">            entries.append(entry)</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// atEnd 指在最后一个显示时间点的小组件完毕后重新刷新TimeLine</span></span><br><span class="line">        <span class="keyword">let</span> timeline <span class="operator">=</span> <span class="type">Timeline</span>(entries: entries, policy: .atEnd)</span><br><span class="line">        completion(timeline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimpleEntry</span>: <span class="title class_ inherited__">TimelineEntry</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">  	<span class="comment">// 下面可以自己添加自定义的model</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidgetEntryView</span> : <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> entry: <span class="type">Provider</span>.<span class="type">Entry</span></span><br><span class="line">		<span class="comment">// swiftUI的View 可以返回一系列View 具体请参看SwiftUI文档</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(entry.date, style: .time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小组件主入口</span></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidget</span>: <span class="title class_ inherited__">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> kind: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;TestWidget&quot;</span></span><br><span class="line">		<span class="comment">// StaticConfiguration 不带配置项的小组件初始化方式</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">WidgetConfiguration</span> &#123;</span><br><span class="line">        <span class="type">StaticConfiguration</span>(kind: kind, provider: <span class="type">Provider</span>()) &#123; entry <span class="keyword">in</span></span><br><span class="line">            <span class="type">TestWidgetEntryView</span>(entry: entry)</span><br><span class="line">        &#125;</span><br><span class="line">        .configurationDisplayName(<span class="string">&quot;My Widget&quot;</span>)</span><br><span class="line">        .description(<span class="string">&quot;This is an example widget.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实时预览view</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidget_Previews</span>: <span class="title class_ inherited__">PreviewProvider</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TestWidgetEntryView</span>(entry: <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>()))</span><br><span class="line">            .previewContext(<span class="type">WidgetPreviewContext</span>(family: .systemSmall))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>于是我们获得了第一个小组件：</p>
<p><img src="https://cdn.zcx.info/008eGmZEly1gnu2oixw72j304o051mx9.jpg"></p>
<p>看起来很简单吧！</p>
<hr>
<h3 id="Widget结构解析"><a href="#Widget结构解析" class="headerlink" title="Widget结构解析"></a>Widget结构解析</h3><h4 id="至关重要-TimeLine"><a href="#至关重要-TimeLine" class="headerlink" title="至关重要 TimeLine"></a>至关重要 TimeLine</h4><p><code>getTimeLine</code> 方法获取小组件整个显示周期。</p>
<p>为了管理系统负载，<code>WidgetKit</code>使用预算来分配一天中的窗口小部件重新负载。</p>
<blockquote>
<p>Widgets use SwiftUI views to display their content. WidgetKit renders the views on your behalf in a separate process. As a result, your widget extension is not continually active, even if the widget is onscreen. Despite your widget not always being active, there are several ways you can keep its content up to date.</p>
</blockquote>
<p>抛开 <code>SwiftUI</code>不谈，单说 <code>your widget extension is not continually active</code> ，这段文字清晰的说明了小组件所面临的问题：不能实时刷新。即使你的小组件在你目光注视中，小组件也不能保持最新状态。</p>
<p>重新加载窗口小部件会消耗系统资源，并会由于额外的联网和处理而导致电池消耗。为了减少对性能的影响并保持全天的电池寿命，请求的更新频率和更新次数将会限制为必要。</p>
<p>那么小组件如何刷新？</p>
<blockquote>
<p>Many widgets have predictable points in time where it makes sense to update their content. For example, a widget that displays weather information might update the temperature hourly throughout the day. A stock market widget could update its content frequently during open market hours, but not at all over the weekend. By planning these times in advance, WidgetKit automatically refreshes your widget when the appropriate time arrives.</p>
</blockquote>
<p>许多APP需要定时刷新数据，这些刷新时间是可预测的，比如日历APP每天刷新当日的日期信息，股市APP则会在工作日频繁刷新交易信息，但是在休息日不频繁刷新。</p>
<p>当我们能够为小组件提供一个可预测的时间点和刷新策略，系统便会按照既定的顺序刷新。</p>
<p><img src="https://cdn.zcx.info/008eGmZEly1gnwiq5qmqfj30n80rugn1.jpg"></p>
<p>如图所示，我们在 <code>.Now</code>和每隔1小时共三小时设置四个显示时间点，系统在get到我们给定的 <code>TimeLine</code>之后会在当前、一小时后、两小时后、三小时后总计四个时间点进行小组件UI渲染,由于我们第一次给定的重新刷新策略为 <code>.atEnd</code>所以会在三个小时时间点渲染完毕之后重新获取 <code>TimeLine</code>。</p>
<p>第二个 <code>TimeLine(Provide timeline)</code>中设置的重新刷新策略为 <code>.never</code>所以在这个时间点的小组件渲染完毕之后就不再刷新了。</p>
<h4 id="添加预览-Snapshot"><a href="#添加预览-Snapshot" class="headerlink" title="添加预览 Snapshot"></a>添加预览 Snapshot</h4><p><code>getSnapshot</code>方法比较简单，这个方法获取我们在打开小组件预览界面时所看到的三个小组件的 <code>Entry</code>。</p>
<p>这里如果不需要展示实时数据的时候可以放入固定的预览数据以获得最好的体验(不需要请求网络直接渲染数据)。</p>
<h4 id="界面美化-Placeholder"><a href="#界面美化-Placeholder" class="headerlink" title="界面美化 Placeholder"></a>界面美化 Placeholder</h4><p><code>placeholder</code>方法目的在于获取一个没有数据或者没有网络情况下的默认View,一般是进行美化小组件的时候在这个view上做文章，</p>
<h4 id="数据支撑-TimelineEntry"><a href="#数据支撑-TimelineEntry" class="headerlink" title="数据支撑 TimelineEntry"></a>数据支撑 TimelineEntry</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SimpleEntry</span>: <span class="title class_ inherited__">TimelineEntry</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TimelineEntry</code>协议必须包含一个 <code>date</code>属性，用于计算需要渲染页面的时间点</p>
<p>自定义的模型可以实现这个协议用于承载内容数据。</p>
<h4 id="内容基石-WidgetEntryView"><a href="#内容基石-WidgetEntryView" class="headerlink" title="内容基石 WidgetEntryView"></a>内容基石 WidgetEntryView</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidgetEntryView</span> : <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> entry: <span class="type">Provider</span>.<span class="type">Entry</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(entry.date, style: .time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小组件的 <code>View</code>就是一个普通的包含 <code>Provider.Entry</code>的 <code>View(swiftUI)</code>，一般创建timeline的时候会提供 <code>Provider.Entry</code>给 <code>View</code>进行渲染。</p>
<p><code>body</code>属性下包含一系列 <code>VIew</code>控件用于渲染页面，更多 <code>SwiftUI</code>相关的知识看<a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">SwiftUI文档</a>。</p>
<p>以上就是小组件的结构拆分和解析，只要明白组成结构和运行机制就能根据自己的需求去定制开发了。</p>
<hr>
<h3 id="Widget进阶"><a href="#Widget进阶" class="headerlink" title="Widget进阶"></a>Widget进阶</h3><h4 id="功能和限制"><a href="#功能和限制" class="headerlink" title="功能和限制"></a>功能和限制</h4><p><code>iOS14 Widget</code>的功能对比着以前的 <code>TodayExtension</code>要少了很多，官方对小组件添加了很多限制。</p>
<ul>
<li>小组件扩展整体需要使用 <code>SwiftUI</code>结构，<code>WidgetEntryView</code>需要提供 <code>SwiftUIView</code>。</li>
<li>页面滚动、动画和视频是被禁止的，<code>SwiftUI</code> 中 <code> List</code> 控件是无法使用的，扩展的 <code>UIKit</code>中 <code>UIVisualEffectView</code>是被禁用的(毛玻璃效果)，更多被禁用的 <code>View</code>还需要在开发中发现。</li>
<li>只支持点击事件交互。</li>
<li>无法主动更新数据 刷新数据使用 <code>Timeline</code>方式手动设置。</li>
<li>每次重置刷新轮次的间隔不能低于5分钟，低于5分钟无效 ，我们在填充 <code>entries</code>时应该为其填充5分钟内需要显示的数据。不建议显示实时时间，和手机系统显示的时间可能会出现偏差。</li>
</ul>
<h4 id="小组件样式区分-supportedFamilies"><a href="#小组件样式区分-supportedFamilies" class="headerlink" title="小组件样式区分  supportedFamilies"></a>小组件样式区分  supportedFamilies</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidget</span>: <span class="title class_ inherited__">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> kind: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;TestWidget&quot;</span></span><br><span class="line">		<span class="comment">// StaticConfiguration 不带配置项的小组件初始化方式</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">WidgetConfiguration</span> &#123;</span><br><span class="line">        <span class="type">StaticConfiguration</span>(kind: kind, provider: <span class="type">Provider</span>()) &#123; entry <span class="keyword">in</span></span><br><span class="line">            <span class="type">TestWidgetEntryView</span>(entry: entry)</span><br><span class="line">        &#125;</span><br><span class="line">        .configurationDisplayName(<span class="string">&quot;My Widget&quot;</span>)</span><br><span class="line">        .description(<span class="string">&quot;This is an example widget.&quot;</span>)</span><br><span class="line">        .supportedFamilies([.systemSmall])<span class="comment">// 注意这里增加了一个方法来限制小组件支持的类型 这里只支持2x2小方块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从主入口可以看到我们定义了一个 <code>TestWidget的</code>小组件，这个小组件默认支持三种样式。</p>
<p>我们常常只需要某一个小组件只支持一种样式，比如最小的方块形状的组件设计的时候由于尺寸及形状往往不考虑其他显示格式。</p>
<p>这时我们可以在 <code>StaticConfiguration</code>后跟上配置支持的样式方法 <code>supportedFamilies()</code>，小组件按照体积大小分为   <code>systemSmall</code>, <code> systemMedium</code>，<code>systemLarge</code>三种。</p>
<h4 id="多小组件容器-WidgetBundle"><a href="#多小组件容器-WidgetBundle" class="headerlink" title="多小组件容器  WidgetBundle"></a>多小组件容器  WidgetBundle</h4><p>在设计完成并确定要展示的小组件之后，我们会遇到一个问题，如何在入口方法处展示多个不同类型的小组件。</p>
<p>比如我们确定了三个小组件，<code>2x2</code>、<code>2x4</code>、<code>4x4</code>三种尺寸各一个，展示的内容也不相同。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@main</span> <span class="comment">// 移除原来的标记 放在这里 main只能存在一个</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KrWidget</span>: <span class="title class_ inherited__">WidgetBundle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Widget</span> &#123;</span><br><span class="line">        <span class="type">KrSmallWidget</span>()</span><br><span class="line">        <span class="type">KrMediumWidget</span>()</span><br><span class="line">        <span class="type">KrLargeWidget</span>()</span><br><span class="line">      	<span class="type">TestWidget</span>()<span class="comment">// 声明好的小组件可以在WidgetBundle下直接初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们可以将入口方法标记改成 <code>WidgetBundle</code>来适应多个小组件，<code>KrSmallWidget</code>、<code>KrMediumWidget</code>、<code>KrLargeWidget</code>为我们自定义的小组件，其结构和 <code>TestWidget</code>一致。</p>
<h4 id="所见即所得-PreviewProvider"><a href="#所见即所得-PreviewProvider" class="headerlink" title="所见即所得   PreviewProvider"></a>所见即所得   PreviewProvider</h4><p>如果对 <code>swiftUI</code>比较熟悉的胖友对这个会比较熟悉。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidget_Previews</span>: <span class="title class_ inherited__">PreviewProvider</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TestWidgetEntryView</span>(entry: <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>()))</span><br><span class="line">            .previewContext(<span class="type">WidgetPreviewContext</span>(family: .systemSmall))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>PreviewProvider</code>可以呼出实时预览的页面，方便我们码UI。</p>
<p>可以点编辑器右边的resume按钮进行预览</p>
<p><img src="https://cdn.zcx.info/008eGmZEly1gnwfwkcrujj30il04f3yq.jpg"></p>
<p>经过build可以看到预览的结果，在你代码改动的时候会实时变化，十分方便。</p>
<p><img src="https://cdn.zcx.info/008eGmZEly1gnwfux3fiej31310ibn10.jpg"></p>
<p>不小心把页面关掉的话可以在右上角五条横线按钮中找到 <code>Canvas</code>选项勾选即可 <code>(Xcode12)</code></p>
<p><img src="https://cdn.zcx.info/008eGmZEly1gnwfqmmkj4j305r06waag.jpg"></p>
<h4 id="APP内刷新小组件-WidgetCenter"><a href="#APP内刷新小组件-WidgetCenter" class="headerlink" title="APP内刷新小组件   WidgetCenter"></a>APP内刷新小组件   WidgetCenter</h4><p>如果你需要在主工程里干预小组件的刷新，你可以使用 <code>WidgetCenter（单例）</code>类来进行操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Reloads the timelines for all widgets of a particular kind.</span></span><br><span class="line"> <span class="comment">/// - Parameter kind: A string that identifies the widget and matches the</span></span><br><span class="line"> <span class="comment">///   value you used when you created the widget&#x27;s configuration.</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">reloadTimelines</span>(<span class="params">ofKind</span> <span class="params">kind</span>: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">/// Reloads the timelines for all configured widgets belonging to the</span></span><br><span class="line"> <span class="comment">/// containing app.</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">reloadAllTimelines</span>()</span><br></pre></td></tr></table></figure>

<p>一般使用这两个方法，来实现主APP内刷新小组件。</p>
<h4 id="为小组件启用定位"><a href="#为小组件启用定位" class="headerlink" title="为小组件启用定位"></a>为小组件启用定位</h4><p>一些天气类型的小组件经常会获取当前的定位，小组件中如果要请求定位信息，需要在小组件目录下的 <code>info.plist</code>文件中添加 <code>NSWidgetWantsLocation</code>字段来请求权限</p>
<p>更多定位权限相关的信息请参考<a href="https://developer.apple.com/documentation/widgetkit/accessing-location-information-in-widgets">给你的小组件添加定位信息</a></p>
<h4 id="和主APP数据共享"><a href="#和主APP数据共享" class="headerlink" title="和主APP数据共享"></a>和主APP数据共享</h4><p>由于widget跟APP间相互独立，如果想用相同的数据则需要两者间数据共享，创建**<code>App Group</code>**<br>主APP中  <code>Target</code> -&gt; <code>Signing &amp; Capability</code> -&gt; <code>+Capability</code> -&gt; <code>添加 App Group</code></p>
<p>不过如果开发者账号开启 <code>Automatically manage signing</code>的话苹果会自动给你创建相关联的APPID。</p>
<p>两者间的数据共享主要通过**<code>UserDefaults</code><strong>和</strong> <code>FileManager</code>**两种形式。</p>
<h4 id="点击交互和跳转方式"><a href="#点击交互和跳转方式" class="headerlink" title="点击交互和跳转方式"></a>点击交互和跳转方式</h4><p>点击Widget窗口唤起APP进行交互指定跳转支持两种方式：</p>
<ul>
<li><code>.widgetURL</code>：点击区域是Widget的所有区域，适合元素、逻辑简单的小部件，一个小组件只能响应一个 <code>widgetURL</code>，其中**<code>systemSmall</code>**类型的小组件只能使用此方式进行跳转</li>
<li><code>Link</code>：通过Link修饰，允许让界面上不同元素产生点击响应，一个小组件可以包含多个 <code>Link</code></li>
</ul>
<p>以上两种小组件链接点击后，可以在主 <code>APP</code>中的 <code>APPDelegate</code>类中进行响应</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">app</span>: <span class="type">UIApplication</span>, <span class="params">open</span> <span class="params">url</span>: <span class="type">URL</span>, <span class="params">options</span>: [<span class="type">UIApplication</span>.<span class="params">OpenURLOptionsKey</span> : <span class="keyword">Any</span>] <span class="operator">=</span> [:]) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  		 <span class="comment">// 一般为小组件链接定义特殊的host进行区分</span></span><br><span class="line">       <span class="keyword">if</span> url.host <span class="operator">==</span> <span class="type">WidgetExtensionHost</span> &#123;</span><br><span class="line">         <span class="comment">//处理小组件点击事件源</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>APP</code>内做了切屏适配，实现了 <code>SceneDelegate</code>则需要在 <code>SceneDelegate</code>里面实现跳转处理</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">scene</span>(<span class="keyword">_</span> <span class="params">scene</span>: <span class="type">UIScene</span>, <span class="params">openURLContexts</span> <span class="params">URLContexts</span>: <span class="type">Set</span>&lt;<span class="type">UIOpenURLContext</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> context <span class="keyword">in</span> <span class="type">URLContexts</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(context.url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调试小组件"><a href="#调试小组件" class="headerlink" title="调试小组件"></a>调试小组件</h4><p>开发的过程中总是充满了不确定性，一些东西需要断点进行调试。那么针对小组件如何调试？其实很简单，安装APP之后把 <code>Scheme</code>修改为我们的 <code>WidgetExtension</code>，选择测试机，然后运行，在手机上添加小组件后即可看到代码进入断点。</p>
<p><img src="https://cdn.zcx.info/008eGmZEly1gnwg0oh85cj30iw06ljsr.jpg"></p>
<h4 id="机型适配"><a href="#机型适配" class="headerlink" title="机型适配"></a>机型适配</h4><p><img src="https://cdn.zcx.info/008eGmZEly1gnwgzuiadlj30rh09g751.jpg"></p>
<p>不同的设备尺寸所拥有的小组件的尺寸也是不同的，目前（iPhone12时代）小组件有以上几种尺寸。</p>
<p>在设计界面的时候和布局时需要考虑不同大小的区域的布局区别。</p>
<p>官方建议保证大的组件看起来比较好，其他尺寸的小组件根据大尺寸的进行微调。（毕竟屏幕一天比一天大）</p>
<h4 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h4><p>开发过程中有遇到使用双模式的图片素材时，手机切换暗黑模式后页面的图标配图没有及时更新。总觉的目前小组件还有许多问题，不是很完善。</p>
<p>解决方案为使用单模式的图，使用两套图进行根据环境切换。</p>
<p>swiftUI中使用ColorScheme判断暗黑模式</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Environment</span>(\.colorScheme) <span class="keyword">var</span> colorScheme: <span class="type">ColorScheme</span></span><br><span class="line"><span class="comment">//根据不同模式填充不同颜色</span></span><br><span class="line"><span class="type">Rectangle</span>().fill(<span class="type">Color</span>(colorScheme <span class="operator">==</span> .dark <span class="operator">?</span> <span class="type">UIColor</span>(hex: <span class="number">0x262626</span>) <span class="operator">??</span> <span class="type">UIColor</span>.black : .white))</span><br></pre></td></tr></table></figure>

<h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><p>如果主项目是使用swift进行开发的，可以将对应的网络请求库分享到小组件的target进行使用。在对应的类文件的Target Membership选项勾选小组件target即可。</p>
<p><img src="https://cdn.zcx.info/008eGmZEly1gnwha6k9wsj30970g3dgy.jpg"></p>
<p>但是一般主项目中的网络框架往往会夹杂很多定制化的插件或其他需求，这么分享会使项目工程代码依赖十分混乱。</p>
<p>小组件中要使用的接口服务不会很多，所以我建议这里使用简单的网络请求即可。</p>
<p>当然由于widget类似于todayExtension，这里可以和todayExtension的网络请求策略保持一致。</p>
<h4 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h4><p>SwiftUI中的Image没有提供直接加载URL方式的图片显示。在 <code>getTimeline</code>中进行数据请求中 <code>completion(timeline)</code>执行完之后，不再支持图片的异步回调，用异步加载的方式就无法加载网络图片，所以必须在数据请求回来的处理中采用<strong>同步方式</strong>，将图片的data获取，转换成UIImage，再赋值给Image展示</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KrBaseWidgetEntity</span>: <span class="title class_ inherited__">Mappable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> itemId: <span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">var</span> itemType: <span class="type">Int</span>?</span><br><span class="line">    <span class="keyword">var</span> widgetTitle: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> widgetImageURL: <span class="type">URL</span>?</span><br><span class="line">    <span class="keyword">var</span> widgetImage: <span class="type">UIImage</span>?</span><br><span class="line">    <span class="keyword">var</span> route: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">map</span>: <span class="type">Map</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">mapping</span>(<span class="params">map</span>: <span class="type">Map</span>) &#123;</span><br><span class="line">        itemId <span class="operator">&lt;-</span> map[<span class="string">&quot;itemId&quot;</span>]</span><br><span class="line">        itemType <span class="operator">&lt;-</span> map[<span class="string">&quot;itemType&quot;</span>]</span><br><span class="line">        widgetTitle <span class="operator">&lt;-</span> map[<span class="string">&quot;widgetTitle&quot;</span>]</span><br><span class="line">        widgetImageURL <span class="operator">&lt;-</span> (map[<span class="string">&quot;widgetImage&quot;</span>], <span class="type">CustomURLTransform</span>())</span><br><span class="line">        route <span class="operator">&lt;-</span> map[<span class="string">&quot;route&quot;</span>]</span><br><span class="line">      	<span class="comment">//获取到图片地址后直接同步获取图片数据转换为UIImage然后在View里面转换为Image显示</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span>  widgetImageURL,<span class="keyword">let</span> img <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">Data</span>(contentsOf: url) &#123;</span><br><span class="line">            widgetImage <span class="operator">=</span> <span class="type">UIImage</span>(data: img)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">id</span>: <span class="type">Int</span>, <span class="params">img</span>: <span class="type">UIImage</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.itemId <span class="operator">=</span> id</span><br><span class="line">        <span class="keyword">self</span>.itemType <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.widgetTitle <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">self</span>.widgetImage <span class="operator">=</span> img</span><br><span class="line">        <span class="keyword">self</span>.route <span class="operator">=</span> defultRoute</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="埋点传值"><a href="#埋点传值" class="headerlink" title="埋点传值"></a>埋点传值</h4><p>小组件中埋点不宜设计过于复杂，因为小组件能够一直在操作系统界面上留存，但是主APP却不一定，需要传递埋点的时候只能在点击事件传递的URL中附带埋点值然后在APP内接收和处理的时候再提取固定的埋点字段。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目前有一个自定义的埋点传值 类似&quot;media_event_value=click_mor_and_eve_widget&quot;</span></span><br><span class="line"><span class="keyword">let</span> routeStr <span class="operator">=</span> route <span class="operator">??</span> defultRoute</span><br><span class="line">  <span class="keyword">var</span> pathURL <span class="operator">=</span>  <span class="type">URL</span>(string: <span class="string">&quot;TestWidget://<span class="subst">\(widgetHost)</span>?<span class="subst">\(routeStr)</span>&quot;</span>)<span class="operator">!</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> trackStr <span class="operator">=</span> track &#123;</span><br><span class="line">      pathURL <span class="operator">=</span>  <span class="type">URL</span>(string: <span class="string">&quot;TestWidget://<span class="subst">\(widgetHost)</span>?<span class="subst">\(routeStr)</span>&amp;<span class="subst">\(trackStr)</span>&quot;</span>)<span class="operator">!</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Widget踩坑"><a href="#Widget踩坑" class="headerlink" title="Widget踩坑"></a>Widget踩坑</h3><h4 id="强制使用SwiftUI"><a href="#强制使用SwiftUI" class="headerlink" title="强制使用SwiftUI"></a>强制使用SwiftUI</h4><p>这次的小组件更新强制使用SwiftUI可以看到苹果的目标和态度。对这个UI库不熟的话开发起来还是有点困难，不过正好也可以通过Widget对swiftUI进行一次实战训练。</p>
<h4 id="偶现第一次添加小组件到桌面UI渲染失败-系统不调用getTimeLine"><a href="#偶现第一次添加小组件到桌面UI渲染失败-系统不调用getTimeLine" class="headerlink" title="偶现第一次添加小组件到桌面UI渲染失败(系统不调用getTimeLine)"></a>偶现第一次添加小组件到桌面UI渲染失败(系统不调用getTimeLine)</h4><p>测试过程中发现的一个问题</p>
<p>APP第一次安装，第一次添加小组件的的时候，如果不等待小组件预览渲染完成就直接点 <code>添加到桌面</code>会触发初始化失败问题</p>
<p>断点调试发现这个时候操作系统不调用（有时候会等很久才调貌似是线程被阻塞了）<code>getTimeLine</code>方法，导致页面加载不成功，由于timeline获取失败，其后续的刷新时间点也没法确定，则最后全部都不能刷新。</p>
<h4 id="刷新不及时"><a href="#刷新不及时" class="headerlink" title="刷新不及时"></a>刷新不及时</h4><p>自己使用的一些其他家的小组件，例如上文提到的日历，偶尔能看到小组件上还保持着昨天的日期，这让我感觉体验很差。</p>
<p>这个新兴事物还有待优化呀。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>小组件</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 如何做一个九宫格GIF播放器</title>
    <url>/2021/12/06/%E4%BF%A1%E6%81%AF%E6%B5%81GIF%E8%BD%AE%E6%92%AD%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="如何做一个九宫格GIF播放器"><a href="#如何做一个九宫格GIF播放器" class="headerlink" title="如何做一个九宫格GIF播放器"></a>如何做一个九宫格GIF播放器</h1><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>APP V9.4.0版本上线了类似朋友圈的动态，包含文字及最多9张图片。</p>
<p>动态2期内容中九宫格图片内追加了GIF格式的图片，并要求多张GIF图片在九宫格内循环播放，且优先播放信息流内第一个动态中包含的GIF图片。可参考微博信息流内GIF组的播放表现。</p>
<h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><h3 id="GIF播放"><a href="#GIF播放" class="headerlink" title="GIF播放"></a>GIF播放</h3><p>GIF图是包含若干帧图片的图片组，由于阿里云存储或者其他存储容器中的文件特征，许多图片路径并不带.gif或.GIF的后缀，所以不能仅通过比对文件名来识别GIF图。而通过<strong>二进制数据</strong>中来标记其文件类型的固定的<strong>位特征</strong>来区分较为准确。</p>
<p>目前我们项目中集成了优秀的开源网络图片框架 <code>&#39;Kingfisher&#39;</code>，其中包含的 <code>AnimatedImageView</code>类能有效识别GIF文件类型和实现精细的播放控制，且使用方便，仅需要给图片view设置网络图片的URL。</p>
<h3 id="图片对齐方式"><a href="#图片对齐方式" class="headerlink" title="图片对齐方式"></a>图片对齐方式</h3><p>需求中同时需要支持图片设置顶部对齐裁剪和左部对齐裁剪，1期项目中 <code>KrShortContentImageView</code>类已使用 <code>UIImageViewAlignmentMask</code>来实现此需求。</p>
<p><code>UIImageViewAlignmentMask</code>的实现原理为要显示的图片View的外层嵌套一个”相框”容器View，图片View根据原图的比例来进行等比例缩放，再根据对齐方式使用“相框”来裁剪，从而做到顶部对齐或者左部对齐的视觉效果。</p>
<p>GIF图片同时满足此对齐方式的需求，所以只要把内部的图片View替换为支持GIF播放的 <code>AnimatedImageView</code>即可。</p>
<h3 id="播放控制"><a href="#播放控制" class="headerlink" title="播放控制"></a>播放控制</h3><h4 id="顺序播放与循环播放"><a href="#顺序播放与循环播放" class="headerlink" title="顺序播放与循环播放"></a>顺序播放与循环播放</h4><p><code>AnimatedImageView</code>默认自动播放GIF，与我们的需求不符合，所以这里需要关闭其自动播放功能改为手动控制播放列表的顺序播放和整体循环播放。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">var</span> realImageView <span class="operator">=</span> <span class="type">AnimatedImageView</span>().then &#123; img <span class="keyword">in</span></span><br><span class="line">    img.autoPlayAnimatedImage <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    img.contentMode <span class="operator">=</span> .scaleAspectFill</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺其自然的我们创建一个 <code>KrShortContentImageView</code>数组作为播放列表，数组中保存的每一个view都可以视为一个播放器来使用。</p>
<p>每次获取可以播放的view数组后我们从第一个view开始播放，在第一个view的GIF播放完毕后通过代理回到列表中调用下一个view的播放，且当播放的是最后一个view的时候回到数组头进行循环即可。</p>
<p>这里我们实现 <code>AnimatedImageView</code>的代理 <code>AnimatedImageViewDelegate</code>方法来监控每一个GIF的播放结束。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">animatedImageView</span>(<span class="keyword">_</span> <span class="params">imageView</span>: <span class="type">AnimatedImageView</span>, <span class="params">didPlayAnimationLoops</span> <span class="params">count</span>: <span class="type">UInt</span>) &#123;</span><br><span class="line">  <span class="comment">///每一个AnimatedImageView播放完毕后会调用这里的代理方法来播放下一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样顺其自然的我们创建了一个来集中处理播放逻辑和向外提供服务方法的单例类和传递GIF播放和加载事件的代理协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 三个方法分别处理图片加载成功、图片加载失败、GIF播放完毕</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">KrShortContentImageViewDelegate</span>: <span class="title class_ inherited__">AnyObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">krShortContentImageViewLoadImageDidSuccess</span>(<span class="params">imageView</span>: <span class="type">KrShortContentImageView</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">krShortContentImageViewLoadImageFailure</span>(<span class="params">imageView</span>: <span class="type">KrShortContentImageView</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">krShortContentImageViewDidFinishAnimation</span>(<span class="params">imageView</span>: <span class="type">KrShortContentImageView</span>, <span class="params">gifView</span>: <span class="type">AnimatedImageView</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 动态列表播放器管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShortContentGifListPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> `default` <span class="operator">=</span> <span class="type">ShortContentGifListPlayer</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="网络加载数据控制"><a href="#网络加载数据控制" class="headerlink" title="网络加载数据控制"></a>网络加载数据控制</h4><p>鉴于网络状态的波动，不能保证每一个GIF的加载都能很快完成，我们在 <code>KrShortContentImageView</code>类中增加了 <code>UIActivityIndicatorView</code>转动小菊花来表示此GIF图片正在加载中。</p>
<p>同时我们需要一个状态变量标识GIF资源的加载状态，以及简单的变化逻辑。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 图片加载状态机</span></span><br><span class="line"><span class="keyword">var</span> imageLoadState: <span class="type">LoadingState</span> <span class="operator">=</span> .initial </span><br><span class="line"></span><br><span class="line"><span class="comment">/// 图片加载过程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">setRealImage</span>(<span class="params">withUrl</span> <span class="params">url</span>: <span class="type">URL</span>?) &#123;</span><br><span class="line">  <span class="keyword">self</span>.imageLoadState <span class="operator">=</span> .loading</span><br><span class="line">  realImageView.kf.setImage(with: url, placeholder: <span class="type">UIImage</span>(color: <span class="type">KrColor</span>.<span class="type">Fill</span>.placeHolder), options: [], progressBlock: <span class="literal">nil</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (result) <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> `self` <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      <span class="keyword">switch</span> result &#123;</span><br><span class="line">      <span class="keyword">case</span> .success(<span class="keyword">_</span>):</span><br><span class="line">          <span class="keyword">self</span>.imageLoadState <span class="operator">=</span> .success</span><br><span class="line">          <span class="comment">// 通知代理GIF加载成功可以播放GIF</span></span><br><span class="line">          <span class="keyword">self</span>.loadingImageDelegate<span class="operator">?</span>.krShortContentImageViewLoadImageDidSuccess(imageView: <span class="keyword">self</span>)</span><br><span class="line">          <span class="keyword">self</span>.updateRealImageLayout()</span><br><span class="line">      <span class="keyword">case</span> .failure(<span class="keyword">_</span>):</span><br><span class="line">          <span class="keyword">self</span>.imageLoadState <span class="operator">=</span> .fail(msg: <span class="string">&quot;图片加载失败&quot;</span>, image: <span class="string">&quot;&quot;</span>)</span><br><span class="line">          <span class="comment">// 通知代理GIF加载失败可以播放下一个GIF</span></span><br><span class="line">          <span class="keyword">self</span>.loadingImageDelegate<span class="operator">?</span>.krShortContentImageViewLoadImageFailure(imageView: <span class="keyword">self</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="弱网或者超时处理"><a href="#弱网或者超时处理" class="headerlink" title="弱网或者超时处理"></a>弱网或者超时处理</h4><p>弱网和超时暂时没有做自定义的超时时间，使用了kf框架内部的超时时间。在播放GIF时如果发现当前的图片正在加载中就把loadingView展示出来等待其加载，当kf.setImage方法回调失败时通过代理告诉管理器去播放下一个。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> gifContent.imageLoadState &#123;</span><br><span class="line">  <span class="keyword">case</span> .success:</span><br><span class="line">      gifContent.hideLoading()<span class="comment">// 收起loading层</span></span><br><span class="line">      gifContent.startAnimating()<span class="comment">// 开始播放GIF</span></span><br><span class="line">  <span class="keyword">case</span> .loading:</span><br><span class="line">      gifContent.showLoading()<span class="comment">// 展示loading层</span></span><br><span class="line">  <span class="keyword">case</span> .fail(<span class="keyword">let</span> err, <span class="keyword">_</span>):</span><br><span class="line">      playNextGif()<span class="comment">// 播放下一个</span></span><br><span class="line">      <span class="type">SwiftyBeaver</span>.error(<span class="string">&quot;播放GIF出错,<span class="subst">\(err)</span>&quot;</span>, context: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">      playNextGif()</span><br><span class="line">      <span class="type">SwiftyBeaver</span>.error(<span class="string">&quot;播放GIF出错,GIF未初始化成功&quot;</span>, context: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="滚动结束后获取播放列表"><a href="#滚动结束后获取播放列表" class="headerlink" title="滚动结束后获取播放列表"></a>滚动结束后获取播放列表</h3><p>推荐信息流、关注信息流、动态流中均包含动态图片九宫格。滚动停止后如何取出可以播放的 <code>KrShortContentImageView</code>列表成为了关键问题。</p>
<p>为了达到较好的播放效果这里我们定义一个概念：</p>
<blockquote>
<p>如果GIF图在屏幕上渲染出并显示了超出一半的范围，则视为此图是可以播放的。</p>
</blockquote>
<p>介于每个GIF图拥有自身的显示标准（宽高），这里需要计算自身高度的50%来和信息流显示区域进行对比。需要我们把每个GIF图的 <code>Frame</code>计算出来，然后逐层转换坐标系到信息流的主显示层进行可展示区域的<strong>交集计算</strong>，如果和可展示区域相交则判断此GIF图是可以播放的。</p>
<p>以推荐信息流为例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 播放Gif列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">playShortContentGifList</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> indexPaths: [<span class="type">IndexPath</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">let</span> cells <span class="operator">=</span> tableView.visibleCells</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> cells.count &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> indexPath <span class="operator">=</span> tableView.indexPath(for: cells[index]) &#123;</span><br><span class="line">            indexPaths.append(indexPath)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> needsPlayGifList: [<span class="type">KrShortContentImageView</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="comment">/// 这里逻辑是可优化的 之所以先遍历cell取indexPath是为了保证indexPath是从小到大排列的，本来这里还有一个indexPath数组的排序</span></span><br><span class="line">    <span class="comment">/// 重构过程中认识到visibleCells取出时就是有序的，只是把排序方法删掉了，当时没有改canDisplayGifViews的参数，后来忘记了...</span></span><br><span class="line">    <span class="comment">/// 遍历第一个包含可播放的GIF列表的Cell进行播放</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> indexPaths.count  &#123;</span><br><span class="line">        <span class="keyword">let</span> imageList <span class="operator">=</span> canDisplayGifViews(indexPath: indexPaths[index])</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>imageList.isEmpty &#123;</span><br><span class="line">            needsPlayGifList.append(contentsOf: imageList)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ShortContentGifListPlayer</span>.default.setNeedsPlayGifList(gifList: needsPlayGifList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片动态内部满足可播的gif列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">canDisplayGifViews</span>(<span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; [<span class="type">KrShortContentImageView</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> cell <span class="operator">=</span> <span class="keyword">self</span>.tableView.cellForRow(at: indexPath), <span class="keyword">let</span> provider <span class="operator">=</span> cell <span class="keyword">as?</span> <span class="type">ShortContentGifListProvider</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">    <span class="comment">/// 获取GIF列表</span></span><br><span class="line">    <span class="keyword">let</span> list <span class="operator">=</span> provider.provideGifViewList()</span><br><span class="line">    <span class="keyword">let</span> rectInTableView <span class="operator">=</span> tableView.rectForRow(at: indexPath)</span><br><span class="line">    <span class="keyword">var</span> showList: [<span class="type">KrShortContentImageView</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> list.count &#123;</span><br><span class="line">        <span class="keyword">let</span> imageFrame <span class="operator">=</span> list[index].frame</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> superView <span class="operator">=</span> list[index].superview <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;<span class="comment">//注意cell内层结构</span></span><br><span class="line">        <span class="comment">/// 坐标系转换</span></span><br><span class="line">        <span class="keyword">let</span> imageFrameInCell <span class="operator">=</span> superView.convert(imageFrame, to: cell)</span><br><span class="line">        <span class="keyword">let</span> imageFrameInTable <span class="operator">=</span> <span class="type">CGRect</span>(x: rectInTableView.origin.x <span class="operator">+</span> imageFrameInCell.origin.x,</span><br><span class="line">                                       y: rectInTableView.origin.y <span class="operator">+</span> imageFrameInCell.origin.y,</span><br><span class="line">                                       width: imageFrame.size.width, height: imageFrame.size.height)</span><br><span class="line">        <span class="keyword">let</span> reactInMainView <span class="operator">=</span> tableView.convert(imageFrameInTable, to: <span class="keyword">self</span>.view)</span><br><span class="line">        <span class="comment">/// 计算可播区域</span></span><br><span class="line">        <span class="keyword">let</span> safeShownGifArea <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: ceil(imageFrame.size.height <span class="operator">/</span> <span class="number">2</span>), </span><br><span class="line">                                      width: view.bounds.size.width, </span><br><span class="line">                                      height: view.bounds.height <span class="operator">-</span> imageFrame.size.height))</span><br><span class="line">        <span class="comment">/// 交集计算</span></span><br><span class="line">        <span class="keyword">if</span> safeShownGifArea.intersects(reactInMainView) &#123;</span><br><span class="line">            showList.append(list[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> showList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信息流刷新处理"><a href="#信息流刷新处理" class="headerlink" title="信息流刷新处理"></a>信息流刷新处理</h3><p>开发过程中发现信息流经常会有reload的操作，导致动态九宫格刷新数据，同时刷新了GIF的View，此时TableView会从复用池中获取一个新的动态模板使用，也就是说此时显示的GIF虽然图片内容和刷新之前一样但是其实质已经是一个新的GIF了（指针值已经变化）。此时正在播放GIF的View从九宫格上移除，GIF的播放被中断。</p>
<p>如果刷新后再手动调一次播放方法，计算逻辑会重新计算需要播放的GIF，如果滚动位置没有变化会计算出和刷新之前相同的GIF图播放列表（GIF文件URL相同），然后从第一个开始播放。</p>
<p>这样的话存在两个问题：</p>
<p>1：GIF列表播放进度被重置。当前正在播放第三个GIF&gt;触发刷新&gt;重新计算&gt;从头开始播放。</p>
<p>2：GIF播放帧进度被重置。当前正在播放第一个GIF（共60帧）且播放到第30帧图片&gt;触发刷新&gt;重新计算&gt;从头开始播放&gt;开始播放第一个GIF的第一帧。</p>
<p>当然，第一个问题我们尝试通过记录当前正在播放的GIF的URL来判断播放的位置的方法来解决，但是由于替换了承载GIF的View，播放帧被重置的问题是无法解决的。这样当弹起输入框、点赞等操作刷新动态Cell时无法做到无痕刷新，用户正在观看的GIF被中断，体验较差。</p>
<p>所以如果想解决问题2应<strong>避免让GIF直接在信息流中播放</strong>。</p>
<p>这里我们在 <code>ShortContentGifListPlayer</code>播放管理器中持有一个专门用来播放GIF的图片类 <code>gifContent</code>。然后将变化较大且较难控制的动态九宫格中的图片列表作为展示真正播放GIF的容器 <code>containerList</code>来管理，在信息流刷新时仅仅替换GIF容器，而不影响正在播放的GIF图片。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 真正播放的gif</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> gifContent <span class="operator">=</span> <span class="type">KrShortContentImageView</span>()</span><br><span class="line"><span class="comment">/// 当前的gif载体superview</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> currentContainer: <span class="type">KrShortContentImageView</span>?</span><br><span class="line"><span class="comment">/// 载体列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> containerList: [<span class="type">KrShortContentImageView</span>] <span class="operator">=</span> []</span><br></pre></td></tr></table></figure>

<p>每次触发信息流刷新时均重新计算GIF播放容器列表，对比正在播放的GIF的URL和容器的URL，把正在播放的GIF放到对应的容器中，做到视觉内无痕替换。</p>
<p>每次GIF播放完毕之后寻找下一个容器，从容器中获取GIF的图片URL进行加载。</p>
<p>如果播放完毕后找不到新的容器则界定为播放逻辑停止，整个播放器变为非活跃状态。</p>
<p><img src="https://cdn.zcx.info/202302221018159.jpg" alt="示意图"></p>
<hr>
<p>解决上述问题2后，问题1的解决方案也获得了优化。</p>
<p>鉴于我们动态流九宫格图片组经常会从推荐频道进入动态流然后从动态流再进入动态详情页，这三处位置的GIF都需要播放，每次进入后新页面都需要重新计算播放列表，而这种翻页的操作又携带相同（按照图片URL计算）的GIF组。</p>
<p>这样的场景就需要我们把不同位置的相同GIF列表记忆播放进度，即接力播放。</p>
<p>所以我们定义一个接力播放的规则：</p>
<blockquote>
<p>新GIF列表包含正在播放的GIF且新列表是当前播放的GIF列表的子集视为可以接力播放</p>
</blockquote>
<p>例如当前正在播放 <code>[A,B,C,D,E,F,G]</code>列表且正在播放 <code>GIF_C</code>，这个时候某个操作计算出了新的播放列表 <code>[A,B,C,D,E]</code>。我们发现新的播放列表是旧的播放列表的<strong>子集</strong>，且新列表<strong>包含</strong>了正在播放的 <code>GIF_C</code>，这个时候我们需要把正在播放的 <code>GIF_C</code>移动到新列表的 <code>容器C</code>上且设置播放进度为C，而不是重新加载A的URL进行GIF播放。</p>
<p>这样操作减少了GIF图重新播放的次数，降低了图片数据IO次数和GPU重新渲染的次数，将翻页的GIF图平滑过渡到新的播放列表。</p>
<h2 id="功能拓展"><a href="#功能拓展" class="headerlink" title="功能拓展"></a>功能拓展</h2><p>综上所述，如果将GIF变为视频或者实况照片或者其他任何可以控制开始和结束的功能模块，均可套用此逻辑进行交互。</p>
<h2 id="总结与优化"><a href="#总结与优化" class="headerlink" title="总结与优化"></a>总结与优化</h2><h3 id="信息流图片缩略"><a href="#信息流图片缩略" class="headerlink" title="信息流图片缩略"></a>信息流图片缩略</h3><p>由于GIF列表使用了固定的专门用来播放的承载器 <code>gifContent</code>,信息流中不再承担播放GIF图的责任，所以信息流中可以完全舍弃加载GIF，而改用加载GIF图的缩略图。缩略图的内存占用更小，加载速度更快，更加适合多图片信息流的展示。</p>
<p>当点击图片需要加载大图或者滚动停止需要播放GIF的时候再去加载真正的原图以获得较好的显示效果。这样图片原图以懒加载（用时加载）的方式来渲染能够提升信息流中大量图片的加载速度，降低内存消耗。</p>
<p>移动设备可视区域比较小，九宫格中显示的图片尺寸更小，所以使用缩略图（合适的压缩率）代替原图在视觉效果上不会产生特别大的损失。</p>
<h3 id="代码逻辑收敛"><a href="#代码逻辑收敛" class="headerlink" title="代码逻辑收敛"></a>代码逻辑收敛</h3><p>当前的代码实现比较散乱，特别是每个GIF转换坐标系时的计算以及和信息流可播区域进行的交集计算。坐标系转换逻辑的复杂度随着GIFView的层级复杂度的提示而显著提升。探索是否存在一种方法判断任意两个VIew是否存在交集（支持设置忽略EdgeInset），以通用的计算方法来代替包含业务View的计算，从而大量降低耦合度，同时减少了复杂度。</p>
<p>将必要的逻辑抽象为协议，以方便此功能移植到其他频道或者列表。</p>
<p>随着迭代增加功能，信息流Controller中的事件越来越多，提供内容（比如这次的GIF）的Cell可以考虑自身来计算可执行条件，实现或者调用功能，或者使用VM来降低Controller的臃肿。Controller中仅控制Tableview的代理事件监听然后调用符合条件的Cell内部的功能实现。这样每次有新的功能时仅仅增加新的Cell注册和新协议的调用，避开大量修改臃肿的Controller代码以降低出错的概率。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="坐标系转换简化"><a href="#坐标系转换简化" class="headerlink" title="坐标系转换简化"></a>坐标系转换简化</h3><p>带着疑问研究了一下坐标系转换的方法，发现他是 <code>UICoordinateSpace</code>协议，只包含几个和坐标转换相关的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">UICoordinateSpace</span> : <span class="title class_ inherited__">NSObjectProtocol</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">convert</span>(<span class="keyword">_</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">to</span> <span class="params">coordinateSpace</span>: <span class="type">UICoordinateSpace</span>) -&gt; <span class="type">CGPoint</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">convert</span>(<span class="keyword">_</span> <span class="params">point</span>: <span class="type">CGPoint</span>, <span class="params">from</span> <span class="params">coordinateSpace</span>: <span class="type">UICoordinateSpace</span>) -&gt; <span class="type">CGPoint</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">convert</span>(<span class="keyword">_</span> <span class="params">rect</span>: <span class="type">CGRect</span>, <span class="params">to</span> <span class="params">coordinateSpace</span>: <span class="type">UICoordinateSpace</span>) -&gt; <span class="type">CGRect</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">convert</span>(<span class="keyword">_</span> <span class="params">rect</span>: <span class="type">CGRect</span>, <span class="params">from</span> <span class="params">coordinateSpace</span>: <span class="type">UICoordinateSpace</span>) -&gt; <span class="type">CGRect</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">8.0</span>, <span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>UIView</code>是实现这个协议的，所以，在父view的层级内肯定是可以将深层嵌套的子view转换到自身坐标系下的。这样一来我们就不必关心view到底是什么，无论是tableView还是collectionView，可以跨层级将cell上加载的图片的frame计算到上层的。</p>
<p>所以我们可以将这个方案合并为一个通用的扩展，用一个方法就可以把GIF位置是否满足播放条件给计算出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UIView</span> &#123;</span><br><span class="line">    <span class="comment">/// 递归查询是否是自己的subview/多级subview</span></span><br><span class="line">    <span class="comment">/// - Parameter subview: 子view或者深层子view</span></span><br><span class="line">    <span class="comment">/// - Returns: Bool</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isMySubview</span>(<span class="params">subview</span>: <span class="type">UIView</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> subview <span class="operator">!=</span> <span class="keyword">self</span>, <span class="keyword">let</span> subviewSuper <span class="operator">=</span> subview.superview <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> subviewSuper <span class="operator">==</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isMySubview(subview: subviewSuper)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 判断任意一子view或者嵌套深层子view是否显示在了父视图特定的可见区域内</span></span><br><span class="line">    <span class="comment">/// - Parameter subview: 子view或者深层子view</span></span><br><span class="line">    <span class="comment">/// - Returns: Bool</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isSubviewIntersectInAimRect</span>(<span class="params">subview</span>: <span class="type">UIView</span>, <span class="params">inset</span>: <span class="type">UIEdgeInsets</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> subviewSuper <span class="operator">=</span> subview.superview, isMySubview(subview: subview) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> subviewFrameInSuper <span class="operator">=</span> convert(subview.frame, from: subviewSuper)</span><br><span class="line">        <span class="keyword">if</span> subviewFrameInSuper <span class="operator">==</span> .zero <span class="operator">||</span> subviewFrameInSuper.isNull &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> safeShownArea <span class="operator">=</span> bounds.in<span class="keyword">set</span>(by: inset)</span><br><span class="line">        <span class="keyword">return</span> safeShownArea.intersects(subviewFrameInSuper)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用了这个方法后，我们可以对比一下</p>
<p>旧计算过程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图片动态内部满足可播的gif列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">canDisplayGifViews</span>(<span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; [<span class="type">KrShortContentImageView</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> cell <span class="operator">=</span> <span class="keyword">self</span>.tableView.cellForRow(at: indexPath), <span class="keyword">let</span> provider <span class="operator">=</span> cell <span class="keyword">as?</span> <span class="type">ShortContentGifListProvider</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">    <span class="comment">/// 获取GIF列表</span></span><br><span class="line">    <span class="keyword">let</span> list <span class="operator">=</span> provider.provideGifViewList()</span><br><span class="line">    <span class="keyword">let</span> rectInTableView <span class="operator">=</span> tableView.rectForRow(at: indexPath)</span><br><span class="line">    <span class="keyword">var</span> showList: [<span class="type">KrShortContentImageView</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> list.count &#123;</span><br><span class="line">        <span class="keyword">let</span> imageFrame <span class="operator">=</span> list[index].frame</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> superView <span class="operator">=</span> list[index].superview <span class="keyword">else</span> &#123; <span class="keyword">continue</span> &#125;<span class="comment">//注意cell内层结构</span></span><br><span class="line">        <span class="comment">/// 坐标系转换</span></span><br><span class="line">        <span class="keyword">let</span> imageFrameInCell <span class="operator">=</span> superView.convert(imageFrame, to: cell)</span><br><span class="line">        <span class="keyword">let</span> imageFrameInTable <span class="operator">=</span> <span class="type">CGRect</span>(x: rectInTableView.origin.x <span class="operator">+</span> imageFrameInCell.origin.x, y: rectInTableView.origin.y <span class="operator">+</span> imageFrameInCell.origin.y,  width: imageFrame.size.width, height: imageFrame.size.height)</span><br><span class="line">        <span class="keyword">let</span> reactInMainView <span class="operator">=</span> tableView.convert(imageFrameInTable, to: <span class="keyword">self</span>.view)</span><br><span class="line">        <span class="comment">/// 计算可播区域</span></span><br><span class="line">        <span class="keyword">let</span> safeShownGifArea <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: ceil(imageFrame.size.height <span class="operator">/</span> <span class="number">2</span>), width: view.bounds.size.width, height: view.bounds.height <span class="operator">-</span> imageFrame.size.height)</span><br><span class="line">        <span class="comment">/// 交集计算</span></span><br><span class="line">        <span class="keyword">if</span> safeShownGifArea.intersects(reactInMainView) &#123;</span><br><span class="line">            showList.append(list[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> showList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新计算过程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每一个图片动态内部满足可播的gif列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">canDisplayGifViews</span>(<span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; [<span class="type">KrShortContentImageView</span>] &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> cell <span class="operator">=</span> <span class="keyword">self</span>.tableView.cellForRow(at: indexPath),</span><br><span class="line">  <span class="keyword">let</span> provider <span class="operator">=</span> cell <span class="keyword">as?</span> <span class="type">ShortContentGifListProvider</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">  <span class="keyword">let</span> showList: [<span class="type">KrShortContentImageView</span>] <span class="operator">=</span> provider.provideGifViewList().filter &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> `self` <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">      <span class="comment">// tabbar是覆盖在流上方的，所以可播区域限制增加tabbar的高度</span></span><br><span class="line">      <span class="keyword">let</span> shownInset <span class="operator">=</span> <span class="type">UIEdgeInsets</span>(top: <span class="variable">$0</span>.frame.height <span class="operator">/</span> <span class="number">2</span>, left: <span class="number">0</span>, bottom: <span class="variable">$0</span>.frame.height <span class="operator">/</span> <span class="number">2</span> <span class="operator">+</span> <span class="type">BasicConst</span>.<span class="type">Layout</span>.tabBarHeight, right: <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 交集计算</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.tableView.isSubviewIntersectInAimRect(subview: <span class="variable">$0</span>, inset: shownInset)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> showList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功将复杂的逐层转换布局变成了一个方法实现，代码变得十分简洁，看起来很爽。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>经验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>客户端日志规范指南</title>
    <url>/2025/03/14/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A5%E5%BF%97%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="一、日志分类体系"><a href="#一、日志分类体系" class="headerlink" title="一、日志分类体系"></a>一、日志分类体系</h2><h3 id="1-1-核心分类矩阵"><a href="#1-1-核心分类矩阵" class="headerlink" title="1.1 核心分类矩阵"></a>1.1 核心分类矩阵</h3><h3 id="1-2-分类定义"><a href="#1-2-分类定义" class="headerlink" title="1.2 分类定义"></a>1.2 分类定义</h3><table>
<thead>
<tr>
<th>类型</th>
<th>记录内容</th>
<th>存储周期</th>
</tr>
</thead>
<tbody><tr>
<td>诊断日志</td>
<td>程序运行状态、异常堆栈</td>
<td>90天</td>
</tr>
<tr>
<td>统计日志</td>
<td>用户行为埋点、业务转化率</td>
<td>365天</td>
</tr>
<tr>
<td>审计日志</td>
<td>敏感操作记录、权限变更</td>
<td>永久</td>
</tr>
</tbody></table>
<h2 id="二、日志级别标准"><a href="#二、日志级别标准" class="headerlink" title="二、日志级别标准"></a>二、日志级别标准</h2><h3 id="2-1-五级日志对照表"><a href="#2-1-五级日志对照表" class="headerlink" title="2.1 五级日志对照表"></a>2.1 五级日志对照表</h3><table>
<thead>
<tr>
<th>级别</th>
<th>触发场景</th>
<th>采样率</th>
</tr>
</thead>
<tbody><tr>
<td>DEBUG</td>
<td>开发环境调试日志</td>
<td>100%</td>
</tr>
<tr>
<td>INFO</td>
<td>常规流程节点记录</td>
<td>30%</td>
</tr>
<tr>
<td>WARNING</td>
<td>可恢复的异常状态</td>
<td>100%</td>
</tr>
<tr>
<td>ERROR</td>
<td>影响主流程的异常</td>
<td>100%</td>
</tr>
<tr>
<td>FATAL</td>
<td>导致应用崩溃的致命错误</td>
<td>100%</td>
</tr>
</tbody></table>
<h3 id="2-2-级别使用示例"><a href="#2-2-级别使用示例" class="headerlink" title="2.2 级别使用示例"></a>2.2 级别使用示例</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关键函数调用记录</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">didSelectItem</span>(<span class="params">at</span> <span class="params">index</span>: <span class="type">IndexPath</span>) &#123;</span><br><span class="line">    <span class="type">Logger</span>.info(<span class="string">&quot;用户点击单元格&quot;</span>, metadata: [<span class="string">&quot;section&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;row&quot;</span>: <span class="string">&quot;5&quot;</span>])</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">guard</span> isValidIndex(index) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Logger</span>.error(<span class="string">&quot;非法索引路径&quot;</span>, metadata: index.debugDescription)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、关键场景日志规范"><a href="#三、关键场景日志规范" class="headerlink" title="三、关键场景日志规范"></a>三、关键场景日志规范</h2><h3 id="3-1-业务流程监控"><a href="#3-1-业务流程监控" class="headerlink" title="3.1 业务流程监控"></a>3.1 业务流程监控</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">start</span><br><span class="line">:流程开始;</span><br><span class="line">:记录START日志;</span><br><span class="line">if (关键操作) then (成功)</span><br><span class="line">  :记录SUCCESS日志;</span><br><span class="line">else (失败)</span><br><span class="line">  :记录FAILURE日志;</span><br><span class="line">endif</span><br><span class="line">:流程结束;</span><br><span class="line">:记录END日志;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h3 id="3-2-异常处理规范"><a href="#3-2-异常处理规范" class="headerlink" title="3.2 异常处理规范"></a>3.2 异常处理规范</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E1003&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BUSINESS&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;expected&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stack_trace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;device_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;os_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iOS 16.4.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WiFi&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、高级记录规范"><a href="#四、高级记录规范" class="headerlink" title="四、高级记录规范"></a>四、高级记录规范</h2><h3 id="4-1-耗时操作监控"><a href="#4-1-耗时操作监控" class="headerlink" title="4.1 耗时操作监控"></a>4.1 耗时操作监控</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handleLargeFile</span><span class="params">(file: <span class="type">File</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> traceId = Logger.beginTrace(<span class="string">&quot;FILE_PROCESSING&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Logger.debug(<span class="string">&quot;开始处理文件&quot;</span>, metadata: file.metadata)</span><br><span class="line">        <span class="comment">// 实际处理逻辑</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Logger.endTrace(traceId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-环境信息记录"><a href="#4-2-环境信息记录" class="headerlink" title="4.2 环境信息记录"></a>4.2 环境信息记录</h3><table>
<thead>
<tr>
<th>信息维度</th>
<th>采集字段</th>
<th>隐私处理</th>
</tr>
</thead>
<tbody><tr>
<td>设备信息</td>
<td>型号、OS版本、分辨率</td>
<td>MD5哈希处理</td>
</tr>
<tr>
<td>网络环境</td>
<td>连接类型、信号强度、IP地址</td>
<td>脱敏处理</td>
</tr>
<tr>
<td>用户上下文</td>
<td>当前页面、登录状态、时区</td>
<td>加密存储</td>
</tr>
</tbody></table>
<hr>
<p><strong>最佳实践推荐</strong>：</p>
<ol>
<li>使用<a href="https://opentelemetry.io/">OpenTelemetry</a>实现标准化日志采集</li>
<li>通过<a href="https://grafana.com/oss/loki/">Grafana Loki</a>构建日志监控体系</li>
<li>采用<a href="https://www.splunk.com/">Splunk</a>进行日志分析与告警</li>
</ol>
<blockquote>
<p>文档版本：v2.3.1<br>更新日期：2025-03-14</p>
</blockquote>
]]></content>
      <categories>
        <category>工程实践</category>
      </categories>
      <tags>
        <tag>移动开发</tag>
        <tag>日志系统</tag>
        <tag>可观测性</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 开发者技术路线图（2025 年）</title>
    <url>/2024/01/01/%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
    <content><![CDATA[<p>本文整理了iOS开发者所需掌握的核心技能和学习路径，帮助开发者规划职业发展。</p>
<hr>
<h2 id="🌟-基础能力"><a href="#🌟-基础能力" class="headerlink" title="🌟 基础能力"></a>🌟 基础能力</h2><h3 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1. 编程语言"></a>1. 编程语言</h3><ul>
<li><strong>Swift</strong><ul>
<li>掌握语法基础（变量、控制流、函数、闭包）</li>
<li>深入理解 <code>Optional</code>、泛型、协议、<code>async/await</code></li>
<li>学习 Swift Concurrency（<code>Task</code>、<code>Actor</code>、<code>Sendable</code>）</li>
</ul>
</li>
<li><strong>Objective-C（可选）</strong><ul>
<li>理解与 Swift 的混编机制</li>
<li>阅读遗留代码库的兼容性</li>
</ul>
</li>
</ul>
<h3 id="2-开发工具"><a href="#2-开发工具" class="headerlink" title="2. 开发工具"></a>2. 开发工具</h3><ul>
<li><strong>Xcode</strong><ul>
<li>熟练使用 Interface Builder、Storyboard&#x2F;XIB</li>
<li>掌握 LLDB 调试、Instruments 性能分析</li>
<li>熟悉 Swift Package Manager（SPM）依赖管理</li>
</ul>
</li>
<li><strong>终端工具</strong><ul>
<li>基础 Shell 命令（<code>xcodebuild</code>、<code>xcrun</code>）</li>
<li>Fastlane 自动化（构建、测试、发布）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="🎨-UI-UX-开发"><a href="#🎨-UI-UX-开发" class="headerlink" title="🎨 UI&#x2F;UX 开发"></a>🎨 UI&#x2F;UX 开发</h2><h3 id="1-原生框架"><a href="#1-原生框架" class="headerlink" title="1. 原生框架"></a>1. 原生框架</h3><ul>
<li><strong>UIKit</strong><ul>
<li>Auto Layout 与自适应布局</li>
<li>核心组件（<code>UITableView</code>、<code>UICollectionView</code>）</li>
<li>自定义视图与动画（<code>CALayer</code>、<code>UIViewPropertyAnimator</code>）</li>
</ul>
</li>
<li><strong>SwiftUI</strong><ul>
<li>声明式语法与数据绑定（<code>@State</code>、<code>@Binding</code>）</li>
<li>复杂布局（<code>Grid</code>、<code>LazyVStack</code>）</li>
<li>跨平台适配（iOS&#x2F;macOS&#x2F;watchOS）</li>
</ul>
</li>
</ul>
<h3 id="2-设计规范"><a href="#2-设计规范" class="headerlink" title="2. 设计规范"></a>2. 设计规范</h3><ul>
<li><strong>Human Interface Guidelines</strong><ul>
<li>遵循 Apple 设计原则（交互、图标、动效）</li>
<li>适配不同设备尺寸（iPhone&#x2F;iPad&#x2F;折叠屏）</li>
<li>无障碍支持（VoiceOver、动态字体）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="🔗-网络与数据"><a href="#🔗-网络与数据" class="headerlink" title="🔗 网络与数据"></a>🔗 网络与数据</h2><h3 id="1-网络请求"><a href="#1-网络请求" class="headerlink" title="1. 网络请求"></a>1. 网络请求</h3><ul>
<li><strong>URLSession</strong><ul>
<li>实现 RESTful API 调用（GET&#x2F;POST&#x2F;DELETE）</li>
<li>处理后台下载&#x2F;上传任务</li>
<li>优化缓存策略（<code>URLCache</code>、<code>NSURLCache</code>）</li>
</ul>
</li>
<li><strong>Alamofire（第三方库）</strong><ul>
<li>封装网络层（拦截器、请求重试）</li>
<li>结合 Combine&#x2F;Swift Concurrency</li>
</ul>
</li>
</ul>
<h3 id="2-数据存储"><a href="#2-数据存储" class="headerlink" title="2. 数据存储"></a>2. 数据存储</h3><ul>
<li><strong>Core Data</strong><ul>
<li>数据模型设计与版本迁移</li>
<li>性能优化（批量操作、预取）</li>
</ul>
</li>
<li><strong>SwiftData（推荐）</strong><ul>
<li>声明式数据管理（<code>@Model</code> 宏）</li>
<li>与 SwiftUI 深度集成</li>
</ul>
</li>
<li><strong>Realm&#x2F;GRDB（可选）</strong><ul>
<li>替代数据库方案对比</li>
</ul>
</li>
</ul>
<hr>
<h2 id="⚡-性能优化"><a href="#⚡-性能优化" class="headerlink" title="⚡ 性能优化"></a>⚡ 性能优化</h2><h3 id="1-关键指标"><a href="#1-关键指标" class="headerlink" title="1. 关键指标"></a>1. 关键指标</h3><ul>
<li><strong>启动时间优化</strong><ul>
<li>冷启动&#x2F;热启动分析</li>
<li>减少动态库加载（<code>dyld</code> 优化）</li>
</ul>
</li>
<li><strong>内存管理</strong><ul>
<li>检测循环引用（<code>weak</code>、<code>unowned</code>）</li>
<li>使用 Memory Graph Debugger</li>
</ul>
</li>
<li><strong>渲染性能</strong><ul>
<li>解决掉帧问题（<code>CADisplayLink</code> 监测）</li>
<li>离屏渲染优化（<code>cornerRadius</code> 替代方案）</li>
</ul>
</li>
</ul>
<h3 id="2-工具链"><a href="#2-工具链" class="headerlink" title="2. 工具链"></a>2. 工具链</h3><ul>
<li><strong>Instruments</strong><ul>
<li>Time Profiler 定位 CPU 瓶颈</li>
<li>Allocations 分析内存泄漏</li>
</ul>
</li>
<li><strong>Xcode Metrics</strong><ul>
<li>监控线上用户性能数据（电池、卡顿率）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="🧪-测试与调试"><a href="#🧪-测试与调试" class="headerlink" title="🧪 测试与调试"></a>🧪 测试与调试</h2><h3 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1. 单元测试"></a>1. 单元测试</h3><ul>
<li><strong>XCTest 框架</strong><ul>
<li>编写可维护的测试用例</li>
<li>覆盖率分析（Xcode Coverage）</li>
</ul>
</li>
<li><strong>Snapshot Testing（第三方）</strong><ul>
<li>验证 UI 一致性（iOSSnapshotTestCase）</li>
</ul>
</li>
</ul>
<h3 id="2-调试技巧"><a href="#2-调试技巧" class="headerlink" title="2. 调试技巧"></a>2. 调试技巧</h3><ul>
<li><strong>断点高级用法</strong><ul>
<li>条件断点、符号断点</li>
<li>LLDB 命令（<code>po</code>、<code>expression</code>）</li>
</ul>
</li>
<li><strong>Proxyman&#x2F;Charles</strong><ul>
<li>抓包分析与 Mock 数据</li>
</ul>
</li>
</ul>
<hr>
<h2 id="🏗️-架构设计"><a href="#🏗️-架构设计" class="headerlink" title="🏗️ 架构设计"></a>🏗️ 架构设计</h2><h3 id="1-主流模式"><a href="#1-主流模式" class="headerlink" title="1. 主流模式"></a>1. 主流模式</h3><ul>
<li><strong>MVVM</strong><ul>
<li>结合 Combine&#x2F;Swift Concurrency</li>
<li>双向数据绑定（<code>@Published</code>）</li>
</ul>
</li>
<li><strong>VIPER（复杂场景）</strong><ul>
<li>模块化拆分（Router&#x2F;Interactor）</li>
</ul>
</li>
<li><strong>TCA（The Composable Architecture）</strong><ul>
<li>状态管理（<code>Reducer</code>、<code>Store</code>）</li>
</ul>
</li>
</ul>
<h3 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h3><ul>
<li><strong>SOLID 原则</strong><ul>
<li>单一职责、依赖倒置</li>
</ul>
</li>
<li><strong>DI（依赖注入）</strong><ul>
<li>使用 Swinject&#x2F;Factory 框架</li>
</ul>
</li>
</ul>
<hr>
<h2 id="🌐-跨平台技术"><a href="#🌐-跨平台技术" class="headerlink" title="🌐 跨平台技术"></a>🌐 跨平台技术</h2><h3 id="1-混合开发"><a href="#1-混合开发" class="headerlink" title="1. 混合开发"></a>1. 混合开发</h3><ul>
<li><strong>Flutter（推荐）</strong><ul>
<li>使用 Dart 构建跨端 UI</li>
<li>与原生模块通信（Platform Channel）</li>
</ul>
</li>
<li><strong>React Native（可选）</strong><ul>
<li>JavaScript 桥接原生能力</li>
</ul>
</li>
</ul>
<h3 id="2-苹果生态扩展"><a href="#2-苹果生态扩展" class="headerlink" title="2. 苹果生态扩展"></a>2. 苹果生态扩展</h3><ul>
<li><strong>watchOS&#x2F;tvOS</strong><ul>
<li>开发配套应用（HealthKit&#x2F;HomeKit）</li>
</ul>
</li>
<li><strong>CarPlay</strong><ul>
<li>车载系统适配指南</li>
</ul>
</li>
</ul>
<hr>
<h2 id="🚀-进阶领域"><a href="#🚀-进阶领域" class="headerlink" title="🚀 进阶领域"></a>🚀 进阶领域</h2><h3 id="1-新技术"><a href="#1-新技术" class="headerlink" title="1. 新技术"></a>1. 新技术</h3><ul>
<li><strong>AR&#x2F;VR</strong><ul>
<li>使用 ARKit 开发沉浸式体验</li>
</ul>
</li>
<li><strong>机器学习</strong><ul>
<li>Core ML 模型集成（图像分类、NLP）</li>
</ul>
</li>
<li><strong>Swift 编译器插件</strong><ul>
<li>自定义宏（<code>@freestanding</code>、<code>@attached</code>）</li>
</ul>
</li>
</ul>
<h3 id="2-工程化"><a href="#2-工程化" class="headerlink" title="2. 工程化"></a>2. 工程化</h3><ul>
<li><strong>CI&#x2F;CD</strong><ul>
<li>GitHub Actions&#x2F;Bitrise 流水线搭建</li>
<li>TestFlight 分发与管理</li>
</ul>
</li>
<li><strong>App Store 上架</strong><ul>
<li>审核避坑指南（隐私政策、元数据）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="📚-持续学习"><a href="#📚-持续学习" class="headerlink" title="📚 持续学习"></a>📚 持续学习</h2><h3 id="1-资源推荐"><a href="#1-资源推荐" class="headerlink" title="1. 资源推荐"></a>1. 资源推荐</h3><ul>
<li><strong>官方文档</strong><ul>
<li><a href="https://developer.apple.com/">Apple Developer</a></li>
<li>WWDC 视频（年度新技术解析）</li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li>《Swift 进阶》</li>
<li>《Combine 异步编程》</li>
</ul>
</li>
<li><strong>社区</strong><ul>
<li>Swift 论坛、iOS Dev Weekly</li>
</ul>
</li>
</ul>
<h3 id="2-实践建议"><a href="#2-实践建议" class="headerlink" title="2. 实践建议"></a>2. 实践建议</h3><ul>
<li><strong>开源贡献</strong><ul>
<li>Alamofire&#x2F;SwiftUI 源码阅读</li>
</ul>
</li>
<li><strong>个人项目</strong><ul>
<li>开发完整上架应用（从 0 到 1 闭环）</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p><strong>提示</strong>：技术路线需根据个人目标动态调整，建议每半年复盘一次技能树 🎯</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>职业发展</tag>
        <tag>学习路径</tag>
      </tags>
  </entry>
  <entry>
    <title>常见算法考题列表（2025 年整理）</title>
    <url>/2024/01/01/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>本文整理了常见的算法面试题目，包括数据结构、基础算法和高级算法等多个方面的典型题目。</p>
<hr>
<h2 id="📚-数据结构与基础算法"><a href="#📚-数据结构与基础算法" class="headerlink" title="📚 数据结构与基础算法"></a>📚 <strong>数据结构与基础算法</strong></h2><h3 id="1-数组与链表"><a href="#1-数组与链表" class="headerlink" title="1. 数组与链表"></a>1. <strong>数组与链表</strong></h3><ul>
<li><strong>两数之和</strong>题目：在数组中找出和为 <code>target</code> 的两个元素的下标。考察点：哈希表、空间换时间优化:cite[3]:cite[7]</li>
<li><strong>合并两个有序链表</strong>题目：将两个升序链表合并为一个新链表。考察点：指针操作、递归&#x2F;迭代实现:cite[3]:cite[7]</li>
<li><strong>反转链表</strong><br>题目：将单链表反转（迭代或递归实现）。<br>考察点：指针操作、递归思维:cite[2]:cite[7]</li>
</ul>
<h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. <strong>字符串</strong></h3><ul>
<li><strong>最长回文子串</strong>题目：找到字符串中的最长回文子串。考察点：中心扩散法、动态规划:cite[2]:cite[7]</li>
<li><strong>第一个不重复的字符</strong>题目：找到字符串中第一个只出现一次的字符的下标。考察点：哈希表统计频率:cite[7]</li>
<li><strong>版本号排序</strong><br>题目：将版本号数组按从大到小排序（如 <code>[&#39;10.2.1&#39;, &#39;0.402.1&#39;]</code>）。<br>考察点：字符串分割、多级比较:cite[7]</li>
</ul>
<h3 id="3-树与图"><a href="#3-树与图" class="headerlink" title="3. 树与图"></a>3. <strong>树与图</strong></h3><ul>
<li><strong>对称二叉树</strong>题目：判断二叉树是否镜像对称。考察点：递归遍历、层序遍历:cite[3]:cite[7]</li>
<li><strong>二叉树的中序遍历</strong>题目：实现非递归中序遍历。考察点：栈的应用、Morris 遍历:cite[2]:cite[7]</li>
<li><strong>克隆图</strong><br>题目：深度拷贝无向连通图。<br>考察点：DFS&#x2F;BFS、哈希表记录已访问节点:cite[3]</li>
</ul>
<hr>
<h2 id="⚙️-高级算法与优化"><a href="#⚙️-高级算法与优化" class="headerlink" title="⚙️ 高级算法与优化"></a>⚙️ <strong>高级算法与优化</strong></h2><h3 id="1-排序与搜索"><a href="#1-排序与搜索" class="headerlink" title="1. 排序与搜索"></a>1. <strong>排序与搜索</strong></h3><ul>
<li><strong>快速排序</strong>题目：实现快速排序并分析时间复杂度。考察点：分治思想、基准选择优化:cite[1]:cite[7]</li>
<li><strong>二分查找</strong>题目：在有序数组中查找目标值的位置。考察点：边界条件处理、循环不变量:cite[1]:cite[7]</li>
<li><strong>第 K 个最大元素</strong><br>题目：在未排序数组中找到第 K 大的元素。<br>考察点：快速选择算法、堆排序:cite[3]</li>
</ul>
<h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. <strong>动态规划</strong></h3><ul>
<li><strong>最长递增子序列</strong>题目：求数组中最长严格递增子序列的长度。考察点：状态转移方程、二分优化:cite[3]:cite[7]</li>
<li><strong>背包问题</strong>题目：0-1 背包问题的动态规划解法。考察点：二维 DP 表、空间压缩:cite[4]:cite[8]</li>
<li><strong>编辑距离</strong><br>题目：计算将字符串 A 转换为 B 的最小操作次数（增&#x2F;删&#x2F;改）。<br>考察点：二维 DP、状态转移方程:cite[7]</li>
</ul>
<h3 id="3-贪心与回溯"><a href="#3-贪心与回溯" class="headerlink" title="3. 贪心与回溯"></a>3. <strong>贪心与回溯</strong></h3><ul>
<li><strong>跳跃游戏</strong>题目：判断能否从数组起点跳到终点（每步最大跳跃长度为 <code>nums[i]</code>）。考察点：贪心策略、最大覆盖范围:cite[7]</li>
<li><strong>全排列</strong>题目：生成数组的所有排列组合。考察点：回溯算法、剪枝优化:cite[7]</li>
<li><strong>组合总和</strong><br>题目：找出数组中所有和为 <code>target</code> 的组合（元素可重复使用）。<br>考察点：回溯、去重技巧:cite[7]</li>
</ul>
<hr>
<h2 id="🧩-系统设计与场景题"><a href="#🧩-系统设计与场景题" class="headerlink" title="🧩 系统设计与场景题"></a>🧩 <strong>系统设计与场景题</strong></h2><h3 id="1-数据结构设计"><a href="#1-数据结构设计" class="headerlink" title="1. 数据结构设计"></a>1. <strong>数据结构设计</strong></h3><ul>
<li><strong>LRU 缓存</strong>题目：设计基于 LRU 策略的缓存，支持 <code>get</code> 和 <code>put</code> 操作。考察点：哈希表 + 双向链表:cite[2]:cite[7]</li>
<li><strong>最小栈</strong><br>题目：实现一个支持 <code>push</code>、<code>pop</code>、<code>top</code> 及 <code>getMin</code> 的栈。<br>考察点：辅助栈或差值存储:cite[3]</li>
</ul>
<h3 id="2-场景问题"><a href="#2-场景问题" class="headerlink" title="2. 场景问题"></a>2. <strong>场景问题</strong></h3><ul>
<li><strong>会议室安排</strong>题目：给定多个会议时间区间，判断能否全部安排。考察点：区间排序、重叠检测:cite[7]</li>
<li><strong>接雨水</strong><br>题目：计算柱子高度数组能接多少雨水。<br>考察点：双指针、动态规划或单调栈:cite[7]</li>
</ul>
<hr>
<h2 id="📈-复杂度与优化"><a href="#📈-复杂度与优化" class="headerlink" title="📈 复杂度与优化"></a>📈 <strong>复杂度与优化</strong></h2><ul>
<li><strong>时间复杂度分析</strong>常见阶：O(1)、O(n)、O(n²)、O(nlogn) 等，需结合代码解释:cite[4]:cite[8]</li>
<li><strong>空间复杂度优化</strong><br>例如：原地排序、滚动数组、位运算压缩状态:cite[4]:cite[7]</li>
</ul>
<hr>
<blockquote>
<p><strong>提示</strong>：以上题目覆盖了算法面试 80% 的高频考点，建议结合 LeetCode 或《剑指 Offer》进行针对性练习。<br><strong>完整题目与代码实现</strong>可参考：<a href="https://blog.csdn.net/Ed7zgeE9X/article/details/132288312">CSDN 算法题整理</a>:cite[7] | <a href="https://leetcode.com/">力扣题库</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 面试高频问题总结（2025 最新版）</title>
    <url>/2024/01/01/%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本文总结了iOS开发面试中的高频问题，涵盖语言基础、框架应用、性能优化等多个方面。</p>
<h2 id="🎯-语言基础（Swift）"><a href="#🎯-语言基础（Swift）" class="headerlink" title="🎯 语言基础（Swift）"></a>🎯 语言基础（Swift）</h2><ol>
<li><p><strong>值类型 vs 引用类型</strong></p>
<ul>
<li>结构体&#x2F;枚举与类的本质区别？</li>
<li>如何选择 <code>struct</code> 和 <code>class</code> 的使用场景？</li>
</ul>
</li>
<li><p><strong>协议与泛型</strong></p>
<ul>
<li><code>associatedtype</code> 的作用是什么？</li>
<li>如何实现类型擦除（Type Erasure）？</li>
</ul>
</li>
<li><p><strong>内存管理</strong></p>
<ul>
<li>解释 <code>weak</code>、<code>unowned</code>、<code>strong</code> 的区别</li>
<li>如何检测和解决循环引用问题？</li>
</ul>
</li>
<li><p><strong>Swift Concurrency</strong></p>
<ul>
<li><code>async/await</code> 与 Combine 框架的适用场景对比</li>
<li><code>Sendable</code> 协议的作用与实现要求</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🖥️-iOS-框架"><a href="#🖥️-iOS-框架" class="headerlink" title="🖥️ iOS 框架"></a>🖥️ iOS 框架</h2><h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h3><ol>
<li><p><strong>生命周期</strong></p>
<ul>
<li><code>viewDidLoad</code> 和 <code>viewWillAppear</code> 的区别</li>
<li>如何正确管理视图控制器的内存？</li>
</ul>
</li>
<li><p><strong>布局与渲染</strong></p>
<ul>
<li>Auto Layout 性能优化技巧</li>
<li>解释 <code>drawRect</code> 与 <code>layoutSubviews</code> 的调用时机</li>
</ul>
</li>
<li><p><strong>响应链与手势</strong></p>
<ul>
<li>描述 iOS 事件传递机制（Hit-Testing）</li>
<li>如何实现自定义手势识别器？</li>
</ul>
</li>
</ol>
<h3 id="SwiftUI"><a href="#SwiftUI" class="headerlink" title="SwiftUI"></a>SwiftUI</h3><ol>
<li><p><strong>状态管理</strong></p>
<ul>
<li><code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code> 的区别</li>
<li>如何实现跨视图状态共享？</li>
</ul>
</li>
<li><p><strong>性能优化</strong></p>
<ul>
<li><code>LazyVStack</code> 与 <code>VStack</code> 的性能差异</li>
<li>如何避免 SwiftUI 视图的无效重绘？</li>
</ul>
</li>
</ol>
<hr>
<h2 id="💡-设计模式与架构"><a href="#💡-设计模式与架构" class="headerlink" title="💡 设计模式与架构"></a>💡 设计模式与架构</h2><ol>
<li><p><strong>MVVM 实现</strong></p>
<ul>
<li>如何设计双向数据绑定（结合 Combine&#x2F;Swift Concurrency）？</li>
<li>ViewModel 与 Service 层的职责划分</li>
</ul>
</li>
<li><p><strong>依赖注入</strong></p>
<ul>
<li>手动依赖注入 vs 框架（如 Swinject）的优劣</li>
<li>如何在单元测试中应用 DI？</li>
</ul>
</li>
<li><p><strong>模块化设计</strong></p>
<ul>
<li>如何解耦巨型单体工程？</li>
<li>动态化方案（二进制化&#x2F;插件化）的实现思路</li>
</ul>
</li>
</ol>
<hr>
<h2 id="⚙️-性能优化"><a href="#⚙️-性能优化" class="headerlink" title="⚙️ 性能优化"></a>⚙️ 性能优化</h2><ol>
<li><p><strong>启动优化</strong></p>
<ul>
<li>冷启动阶段各进程的加载顺序</li>
<li>如何减少动态库加载时间？</li>
</ul>
</li>
<li><p><strong>内存优化</strong></p>
<ul>
<li>使用 Instruments 定位内存泄漏的步骤</li>
<li><code>NSCache</code> 与 <code>URLCache</code> 的最佳实践</li>
</ul>
</li>
<li><p><strong>渲染性能</strong></p>
<ul>
<li>如何检测和解决掉帧问题？</li>
<li>离屏渲染的常见场景与优化方案</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🌐-网络与存储"><a href="#🌐-网络与存储" class="headerlink" title="🌐 网络与存储"></a>🌐 网络与存储</h2><ol>
<li><p><strong>HTTP&#x2F;2 与 QUIC</strong></p>
<ul>
<li>对比 HTTP&#x2F;1.1 的核心改进点</li>
<li>iOS 如何支持 QUIC 协议？</li>
</ul>
</li>
<li><p><strong>数据持久化</strong></p>
<ul>
<li>Core Data 与 SwiftData 的架构差异</li>
<li>多线程环境下 Realm 的使用注意事项</li>
</ul>
</li>
<li><p><strong>安全机制</strong></p>
<ul>
<li>如何防止中间人攻击（MITM）？</li>
<li>Keychain 数据存储的加密原理</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🔄-多线程与并发"><a href="#🔄-多线程与并发" class="headerlink" title="🔄 多线程与并发"></a>🔄 多线程与并发</h2><ol>
<li><p><strong>GCD 高级用法</strong></p>
<ul>
<li><code>dispatch_barrier_async</code> 的应用场景</li>
<li>如何创建可取消的 DispatchWorkItem？</li>
</ul>
</li>
<li><p><strong>OperationQueue</strong></p>
<ul>
<li>如何实现任务依赖与优先级控制？</li>
<li>对比 GCD 的优劣</li>
</ul>
</li>
<li><p><strong>Actor 模型</strong></p>
<ul>
<li>Swift Actor 如何保证线程安全？</li>
<li><code>nonisolated</code> 关键字的用途</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🧪-测试与调试"><a href="#🧪-测试与调试" class="headerlink" title="🧪 测试与调试"></a>🧪 测试与调试</h2><ol>
<li><p><strong>单元测试</strong></p>
<ul>
<li>如何对异步代码进行测试？</li>
<li>依赖注入在测试中的应用</li>
</ul>
</li>
<li><p><strong>UI 自动化</strong></p>
<ul>
<li>XCUITest 的核心组件与使用限制</li>
<li>如何实现跨语言自动化测试（Appium）</li>
</ul>
</li>
<li><p><strong>Crash 分析</strong></p>
<ul>
<li>符号化崩溃日志的完整流程</li>
<li>如何捕获并上报野指针异常？</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🧠-系统设计题"><a href="#🧠-系统设计题" class="headerlink" title="🧠 系统设计题"></a>🧠 系统设计题</h2><ol>
<li><p><strong>架构设计</strong></p>
<ul>
<li>设计一个支持 LRU 缓存的图片加载库</li>
<li>实现一个支持断点续传的下载管理器</li>
</ul>
</li>
<li><p><strong>场景方案</strong></p>
<ul>
<li>如何保证弱网环境下消息的可靠传输？</li>
<li>设计一个即时通讯应用的消息同步机制</li>
</ul>
</li>
</ol>
<hr>
<h2 id="💻-算法与数据结构"><a href="#💻-算法与数据结构" class="headerlink" title="💻 算法与数据结构"></a>💻 算法与数据结构</h2><ol>
<li><p><strong>高频算法</strong></p>
<ul>
<li>链表反转（迭代&#x2F;递归）</li>
<li>二叉树层序遍历</li>
<li>最长无重复子串</li>
</ul>
</li>
<li><p><strong>优化思维</strong></p>
<ul>
<li>两数之和的多种解法对比（哈希表&#x2F;双指针）</li>
<li>动态规划解决背包问题</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p><strong>提示</strong>：每个问题建议延伸思考：</p>
<ul>
<li>该技术点的底层原理（如 Runtime 机制）</li>
<li>实际项目中的实践案例</li>
<li>不同方案的优缺点对比</li>
</ul>
</blockquote>
<p><strong>注</strong>：结合最新 iOS 19 特性（如 Vision Pro 开发）准备差异化答案 🚀</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>知识点</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
