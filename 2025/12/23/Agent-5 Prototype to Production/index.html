<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>AI-Agent 白皮书 5 - Prototype to Production | 我的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="Prototype to  Production 从原型到生产 Authors: Sokratis Kartakis, Gabriela Hernandez Larios, Ran Li, Elia Secchi, and Huang Xia This whitepaper provides a comprehensive technical guide to the operational li">
<meta property="og:type" content="article">
<meta property="og:title" content="AI-Agent 白皮书 5 - Prototype to Production">
<meta property="og:url" content="https://zcx4u.github.io/2025/12/23/Agent-5%20Prototype%20to%20Production/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="Prototype to  Production 从原型到生产 Authors: Sokratis Kartakis, Gabriela Hernandez Larios, Ran Li, Elia Secchi, and Huang Xia This whitepaper provides a comprehensive technical guide to the operational li">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-22T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-18T16:25:41.764Z">
<meta property="article:author" content="bruin">
<meta property="article:tag" content="技术,博客,编程">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="我的博客" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/images/banner.webp" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="  ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>我的博客 </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS 订阅">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/images/bruin.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">bruin </div>
      <div class="dot"></div>
      <div class="subtitle">个人技术博客 </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/zcx4u" title="GitHub"><i class="fa-brands fa-github"></i></a>
        
          <a class="link-btn" href="mailto:your-email@example.com" title="Email"><i class="fa-solid fa-envelope"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">分类</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/iOS/">
                iOS
                <div class="category-count">21</div>
            </a>
        
            <a class="category-link" href="/categories/AI-Agent/">
                AI-Agent
                <div class="category-count">5</div>
            </a>
        
            <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">
                技术
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/tech-sharing/">
                技术分享
                <div class="category-count">3</div>
            </a>
        
            <a class="category-link" href="/categories/ios-development/">
                iOS开发
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/AI/" rel="tag">AI</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/AIGC/" rel="tag">AIGC</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/BUG%E8%AE%B0%E5%BD%95%E5%92%8C%E7%BB%8F%E9%AA%8C%E6%94%B6%E9%9B%86/" rel="tag">BUG记录和经验收集</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/ChatGPT/" rel="tag">ChatGPT</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Cursor/" rel="tag">Cursor</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/IDE/" rel="tag">IDE</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Webview/" rel="tag">Webview</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Xcode/" rel="tag">Xcode</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/asr/" rel="tag">asr</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/i18n/" rel="tag">i18n</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/ios/" rel="tag">iOS</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E4%B8%80%E9%94%AE%E5%94%A4%E8%B5%B7/" rel="tag">一键唤起</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">图像处理</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%A4%9A%E8%AF%BB%E6%96%87%E6%A1%A3/" rel="tag">多读文档</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%B0%8F%E7%BB%84%E4%BB%B6/" rel="tag">小组件</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/performance/" rel="tag">性能优化</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/" rel="tag">技术调研</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%95%88%E7%8E%87/" rel="tag">效率</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/" rel="tag">效率提升</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%9C%89%E7%94%A8%E7%9A%84/" rel="tag">有用的</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/architecture/" rel="tag">架构设计</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">知识点</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/" rel="tag">经验记录</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/" rel="tag">编程思维</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/" rel="tag">语音识别</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%B0%83%E8%AF%95/" rel="tag">调试</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" rel="tag">错误处理</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/archives/2025/12 ">
          十二月 2025 
          <div class="archive-count">5 </div>
        </a>
      
        <a class="archive-link" href="/archives/2025/07 ">
          七月 2025 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2025/05 ">
          五月 2025 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2025/04 ">
          四月 2025 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2025/03 ">
          三月 2025 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/11 ">
          十一月 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/05 ">
          五月 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2024/01 ">
          一月 2024 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/03 ">
          三月 2023 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/11 ">
          十一月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/07 ">
          七月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/02 ">
          二月 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2021/12 ">
          十二月 2021 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2021/09 ">
          九月 2021 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2021/08 ">
          八月 2021 
          <div class="archive-count">3 </div>
        </a>
      
        <a class="archive-link" href="/archives/2021/04 ">
          四月 2021 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2021/02 ">
          二月 2021 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2021/01 ">
          一月 2021 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2020/09 ">
          九月 2020 
          <div class="archive-count">3 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <a class="recent-link" href="/2025/12/23/Agent-5%20Prototype%20to%20Production/" title="AI-Agent 白皮书 5 - Prototype to Production" >
            <div class="recent-link-text">
              AI-Agent 白皮书 5 - Prototype to Production
            </div>
          </a>
        
          <a class="recent-link" href="/2025/12/21/Agent-4%20%20Agent%20Quality/" title="AI-Agent 白皮书 4 - Agent Quality" >
            <div class="recent-link-text">
              AI-Agent 白皮书 4 - Agent Quality
            </div>
          </a>
        
          <a class="recent-link" href="/2025/12/20/Agent-3%20Context%20Engineering/" title="AI-Agent 白皮书 3 - Context Engineering: Sessions & Memory" >
            <div class="recent-link-text">
              AI-Agent 白皮书 3 - Context Engineering: Sessions &amp; Memory
            </div>
          </a>
        
          <a class="recent-link" href="/2025/12/19/Agent-2%20Agent%20Tools%20&%20%20Interoperability%20%20with%20MCP/" title="AI-Agent 白皮书 2 - Agent Tools & Interoperability with MCP" >
            <div class="recent-link-text">
              AI-Agent 白皮书 2 - Agent Tools &amp; Interoperability with MCP
            </div>
          </a>
        
          <a class="recent-link" href="/2025/12/18/Agent-1%20Introduction%20to%20Agents/" title="AI-Agent 白皮书 1 - Introduction to Agents whitepaper" >
            <div class="recent-link-text">
              AI-Agent 白皮书 1 - Introduction to Agents whitepaper
            </div>
          </a>
        
          <a class="recent-link" href="/2025/07/04/Cursor-%E7%BB%93%E6%9E%84%E5%92%8C%E6%8E%A7%E5%88%B6%E6%98%AF%E8%83%9C%E5%88%A9%E4%B9%8B%E9%81%93/" title="Cursor-结构和控制是胜利之道" >
            <div class="recent-link-text">
              Cursor-结构和控制是胜利之道
            </div>
          </a>
        
          <a class="recent-link" href="/2025/05/09/%E5%9F%BA%E4%BA%8EWeb%20Vitals%E7%9A%84%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E8%B0%83%E7%A0%94/" title="基于Web Vitals的秒开优化调研" >
            <div class="recent-link-text">
              基于Web Vitals的秒开优化调研
            </div>
          </a>
        
          <a class="recent-link" href="/2025/04/02/iOS%E4%BD%BF%E7%94%A8Cursor%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/" title="iOS使用Cursor开发配置指南" >
            <div class="recent-link-text">
              iOS使用Cursor开发配置指南
            </div>
          </a>
        
          <a class="recent-link" href="/2025/03/27/iOS-i18n%E5%8A%A8%E6%80%81%E5%8C%96%E6%80%9D%E8%80%83/" title="iOS-i18n动态化思考" >
            <div class="recent-link-text">
              iOS-i18n动态化思考
            </div>
          </a>
        
          <a class="recent-link" href="/2024/11/29/iOS%E8%83%8C%E6%99%AF%E6%A8%A1%E7%B3%8A%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/" title="AI作业背景模糊实现技术方案" >
            <div class="recent-link-text">
              AI作业背景模糊实现技术方案
            </div>
          </a>
        
          <a class="recent-link" href="/2024/05/20/iOS%E7%AB%AF%20ASR%E4%BC%98%E5%8C%96/" title="iOS端 ASR优化" >
            <div class="recent-link-text">
              iOS端 ASR优化
            </div>
          </a>
        
          <a class="recent-link" href="/2024/01/15/ChatGPT%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%89%8B%E5%86%8C/" title="ChatGPT使用技巧手册" >
            <div class="recent-link-text">
              ChatGPT使用技巧手册
            </div>
          </a>
        
          <a class="recent-link" href="/2023/03/12/iOSCrash%E7%B1%BB%E5%9E%8B/" title="iOS Crash类型总结" >
            <div class="recent-link-text">
              iOS Crash类型总结
            </div>
          </a>
        
          <a class="recent-link" href="/2023/03/12/iOS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/" title="iOS文件系统编程指南" >
            <div class="recent-link-text">
              iOS文件系统编程指南
            </div>
          </a>
        
          <a class="recent-link" href="/2022/11/05/iOS%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/" title="iOS签名机制" >
            <div class="recent-link-text">
              iOS签名机制
            </div>
          </a>
        
          <a class="recent-link" href="/2022/07/06/SwiftUI/" title="SwiftUI 从入门到放弃" >
            <div class="recent-link-text">
              SwiftUI 从入门到放弃
            </div>
          </a>
        
          <a class="recent-link" href="/2022/02/28/XCUITest%E6%8E%A2%E7%B4%A2/" title="XCUITest iOS自动化UI测试框架" >
            <div class="recent-link-text">
              XCUITest iOS自动化UI测试框架
            </div>
          </a>
        
          <a class="recent-link" href="/2021/12/06/iOS%20Web%E5%94%A4%E8%B5%B7APP%E6%96%B9%E6%A1%88%E5%8F%82%E8%80%83/" title="iOS 一键唤起APP方案参考" >
            <div class="recent-link-text">
              iOS 一键唤起APP方案参考
            </div>
          </a>
        
          <a class="recent-link" href="/2021/12/06/%E4%BF%A1%E6%81%AF%E6%B5%81GIF%E8%BD%AE%E6%92%AD%E6%A1%86%E6%9E%B6/" title="iOS 如何做一个九宫格GIF播放器" >
            <div class="recent-link-text">
              iOS 如何做一个九宫格GIF播放器
            </div>
          </a>
        
          <a class="recent-link" href="/2021/09/18/iOS%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%BB%84%E4%BB%B6%E7%AF%87/" title="iOS编译优化方案探索与实践-组件篇" >
            <div class="recent-link-text">
              iOS编译优化方案探索与实践-组件篇
            </div>
          </a>
        
          <a class="recent-link" href="/2021/09/09/module-importing%20failed-invalid%20pathname/" title="module importing failed invalid pathname 问题解决" >
            <div class="recent-link-text">
              module importing failed invalid pathname 问题解决
            </div>
          </a>
        
          <a class="recent-link" href="/2021/08/31/iOS-OCR%E5%AE%9E%E8%B7%B5/" title="iOS-OCR实践" >
            <div class="recent-link-text">
              iOS-OCR实践
            </div>
          </a>
        
          <a class="recent-link" href="/2021/08/25/AVPlayer%E7%9B%B8%E5%85%B3BUG%E8%AE%B0%E5%BD%95/" title="AVPlayer相关BUG记录" >
            <div class="recent-link-text">
              AVPlayer相关BUG记录
            </div>
          </a>
        
          <a class="recent-link" href="/2021/08/25/Xcode%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BA%91%E5%90%8C%E6%AD%A5+%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/" title="Xcode代码块云同步+本地安装脚本" >
            <div class="recent-link-text">
              Xcode代码块云同步+本地安装脚本
            </div>
          </a>
        
          <a class="recent-link" href="/2021/04/22/iOS%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%B4%A0%E7%B0%87/" title="iOS字符串安全截取及任意位置插入" >
            <div class="recent-link-text">
              iOS字符串安全截取及任意位置插入
            </div>
          </a>
        
          <a class="recent-link" href="/2021/04/20/NSCache/" title="NSCache" >
            <div class="recent-link-text">
              NSCache
            </div>
          </a>
        
          <a class="recent-link" href="/2021/02/23/%E4%B8%80%E5%B8%96%E7%9C%8B%E9%80%8FiOS14%20%E5%B0%8F%E7%BB%84%E4%BB%B6/" title="一帖看透iOS14 小组件" >
            <div class="recent-link-text">
              一帖看透iOS14 小组件
            </div>
          </a>
        
          <a class="recent-link" href="/2021/01/18/APP%E4%BB%A3%E7%90%86/" title="APP内部代理" >
            <div class="recent-link-text">
              APP内部代理
            </div>
          </a>
        
          <a class="recent-link" href="/2020/09/25/runloop/" title="runloop 学习笔记" >
            <div class="recent-link-text">
              runloop 学习笔记
            </div>
          </a>
        
          <a class="recent-link" href="/2020/09/23/block/" title="__block 关键字探究" >
            <div class="recent-link-text">
              __block 关键字探究
            </div>
          </a>
        
          <a class="recent-link" href="/2020/09/22/GCD/" title="GCD相关知识学习笔记" >
            <div class="recent-link-text">
              GCD相关知识学习笔记
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-Agent-5 Prototype to Production" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        AI-Agent 白皮书 5 - Prototype to Production
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2025-12-22T16:00:00.000Z" itemprop="datePublished">2025-12-23</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/AI-Agent/">AI-Agent</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            54k 词 
          </div>
        </div>
        
      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p><strong>Prototype to  Production</strong></p>
<p><strong>从原型到生产</strong></p>
<p><strong>Authors: Sokratis Kartakis, Gabriela Hernandez Larios, Ran Li, Elia Secchi, and Huang Xia</strong></p>
<p>This whitepaper provides a comprehensive technical guide to the operational life cycle of AI  agents, focusing on deployment, scaling, and productionizing. Building on Day 4’s coverage  of evaluation and observability, this guide emphasizes how to build the necessary trust to  move agents into production through robust CI&#x2F;CD pipelines and scalable infrastructure. It  explores the challenges of transitioning agent-based systems from prototypes to enterprise grade solutions, with special attention to Agent2Agent (A2A) interoperability. This guide  offers practical insights for AI&#x2F;ML engineers, DevOps professionals, and system architects.</p>
<p>本白皮书提供了 AI 智能体运营生命周期的全面技术指南，重点关注部署、扩展和生产化。在第 4 天评估和可观测性内容的基础上，本指南强调如何通过强大的 CI&#x2F;CD 管道和可扩展的基础设施建立必要的信任，将智能体推向生产。它探讨了将基于智能体的系统从原型转变为企业级解决方案的挑战，特别关注 Agent2Agent（A2A）互操作性。本指南为 AI&#x2F;ML 工程师、DevOps 专业人员和系统架构师提供实用洞察。</p>
<p><strong>Introduction: From Prototype</strong><br><strong>to Production</strong></p>
<p><strong>简介：从原型到生产</strong></p>
<p>You can spin up an AI agent prototype in minutes, maybe even seconds. But turning that  clever demo into a trusted, production-grade system that your business can depend on?  That’s where the real work begins. Welcome to the <strong>“last mile” production gap</strong>, where we  consistently observe in practice with customers that roughly 80% of the effort is spent not  on the agent’s core intelligence, but on the infrastructure, security, and validation needed to  make it reliable and safe.</p>
<p>你可以在几分钟甚至几秒钟内启动一个 AI 智能体原型。但要将那个聪明的演示转变为你的业务可以依赖的受信任的生产级系统？真正的工作从这里开始。欢迎来到**”最后一公里”生产差距**，我们在与客户的实践中一直观察到，大约 80% 的工作不是花在智能体的核心智能上，而是花在使其可靠和安全所需的基础设施、安全和验证上。</p>
<p>Skipping these final steps could cause several problems. For example:</p>
<p>跳过这些最后步骤可能会导致几个问题。例如：</p>
<p><strong>• A customer service agent is tricked into giving products away for free</strong> because you  forgot to set up the right guardrails.</p>
<p><strong>• 客服智能体被诱骗免费赠送产品</strong>，因为你忘记设置正确的护栏。</p>
<p><strong>• A user discovers they can access a confidential internal database</strong> through your agent  because authentication was improperly configured.</p>
<p><strong>• 用户发现他们可以通过你的智能体访问机密内部数据库</strong>，因为身份验证配置不当。</p>
<p><strong>• An agent generates a large consumption bill over the weekend</strong>, but no one knows why  because you didn’t set up any monitoring.</p>
<p><strong>• 智能体在周末产生了大额消费账单</strong>，但没人知道为什么，因为你没有设置任何监控。</p>
<p><strong>• A critical agent that worked perfectly yesterday suddenly stops</strong>, but your team is  scrambling because there was no continuous evaluation in place.</p>
<p><strong>• 昨天运行完美的关键智能体突然停止</strong>，但你的团队手忙脚乱，因为没有持续评估机制。</p>
<p>These aren’t just technical problems; they are major business failures. And while principles  from DevOps and MLOps provide a critical foundation, they aren’t enough on their own.  Deploying agentic systems introduces a new class of challenges that require an <strong>evolution  in our operational discipline</strong>. Unlike traditional ML models, agents are autonomously  interactive, stateful, and follow dynamic execution paths.</p>
<p>这些不仅仅是技术问题；它们是重大的业务失败。虽然 DevOps 和 MLOps 的原则提供了关键基础，但仅凭它们是不够的。部署智能体系统引入了一类新的挑战，需要<strong>我们运营纪律的演进</strong>。与传统 ML 模型不同，智能体是自主交互的、有状态的，并遵循动态执行路径。</p>
<p>This creates unique operational headaches that demand specialized strategies:</p>
<p>这造成了独特的运营难题，需要专门的策略：</p>
<p><strong>• Dynamic Tool Orchestration:</strong> An agent’s “trajectory” is assembled on the fly as it picks  and chooses tools. This requires robust versioning, access control, and observability for a  system that behaves differently every time.</p>
<p><strong>• 动态工具编排：</strong> 智能体的”轨迹”在其选择工具时即时组装。这需要强大的版本控制、访问控制和可观测性，因为系统每次的行为都不同。</p>
<p><strong>• Scalable State Management:</strong> Agents can remember things across interactions.  Managing session and memory securely and consistently at scale is a complex systems  design problem.</p>
<p><strong>• 可扩展的状态管理：</strong> 智能体可以跨交互记住事物。大规模安全一致地管理会话和记忆是一个复杂的系统设计问题。</p>
<p><strong>• Unpredictable Cost &amp; Latency:</strong> An agent can take many different paths to find an  answer, making its cost and response time incredibly hard to predict and control without  smart budgeting and caching.</p>
<p><strong>• 不可预测的成本与延迟：</strong> 智能体可以采取许多不同的路径来找到答案，使其成本和响应时间在没有智能预算和缓存的情况下极难预测和控制。</p>
<p>To navigate these challenges successfully, you need a foundation built on three  key pillars: <strong>Automated Evaluation</strong>, <strong>Automated Deployment (CI&#x2F;CD)</strong>, and  <strong>Comprehensive Observability</strong>.</p>
<p>要成功应对这些挑战，你需要建立在三个关键支柱上的基础：<strong>自动化评估</strong>、<strong>自动化部署（CI&#x2F;CD）<strong>和</strong>全面可观测性</strong>。</p>
<p>This whitepaper is your step-by-step playbook for building that foundation and navigating  the path to production! We’ll start with the pre-production essentials, showing you how to  set up automated CI&#x2F;CD pipelines and use rigorous evaluation as a critical quality check.  From there, we’ll dive into the challenges of running agents in the wild, covering strategies for  scaling, performance tuning, and real-time monitoring. Finally, we’ll look ahead to the exciting  world of multi-agent systems with the Agent-to-Agent protocol and explore what it takes to  get them communicating safely and effectively.</p>
<p>本白皮书是你构建该基础并导航生产路径的分步指南！我们将从预生产基础开始，向你展示如何设置自动化 CI&#x2F;CD 管道并使用严格的评估作为关键质量检查。从那里，我们将深入探讨在野外运行智能体的挑战，涵盖扩展、性能调优和实时监控的策略。最后，我们将展望多智能体系统的激动人心的世界，了解 Agent-to-Agent 协议，并探索使它们安全有效通信所需的条件。</p>
<p>![][image1] <strong>Practical Implementation Guide</strong></p>
<p><strong>实践实施指南</strong></p>
<p>Throughout this whitepaper, practical examples reference the Google Cloud Platform  Agent Starter Pack1—1a Python package providing production-ready Generative AI  agent templates for Google Cloud. It includes <strong>pre-built agents</strong>, <strong>automated CI&#x2F;CD  setup</strong>, <strong>Terraform deployment</strong>, <strong>Vertex AI evaluation integration</strong> and built-in Google  Cloud <strong>observability</strong>. The starter pack demonstrates the concepts discussed here  with working code you can deploy in minutes.</p>
<p>在本白皮书中，实际示例引用了 Google Cloud Platform Agent Starter Pack¹——一个为 Google Cloud 提供生产就绪的生成式 AI 智能体模板的 Python 包。它包括<strong>预构建的智能体</strong>、<strong>自动化 CI&#x2F;CD 设置</strong>、<strong>Terraform 部署</strong>、<strong>Vertex AI 评估集成</strong>和内置的 Google Cloud <strong>可观测性</strong>。该入门包用可在几分钟内部署的可工作代码演示了此处讨论的概念。</p>
<p><strong>People and Process</strong></p>
<p><strong>人员与流程</strong></p>
<p>After all that talk of CI&#x2F;CD, observability, and dynamic pipelines, why the focus on people and  process? Because the best technology in the world is ineffective without the right team to  build, manage, and govern it.</p>
<p>在谈论了所有 CI&#x2F;CD、可观测性和动态管道之后，为什么要关注人员和流程？因为世界上最好的技术如果没有合适的团队来构建、管理和治理，也是无效的。</p>
<p>That customer service agent isn’t magically prevented from giving away free products; an  AI Engineer and a Prompt Engineer design and implement the guardrails. The confidential  database isn’t secured by an abstract concept; a Cloud Platform team configures the  authentication. Behind every successful, production-grade agent there is a well-orchestrated  team of specialists, and in this section, we’ll introduce the key players.</p>
<p>那个客服智能体不是被魔法阻止免费赠送产品的；是 AI 工程师和提示工程师设计和实施了护栏。机密数据库不是被抽象概念保护的；是云平台团队配置了身份验证。每个成功的生产级智能体背后都有一个协调良好的专家团队，在本节中，我们将介绍关键参与者。</p>
<p>![][image2]<br>Figure 1: A diagram showing that “Ops” is the intersection of people, processes, and technology</p>
<p>图 1：显示”Ops”是人员、流程和技术交汇点的图表</p>
<p>In a traditional MLOps landscape, this involves several key teams:</p>
<p>在传统的 MLOps 环境中，这涉及几个关键团队：</p>
<p><strong>• Cloud Platform Team:</strong> Comprising cloud architects, administrators, and security  specialists, this team manages the foundational cloud infrastructure, security, and access  control. The team grants engineers and service accounts least-privilege roles, ensuring  access only to necessary resources.</p>
<p><strong>• 云平台团队：</strong> 由云架构师、管理员和安全专家组成，该团队管理基础云基础设施、安全和访问控制。该团队授予工程师和服务账户最小权限角色，确保只能访问必要的资源。</p>
<p><strong>• Data Engineering Team:</strong> Data engineers and data owners build and maintain the data  pipelines, handling ingestion, preparation, and quality standards.</p>
<p><strong>• 数据工程团队：</strong> 数据工程师和数据所有者构建和维护数据管道，处理摄取、准备和质量标准。</p>
<p><strong>• Data Science and MLOps Team:</strong> This includes data scientists who experiment with  and train models, and ML engineers who automate the end-to-end ML pipeline (e.g.,  preprocessing, training, post-processing) at scale using CI&#x2F;CD. MLOps Engineers support  this by building and maintaining the standardized pipeline infrastructure.</p>
<p><strong>• 数据科学和 MLOps 团队：</strong> 这包括实验和训练模型的数据科学家，以及使用 CI&#x2F;CD 大规模自动化端到端 ML 管道（如预处理、训练、后处理）的 ML 工程师。MLOps 工程师通过构建和维护标准化管道基础设施来支持这一点。</p>
<p><strong>• Machine Learning Governance:</strong> This centralized function, including product owners  and auditors, oversees the ML lifecycle, acting as a repository for artifacts and metrics to  ensure compliance, transparency, and accountability .</p>
<p><strong>• 机器学习治理：</strong> 这一集中功能，包括产品负责人和审计员，监督 ML 生命周期，作为工件和指标的存储库，以确保合规性、透明度和问责制。</p>
<p>Generative AI introduces a new layer of complexity and specialized roles to this landscape:</p>
<p>生成式 AI 为这一领域引入了新的复杂性层次和专业角色：</p>
<p><strong>• Prompt Engineers:</strong> While this role title is still evolving in the industry, these individuals  blend technical skill in crafting prompts with deep domain expertise. They define the  right questions and expected answers from a model, though in practice this work may  be done by AI Engineers, domain experts, or dedicated specialists depending on the  organization’s maturity.</p>
<p><strong>• 提示工程师：</strong> 虽然这个角色名称在行业中仍在演变，但这些人将制作提示的技术技能与深厚的领域专业知识相结合。他们定义模型的正确问题和预期答案，尽管在实践中，这项工作可能由 AI 工程师、领域专家或专门的专家完成，具体取决于组织的成熟度。</p>
<p><strong>• AI Engineers:</strong> They are responsible for scaling GenAI solutions to production, building  robust backend systems that incorporate evaluation at scale, guardrails, and RAG&#x2F;tool  integration .</p>
<p><strong>• AI 工程师：</strong> 他们负责将 GenAI 解决方案扩展到生产，构建包含大规模评估、护栏和 RAG&#x2F;工具集成的强大后端系统。</p>
<p><strong>• DevOps&#x2F;App Developers:</strong> These developers build the front-end components and user friendly interfaces that integrate with the GenAI backend.</p>
<p><strong>• DevOps&#x2F;应用开发人员：</strong> 这些开发人员构建与 GenAI 后端集成的前端组件和用户友好界面。</p>
<p>The scale and structure of an organization will influence these roles; in smaller companies,  individuals may wear multiple hats, while mature organizations will have more specialized  teams. Effectively coordinating all these diverse roles is essential for establishing a robust  operational foundation and successfully productionizing both traditional ML and generative  AI initiatives.</p>
<p>组织的规模和结构会影响这些角色；在较小的公司中，个人可能身兼数职，而成熟的组织将拥有更专业化的团队。有效协调所有这些不同的角色对于建立强大的运营基础并成功地将传统 ML 和生成式 AI 计划投入生产至关重要。</p>
<p>![][image3]<br>Figure 2: How multiple teams collaborate to operationalize both models and GenAI applications</p>
<p>图 2：多个团队如何协作以将模型和 GenAI 应用程序投入运营</p>
<p><strong>The Journey to Production</strong></p>
<p><strong>生产之旅</strong></p>
<p>Now that we’ve established the team, we turn to the process. How do we translate the work  of all these specialists into a system that is trustworthy, reliable, and ready for users?</p>
<p>现在我们已经建立了团队，我们转向流程。我们如何将所有这些专家的工作转化为一个值得信赖、可靠且可供用户使用的系统？</p>
<p>The answer lies in a disciplined pre-production process built on a single core principle:  <strong>Evaluation-Gated Deployment</strong>. The idea is simple but powerful: no agent version should  reach users without first passing a comprehensive evaluation that proves its quality and  safety. This pre-production phase is where we trade manual uncertainty for automated  confidence, and it consists of three pillars: a rigorous evaluation process that acts as a  quality gate, an automated CI&#x2F;CD pipeline that enforces it, and safe rollout strategies to  de-risk the final step into production.</p>
<p>答案在于建立在单一核心原则之上的纪律严明的预生产流程：<strong>评估门控部署</strong>。这个想法简单但强大：任何智能体版本都不应在未首先通过证明其质量和安全性的全面评估的情况下到达用户。这个预生产阶段是我们用自动化信心换取手动不确定性的地方，它由三个支柱组成：作为质量门控的严格评估流程、执行它的自动化 CI&#x2F;CD 管道，以及降低进入生产最后一步风险的安全发布策略。</p>
<p><strong>Evaluation as a Quality Gate</strong></p>
<p><strong>评估作为质量门控</strong></p>
<p>Why do we need a special quality gate for agents? Traditional software tests are insufficient  for systems that reason and adapt. Furthermore, evaluating an agent is distinct from  evaluating an LLM; it requires assessing not just the final answer, but the entire trajectory  of reasoning and actions taken to complete a task. An agent can pass 100 unit tests for its  tools but still fail spectacularly by choosing the wrong tool or hallucinating a response. We  need to evaluate its <em>behavioral quality</em>, not just its functional correctness. This gate can be  implemented in two primary ways:</p>
<p>为什么我们需要针对智能体的特殊质量门控？传统软件测试对于推理和适应的系统是不够的。此外，评估智能体不同于评估 LLM；它需要评估的不仅仅是最终答案，还有完成任务所采取的整个推理和行动轨迹。一个智能体可以通过其工具的 100 个单元测试，但仍然可能因选择错误的工具或产生幻觉响应而惨败。我们需要评估它的<em>行为质量</em>，而不仅仅是其功能正确性。这个门控可以通过两种主要方式实现：</p>
<p><strong>1. The Manual “Pre-PR” Evaluation:</strong> For teams seeking flexibility or just beginning their  evaluation journey, the quality gate is enforced through a team process. Before submitting  a pull request (PR), the <strong>AI Engineer</strong> or <strong>Prompt Engineer</strong> (or whoever is responsible  for agent behavior in your organization) runs the evaluation suite locally. The resulting  performance report—comparing the new agent against the production baseline—is then  linked in the PR description. This makes the evaluation results a mandatory artifact for  human review. The reviewer—typically another <strong>AI Engineer</strong> or the <strong>Machine Learning  Governor</strong>—is now responsible for assessing not just the code, but also the agent’s  behavioral changes against guardrail violations and prompt injection vulnerabilities.</p>
<p><strong>1. 手动”Pre-PR”评估：</strong> 对于寻求灵活性或刚刚开始评估之旅的团队，质量门控通过团队流程来执行。在提交拉取请求（PR）之前，<strong>AI 工程师</strong>或<strong>提示工程师</strong>（或在您的组织中负责智能体行为的任何人）在本地运行评估套件。然后将生成的性能报告（将新智能体与生产基线进行比较）链接到 PR 描述中。这使得评估结果成为人工审查的强制性工件。审查者——通常是另一位 <strong>AI 工程师</strong>或<strong>机器学习治理人员</strong>——现在不仅负责评估代码，还负责评估智能体针对护栏违规和提示注入漏洞的行为变化。</p>
<p><strong>2. The Automated In-Pipeline Gate:</strong> For mature teams, the evaluation harness—built and  maintained by the <strong>Data Science and MLOps Team</strong>—is integrated directly into the CI&#x2F; CD pipeline. A failing evaluation automatically blocks the deployment, providing rigid,</p>
<p>programmatic enforcement of quality standards that the <strong>Machine Learning Governance</strong> team has defined. This approach trades the flexibility of manual review for the consistency  of automation. The CI&#x2F;CD pipeline can be configured to automatically trigger an evaluation  job that compares the new agent’s responses against a golden dataset. The deployment is</p>
<p>programmatically blocked if key metrics, such as “tool call success rate” or “helpfulness,”  fall below a predefined threshold.</p>
<p><strong>2. 自动化管道内门控：</strong> 对于成熟的团队，由<strong>数据科学和 MLOps 团队</strong>构建和维护的评估框架直接集成到 CI&#x2F;CD 管道中。评估失败会自动阻止部署，提供<strong>机器学习治理</strong>团队定义的质量标准的严格程序化执行。这种方法以自动化的一致性换取手动审查的灵活性。CI&#x2F;CD 管道可以配置为自动触发评估作业，将新智能体的响应与黄金数据集进行比较。如果关键指标（如”工具调用成功率”或”有用性”）低于预定义阈值，则以编程方式阻止部署。</p>
<p>Regardless of the method, the principle is the same: no agent proceeds to production  without a quality check. We covered the specifics of what to measure and how to build this  evaluation harness in our deep dive on <strong>Day 4: Agent Quality: Observability, Logging,  Tracing, Evaluation, Metrics</strong>, which explored everything from crafting a ‘golden dataset’ (a  curated, representative set of test cases designed to assess an agent’s intended behavior  and guardrail compliance) to implementing LLM-as-a-judge techniques, to finally using a  service like Vertex AI Evaluation2 to power evaluation.</p>
<p>无论采用哪种方法，原则都是相同的：没有智能体在没有质量检查的情况下进入生产。我们在<strong>第 4 天：智能体质量：可观测性、日志记录、追踪、评估、指标</strong>的深入探讨中涵盖了衡量什么以及如何构建此评估框架的具体内容，其中探讨了从制作”黄金数据集”（旨在评估智能体预期行为和护栏合规性的精选代表性测试用例集）到实施 LLM 即评判者技术，再到最终使用像 Vertex AI Evaluation² 这样的服务来支持评估的所有内容。</p>
<p><strong>The Automated CI&#x2F;CD Pipeline</strong></p>
<p><strong>自动化 CI&#x2F;CD 管道</strong></p>
<p>An AI agent is a composite system, comprising not just source code but also prompts, tool  definitions, and configuration files. This complexity introduces significant challenges: how do  we ensure a change to a prompt doesn’t degrade the performance of a tool? How do we test  the interplay between all these artifacts before they reach users?</p>
<p>AI 智能体是一个复合系统，不仅包括源代码，还包括提示、工具定义和配置文件。这种复杂性带来了重大挑战：我们如何确保对提示的更改不会降低工具的性能？我们如何在这些工件到达用户之前测试它们之间的相互作用？</p>
<p>The solution is a CI&#x2F;CD (Continuous Integration&#x2F;Continuous Deployment) pipeline. It is more  than just an automation script; it’s a structured process that helps different people in a team  collaborate to manage complexity and ensure quality. It works by testing changes in stages,  incrementally building confidence before the agent is released to users.</p>
<p>解决方案是 CI&#x2F;CD（持续集成&#x2F;持续部署）管道。它不仅仅是一个自动化脚本；它是一个结构化的流程，帮助团队中的不同人员协作管理复杂性并确保质量。它通过分阶段测试更改来工作，在智能体发布给用户之前逐步建立信心。</p>
<p>A robust pipeline is designed as a funnel. It catches errors as early and as cheaply as  possible, a practice often called “shifting left.” It separates fast, pre-merge checks from more  comprehensive, resource-intensive post-merge deployments. This progressive workflow is  typically structured into three distinct phases:</p>
<p>强大的管道被设计成漏斗状。它尽可能早地、以最低成本捕获错误，这种做法通常被称为”左移”。它将快速的合并前检查与更全面的、资源密集的合并后部署分开。这种渐进式工作流通常被组织成三个不同的阶段：</p>
<p><strong>1. Phase 1: Pre-Merge Integration (CI)</strong>. The pipeline’s first responsibility is to provide  rapid feedback to the <strong>AI Engineer</strong> or <strong>Prompt Engineer</strong> who has opened a pull request.  Triggered automatically, this CI phase acts as a gatekeeper for the main branch. It runs  fast checks like unit tests, code linting, and dependency scanning. Crucially, this is the</p>
<p><strong>1. 阶段 1：合并前集成（CI）</strong>。管道的首要职责是向打开拉取请求的 <strong>AI 工程师</strong>或<strong>提示工程师</strong>提供快速反馈。自动触发的这个 CI 阶段充当主分支的守门人。它运行快速检查，如单元测试、代码检查和依赖扫描。至关重要的是，这是</p>
<p>ideal stage to run the <strong>agent quality evaluation suite</strong> designed by Prompt Engineers.  This provides immediate feedback on whether a change improves or degrades the agent’s  performance against key scenarios before it is ever merged. By catching issues here, we  prevent polluting the main branch. The PR checks configuration template3 generated  with the Agent Starter Pack1 (ASP) is a practical example of implementing this phase with  Cloud Build.4</p>
<p>运行由提示工程师设计的<strong>智能体质量评估套件</strong>的理想阶段。这在更改合并之前提供关于更改是否改进或降低智能体针对关键场景的性能的即时反馈。通过在这里捕获问题，我们防止污染主分支。使用 Agent Starter Pack¹（ASP）生成的 PR 检查配置模板³是使用 Cloud Build⁴ 实现此阶段的实际示例。</p>
<p><strong>2. Phase 2: Post-Merge Validation in Staging (CD)</strong>. Once a change passes all CI checks— including the performance evaluation—and is merged, the focus shifts from code and  performance correctness to the operational readiness of the integrated system. The  Continuous Deployment (CD) process, often managed by the <strong>MLOps Team</strong>, packages  the agent and deploys it to a staging environment—a high-fidelity replica of production.  Here, more comprehensive, resource-intensive tests are run, such as <strong>load testing</strong> and  <strong>integration tests</strong> against remote services. This is also the critical phase for internal user  testing (often called “dogfooding”), where humans within the company can interact with  the agent and provide qualitative feedback before it reaches the end user. This ensures  that the agent as an <em>integrated system</em> performs reliably and efficiently under production like conditions before it is considered for release. The staging deployment template5 from  ASP shows an example of this deployment.</p>
<p><strong>2. 阶段 2：暂存环境中的合并后验证（CD）</strong>。一旦更改通过所有 CI 检查（包括性能评估）并被合并，焦点就从代码和性能正确性转移到集成系统的运营准备就绪。持续部署（CD）流程，通常由 <strong>MLOps 团队</strong>管理，打包智能体并将其部署到暂存环境——生产的高保真副本。在这里，运行更全面的、资源密集的测试，如<strong>负载测试</strong>和针对远程服务的<strong>集成测试</strong>。这也是内部用户测试（通常称为”dogfooding”）的关键阶段，公司内部的人员可以与智能体交互并在其到达最终用户之前提供定性反馈。这确保了智能体作为一个<em>集成系统</em>在被考虑发布之前在类生产条件下可靠高效地运行。ASP 的暂存部署模板⁵展示了此部署的示例。</p>
<p><strong>3. Phase 3: Gated Deployment to Production</strong>. After the agent has been thoroughly  validated in the staging environment, the final step is deploying to production. This  is almost never fully automatic, typically requiring a <strong>Product Owner</strong> to give the final  sign-off, ensuring human-in-the-loop. Upon approval, the exact deployment artifact  that was tested and validated in staging is promoted to the production environment.  This production deployment template6 generated with ASP shows how this final phase  retrieves the validated artifact and deploys it to production with appropriate safeguards.</p>
<p><strong>3. 阶段 3：门控部署到生产</strong>。在智能体在暂存环境中经过彻底验证后，最后一步是部署到生产。这几乎从不是完全自动的，通常需要<strong>产品负责人</strong>做最终签字，确保人机协同。批准后，在暂存中测试和验证的确切部署工件被提升到生产环境。使用 ASP 生成的此生产部署模板⁶展示了这个最终阶段如何检索已验证的工件并以适当的保障措施将其部署到生产。</p>
<p>![][image4]<br>Figure 3: Different stages of the CI&#x2F;CD process</p>
<p>图 3：CI&#x2F;CD 流程的不同阶段</p>
<p>Making this three-phase CI&#x2F;CD workflow possible requires robust automation infrastructure  and proper secrets management. This automation is powered by two key technologies:</p>
<p>使这个三阶段 CI&#x2F;CD 工作流成为可能需要强大的自动化基础设施和适当的密钥管理。这种自动化由两项关键技术驱动：</p>
<p><strong>• Infrastructure as Code (IaC):</strong> Tools like Terraform define environments programmatically,  ensuring they are identical, repeatable, and version-controlled. For example, this template  generated with Agent Starter Pack7 provides Terraform configurations for complete  agent infrastructure including Vertex AI, Cloud Run, and BigQuery resources.</p>
<p><strong>• 基础设施即代码（IaC）：</strong> 像 Terraform 这样的工具以编程方式定义环境，确保它们是相同的、可重复的和版本控制的。例如，使用 Agent Starter Pack⁷ 生成的此模板提供了完整智能体基础设施的 Terraform 配置，包括 Vertex AI、Cloud Run 和 BigQuery 资源。</p>
<p><strong>• Automated Testing Frameworks:</strong> Frameworks like Pytest execute tests and evaluations  at each stage, handling agent-specific artifacts like conversation histories, tool invocation  logs, and dynamic reasoning traces.</p>
<p><strong>• 自动化测试框架：</strong> 像 Pytest 这样的框架在每个阶段执行测试和评估，处理智能体特定的工件，如对话历史、工具调用日志和动态推理追踪。</p>
<p>Furthermore, sensitive information like API keys for tools should be managed securely using  a service like Secret Manager8 and injected into the agent’s environment at runtime, rather  than being hardcoded in the repository.</p>
<p>此外，工具的 API 密钥等敏感信息应使用像 Secret Manager⁸ 这样的服务安全管理，并在运行时注入到智能体的环境中，而不是在存储库中硬编码。</p>
<p><strong>Safe Rollout Strategies</strong></p>
<p><strong>安全发布策略</strong></p>
<p>While comprehensive pre-production checks are essential, real-world application inevitably  reveals unforeseen issues. Rather than switching 100% of users at once, consider minimizing  risk through gradual rollouts with careful monitoring.</p>
<p>虽然全面的预生产检查是必不可少的，但真实世界的应用不可避免地会揭示不可预见的问题。与其一次性切换 100% 的用户，不如考虑通过谨慎监控的渐进式发布来最小化风险。</p>
<p>Here are four proven patterns that help teams build confidence in their deployments:</p>
<p>以下是帮助团队对其部署建立信心的四种经过验证的模式：</p>
<p><strong>• Canary:</strong> Start with 1% of users, monitoring for prompt injections and unexpected tool  usage. Scale up gradually or roll back instantly.</p>
<p><strong>• 金丝雀发布：</strong> 从 1% 的用户开始，监控提示注入和意外的工具使用。逐步扩大规模或立即回滚。</p>
<p><strong>• Blue-Green:</strong> Run two identical production environments. Route traffic to “blue” while  deploying to “green,” then switch instantly. If issues emerge, switch back—zero downtime,  instant recovery.</p>
<p><strong>• 蓝绿部署：</strong> 运行两个相同的生产环境。在部署到”绿色”时将流量路由到”蓝色”，然后立即切换。如果出现问题，切换回来——零停机时间，即时恢复。</p>
<p><strong>• A&#x2F;B Testing:</strong> Compare agent versions on real business metrics for data-driven decisions.  This can happen either with internal or external users.</p>
<p><strong>• A&#x2F;B 测试：</strong> 在真实业务指标上比较智能体版本，以进行数据驱动的决策。这可以与内部或外部用户一起进行。</p>
<p><strong>• Feature Flags:</strong> Deploy code but control release dynamically, testing new capabilities with  select users first.</p>
<p><strong>• 功能标志：</strong> 部署代码但动态控制发布，首先与选定的用户测试新功能。</p>
<p>All these strategies share a foundation: <strong>rigorous versioning</strong>. Every component—code,  prompts, model endpoints, tool schemas, memory structures, even evaluation datasets— must be versioned. When issues arise despite safeguards, this enables instant rollback to a  known-good state. See this as your production “undo” button!</p>
<p>所有这些策略都有一个共同的基础：<strong>严格的版本控制</strong>。每个组件——代码、提示、模型端点、工具模式、记忆结构，甚至评估数据集——都必须进行版本控制。当尽管有保障措施但仍出现问题时，这可以立即回滚到已知良好状态。将此视为您的生产”撤销”按钮！</p>
<p>You can deploy agents using Agent Engine9 or Cloud Run10, then leverage Cloud Load  Balancing11 for traffic management across versions or connect to other microservices. The  Agent Starter Pack1 provides ready-to-use templates with GitOps workflows—where every  deployment is a git commit, every rollback is a git revert, and your repository becomes the  single source of truth for both current state and complete deployment history.</p>
<p>您可以使用 Agent Engine⁹ 或 Cloud Run¹⁰ 部署智能体，然后利用 Cloud Load Balancing¹¹ 进行跨版本的流量管理或连接到其他微服务。Agent Starter Pack¹ 提供了带有 GitOps 工作流的即用模板——每次部署都是一次 git 提交，每次回滚都是一次 git 还原，您的存储库成为当前状态和完整部署历史的单一事实来源。</p>
<p><strong>Building Security from the Start</strong></p>
<p><strong>从一开始就构建安全性</strong></p>
<p>Safe deployment strategies protect you from bugs and outages, but agents face a unique  challenge: they can reason and act autonomously. A perfectly deployed agent can still cause  harm if it hasn’t been built with proper security and responsibility measures. This requires a  comprehensive governance strategy embedded from day one, not added as an afterthought.</p>
<p>安全的部署策略可以保护您免受错误和中断的影响，但智能体面临着独特的挑战：它们可以自主推理和行动。即使部署完美的智能体，如果没有构建适当的安全和责任措施，仍然可能造成伤害。这需要从第一天就嵌入全面的治理策略，而不是事后添加。</p>
<p>Unlike traditional software that follows predetermined paths, agents make decisions. They  interpret ambiguous requests, access multiple tools, and maintain memory across sessions.  This autonomy creates distinct risks:</p>
<p>与遵循预定路径的传统软件不同，智能体做出决策。它们解释模糊的请求，访问多个工具，并在会话之间维护记忆。这种自主性创造了独特的风险：</p>
<p><strong>• Prompt Injection &amp; Rogue Actions:</strong> Malicious users can trick agents into performing  unintended actions or bypassing restrictions.</p>
<p><strong>• 提示注入和流氓行为：</strong> 恶意用户可以诱骗智能体执行意外操作或绕过限制。</p>
<p><strong>• Data Leakage:</strong> Agents might inadvertently expose sensitive information through their  responses or tool usage.</p>
<p><strong>• 数据泄露：</strong> 智能体可能通过其响应或工具使用无意中暴露敏感信息。</p>
<p><strong>• Memory Poisoning:</strong> False information stored in an agent’s memory can corrupt all  future interactions.</p>
<p><strong>• 记忆投毒：</strong> 存储在智能体记忆中的虚假信息可能会破坏所有未来的交互。</p>
<p>Fortunately, frameworks like Google’s Secure AI Agents approach12 and the Google Secure  AI Framework (SAIF)13 address these challenges through three layers of defense:</p>
<p>幸运的是，像 Google 的安全 AI 智能体方法¹² 和 Google 安全 AI 框架（SAIF）¹³ 这样的框架通过三层防御来解决这些挑战：</p>
<p><strong>1. Policy Definition and System Instructions (The Agent’s Constitution):</strong> The process  begins by defining policies for desired and undesired agent behavior. These are  engineered into <strong>System Instructions (SIs)</strong> that act as the agent’s core constitution.</p>
<p><strong>1. 策略定义和系统指令（智能体的宪法）：</strong> 流程从定义期望和不期望的智能体行为策略开始。这些被设计成<strong>系统指令（SI）</strong>，作为智能体的核心宪法。</p>
<p><strong>2. Guardrails, Safeguards, and Filtering (The Enforcement Layer):</strong> This layer acts as the  hard-stop enforcement mechanism.</p>
<p><strong>2. 护栏、保障措施和过滤（执行层）：</strong> 该层充当硬停止执行机制。</p>
<p><strong>• Input Filtering:</strong> Use classifiers and services like the Perspective API to analyze prompts  and block malicious inputs before they reach the agent.</p>
<p><strong>• 输入过滤：</strong> 使用分类器和像 Perspective API 这样的服务来分析提示，并在恶意输入到达智能体之前阻止它们。</p>
<p><strong>• Output Filtering:</strong> After the agent generates a response, <strong>Vertex AI’s built-in safety  filters</strong> provide a final check for harmful content, PII, or policy violations. For example,  before a response is sent to the user, it is passed through Vertex AI’s built-in safety  filters14, which can be configured to block outputs containing specific PII, toxic  language, or other harmful content.</p>
<p><strong>• 输出过滤：</strong> 在智能体生成响应后，<strong>Vertex AI 的内置安全过滤器</strong>提供对有害内容、PII 或政策违规的最终检查。例如，在将响应发送给用户之前，它会通过 Vertex AI 的内置安全过滤器¹⁴，可以配置为阻止包含特定 PII、有毒语言或其他有害内容的输出。</p>
<p><strong>• Human-in-the-Loop (HITL) Escalation:</strong> For high-risk or ambiguous actions, the  system must pause and escalate to a human for review and approval.</p>
<p><strong>• 人机协同（HITL）升级：</strong> 对于高风险或模糊的操作，系统必须暂停并升级给人类进行审查和批准。</p>
<p><strong>3. Continuous Assurance and Testing:</strong> Safety is not a one-time setup. It requires constant  evaluation and adaptation.</p>
<p><strong>3. 持续保证和测试：</strong> 安全不是一次性设置。它需要持续的评估和适应。</p>
<p><strong>• Rigorous Evaluation:</strong> Any change to the model or its safety systems must trigger a full  re-run of a comprehensive evaluation pipeline using <strong>Vertex AI Evaluation</strong>.</p>
<p><strong>• 严格评估：</strong> 对模型或其安全系统的任何更改都必须触发使用 <strong>Vertex AI Evaluation</strong> 的综合评估管道的完整重新运行。</p>
<p><strong>• Dedicated RAI Testing:</strong> Rigorously test for specific risks either by creating dedicated  datasets or using simulation agents, including <strong>Neutral Point of View (NPOV)  evaluations</strong> and <strong>Parity evaluations</strong>.</p>
<p><strong>• 专门的 RAI 测试：</strong> 通过创建专用数据集或使用模拟智能体来严格测试特定风险，包括<strong>中立观点（NPOV）评估</strong>和<strong>对等性评估</strong>。</p>
<p><strong>• Proactive Red Teaming:</strong> Actively try to break the safety systems through creative  manual testing and AI-driven <strong>persona-based simulation</strong>.</p>
<p><strong>• 主动红队测试：</strong> 通过创造性的手动测试和 AI 驱动的<strong>基于角色的模拟</strong>主动尝试破坏安全系统。</p>
<p><strong>Operations in-Production</strong></p>
<p><strong>生产中的运营</strong></p>
<p>Your agent is live. Now the focus shifts from development to a fundamentally different  challenge: <strong>keeping the system reliable</strong>, <strong>cost-effective</strong>, <strong>and safe as it interacts with  thousands of users</strong>. A traditional service operates on predictable logic. An agent, in  contrast, is an autonomous actor. Its ability to follow unexpected reasoning paths means it  can exhibit emergent behaviors and accumulate costs without direct oversight.</p>
<p>您的智能体已上线。现在焦点从开发转移到一个根本不同的挑战：<strong>在与数千名用户交互时保持系统可靠</strong>、<strong>具有成本效益</strong>和<strong>安全</strong>。传统服务按可预测的逻辑运行。相比之下，智能体是一个自主行动者。它遵循意外推理路径的能力意味着它可以在没有直接监督的情况下展现涌现行为并累积成本。</p>
<p>Managing this autonomy requires a different operational model. Instead of static monitoring,  effective teams adopt a continuous loop: Observe the system’s behavior in real-time, Act to  maintain performance and safety, and Evolve the agent based on production learnings. This  integrated cycle is the core discipline for operating agents successfully in production.</p>
<p>管理这种自主性需要不同的运营模式。有效的团队不是静态监控，而是采用持续循环：实时观察系统行为，采取行动以维护性能和安全，并根据生产学习来演进智能体。这个集成循环是在生产中成功运营智能体的核心纪律。</p>
<p><strong>Observe: Your Agent’s Sensory System</strong></p>
<p><strong>观察：智能体的感知系统</strong></p>
<p>To trust and manage an autonomous agent, you must first understand its process.  Observability provides this crucial insight, acting as the sensory system for the subsequent  “Act” and “Evolve” phases. A robust observability practice is built on three pillars that work  together to provide a complete picture of the agent’s behavior:</p>
<p>要信任和管理自主智能体，您必须首先了解其过程。可观测性提供这种关键洞察，作为后续”行动”和”演进”阶段的感知系统。强大的可观测性实践建立在三个支柱之上，它们协同工作以提供智能体行为的完整画面：</p>
<p><strong>• Logs:</strong> The granular, factual diary of what happened, recording every tool call, error,  and decision.</p>
<p><strong>• 日志：</strong> 发生事情的细粒度、事实性日记，记录每个工具调用、错误和决策。</p>
<p><strong>• Traces:</strong> The narrative that connects individual logs, revealing the causal path of why an  agent took a certain action.</p>
<p><strong>• 追踪：</strong> 连接单个日志的叙事，揭示智能体为何采取某种行动的因果路径。</p>
<p><strong>• Metrics:</strong> The aggregated report card, summarizing performance, cost, and operational  health at scale to show how well the system is performing.</p>
<p><strong>• 指标：</strong> 汇总的成绩单，大规模总结性能、成本和运营健康状况，以显示系统运行得有多好。</p>
<p>For example, in Google Cloud, this is achieved through the operations suite: a user’s request  generates a unique ID in Cloud Trace15 that links the Vertex AI Agent Engine9 invocation,  model calls, and tool executions with visible durations. Detailed logs flow to Cloud Logging16,  while Cloud Monitoring17 dashboards alert when latency thresholds are exceeded. The  Agent Development Kit (ADK)18 provides built-in Cloud Trace integration for automatic  instrumentation of agent operations.</p>
<p>例如，在 Google Cloud 中，这是通过运维套件实现的：用户的请求在 Cloud Trace¹⁵ 中生成唯一 ID，将 Vertex AI Agent Engine⁹ 调用、模型调用和工具执行与可见的持续时间链接起来。详细日志流入 Cloud Logging¹⁶，而 Cloud Monitoring¹⁷ 仪表板在超过延迟阈值时发出警报。Agent Development Kit（ADK）¹⁸ 提供内置的 Cloud Trace 集成，用于自动检测智能体操作。</p>
<p>By implementing these pillars, we move from operating in the dark to having a clear, data driven view of our agent’s behavior, providing the foundation needed to manage it effectively  in production. (For a full discussion of these concepts, see <strong>Agent Quality: Observability,  Logging, Tracing, Evaluation, Metrics</strong>).</p>
<p>通过实施这些支柱，我们从在黑暗中运营转变为对智能体行为拥有清晰的、数据驱动的视图，提供在生产中有效管理它所需的基础。（有关这些概念的完整讨论，请参阅<strong>智能体质量：可观测性、日志记录、追踪、评估、指标</strong>）。</p>
<p><strong>Act: The Levers of Operational Control</strong></p>
<p><strong>行动：运营控制的杠杆</strong></p>
<p>Observations without action are just expensive dashboards. The “Act” phase is about real time intervention—the levers you pull to manage the agent’s performance, cost, and safety  based on what you observe.</p>
<p>没有行动的观察只是昂贵的仪表板。”行动”阶段是关于实时干预的——根据你观察到的情况来拉动管理智能体性能、成本和安全的杠杆。</p>
<p>Think of “Act” as the system’s automated reflexes designed to maintain stability in real-time.  In contrast, “Evolve”, which will be covered later, is the strategic process of learning from  behavior to create a fundamentally better system.</p>
<p>将”行动”视为旨在实时维持稳定性的系统自动化反射。相比之下，稍后将介绍的”演进”是从行为中学习以创建根本上更好的系统的战略过程。</p>
<p>Because an agent is autonomous, you cannot pre-program every possible outcome. Instead,  you must build robust mechanisms to influence its behavior in production. These operational  levers fall into two primary categories: managing the system’s health and managing its risk.</p>
<p>因为智能体是自主的，所以你无法预先编程每一种可能的结果。相反，你必须构建强大的机制来影响其在生产中的行为。这些运营杠杆分为两个主要类别：管理系统健康和管理风险。</p>
<p><strong>Managing System Health: Performance, Cost, and Scale</strong></p>
<p><strong>管理系统健康：性能、成本和规模</strong></p>
<p>Unlike traditional microservices, an agent’s workload is dynamic and stateful. Managing its  health requires a strategy for handling this unpredictability.</p>
<p>与传统微服务不同，智能体的工作负载是动态和有状态的。管理其健康需要一种处理这种不可预测性的策略。</p>
<p><strong>• Designing for Scale:</strong> The foundation is decoupling the agent’s logic from its state.</p>
<p><strong>• 为规模而设计：</strong> 基础是将智能体的逻辑与其状态解耦。</p>
<p><strong>• Horizontal Scaling:</strong> Design the agent as a stateless, containerized service. With  external state, any instance can handle any request, enabling serverless platforms like  Cloud Run10 or the managed Vertex AI Agent Engine Runtime9 to scale automatically.</p>
<p><strong>• 水平扩展：</strong> 将智能体设计为无状态的容器化服务。使用外部状态，任何实例都可以处理任何请求，使像 Cloud Run¹⁰ 或托管的 Vertex AI Agent Engine Runtime⁹ 这样的无服务器平台能够自动扩展。</p>
<p><strong>• Asynchronous Processing:</strong> For long-running tasks, offload work using event driven patterns. This keeps the agent responsive while complex jobs process in the  background. On Google Cloud, for example, a service can publish tasks to Pub&#x2F;Sub19,  which can then trigger a Cloud Run service for asynchronous processing.</p>
<p><strong>• 异步处理：</strong> 对于长时间运行的任务，使用事件驱动模式卸载工作。这使智能体保持响应性，同时复杂的作业在后台处理。例如，在 Google Cloud 上，服务可以将任务发布到 Pub&#x2F;Sub¹⁹，然后可以触发 Cloud Run 服务进行异步处理。</p>
<p><strong>• Externalized State Management:</strong> Since LLMs are stateless, persisting memory  externally is non-negotiable. This highlights a key architectural choice: <strong>Vertex AI Agent  Engine</strong> provides a built-in, durable Session and memory service, while <strong>Cloud Run</strong> offers the flexibility to integrate directly with databases like AlloyDB20 or Cloud SQL21.</p>
<p><strong>• 外部化状态管理：</strong> 由于 LLM 是无状态的，外部持久化记忆是不可妥协的。这突出了一个关键的架构选择：<strong>Vertex AI Agent Engine</strong> 提供内置的、持久的会话和记忆服务，而 <strong>Cloud Run</strong> 提供直接与 AlloyDB²⁰ 或 Cloud SQL²¹ 等数据库集成的灵活性。</p>
<p><strong>• Balancing Competing Goals:</strong> Scaling always involves balancing three competing goals:  speed, reliability, and cost.</p>
<p><strong>• 平衡竞争目标：</strong> 扩展总是涉及平衡三个竞争目标：速度、可靠性和成本。</p>
<p><strong>• Speed (Latency):</strong> Keep your agent fast by designing it to work in parallel, aggressively  caching results, and using smaller, efficient models for routine tasks.</p>
<p><strong>• 速度（延迟）：</strong> 通过将智能体设计为并行工作、积极缓存结果以及对常规任务使用更小、更高效的模型来保持智能体的快速性。</p>
<p><strong>• Reliability (Handling Glitches):</strong> Agents must handle temporary failures. When a call  fails, automatically retry, ideally with <em>exponential backoff</em> to give the service time to  recover. This requires designing “safe-to-retry” (<em>idempotent</em>) tools to prevent bugs like  duplicate charges.</p>
<p><strong>• 可靠性（处理故障）：</strong> 智能体必须处理临时故障。当调用失败时，自动重试，理想情况下使用<em>指数退避</em>给服务时间恢复。这需要设计”可安全重试”（<em>幂等</em>）工具以防止重复收费等错误。</p>
<p><strong>• Cost:</strong> Keep the agent affordable by shortening prompts, using cheaper models for  easier tasks, and sending requests in groups (batching).</p>
<p><strong>• 成本：</strong> 通过缩短提示、对较简单的任务使用更便宜的模型以及分组发送请求（批处理）来保持智能体的经济性。</p>
<p><strong>Managing Risk: The Security Response Playbook</strong></p>
<p><strong>管理风险：安全响应手册</strong></p>
<p>Because an agent can act on its own, you need a playbook for rapid containment. When  a threat is detected, the response should follow a clear sequence: <strong>contain, triage,  and resolve</strong>.</p>
<p>因为智能体可以自主行动，你需要一个快速遏制的手册。当检测到威胁时，响应应遵循明确的顺序：<strong>遏制、分类和解决</strong>。</p>
<p>The first step is <strong>immediate containment</strong>. The priority is to stop the harm, typically with a  “circuit breaker”—a feature flag to instantly disable the affected tool.</p>
<p>第一步是<strong>立即遏制</strong>。优先事项是停止伤害，通常使用”断路器”——一个功能标志来立即禁用受影响的工具。</p>
<p>Next is <strong>triage</strong>. With the threat contained, suspicious requests are routed to a human-in-the loop (HITL) review queue to investigate the exploit’s scope and impact.</p>
<p>接下来是<strong>分类</strong>。在威胁被遏制后，可疑请求被路由到人机协同（HITL）审查队列，以调查漏洞的范围和影响。</p>
<p>Finally, the focus shifts to a <strong>permanent resolution</strong>. The team develops a patch—like an  updated input filter or system prompt—and deploys it through the automated CI&#x2F;CD pipeline,  ensuring the fix is fully tested before blocking the exploit for good.</p>
<p>最后，焦点转向<strong>永久解决</strong>。团队开发补丁——如更新的输入过滤器或系统提示——并通过自动化 CI&#x2F;CD 管道部署它，确保修复在永久阻止漏洞之前经过充分测试。</p>
<p><strong>Evolve: Learning from Production</strong></p>
<p><strong>演进：从生产中学习</strong></p>
<p>While the “Act” phase provides the system’s immediate, tactical reflexes, the “Evolve” phase  is about long-term, strategic improvement. It begins by looking at the patterns and trends  collected in your observability data and asking a crucial question: “How do we fix the root  cause so this problem never happens again?”</p>
<p>虽然”行动”阶段提供系统的即时战术反射，但”演进”阶段是关于长期战略改进的。它从查看在可观测性数据中收集的模式和趋势开始，并提出一个关键问题：”我们如何修复根本原因，使这个问题永远不再发生？”</p>
<p>This is where you move from reacting to production incidents to proactively making your  agent smarter, more efficient, and safer. You turn the raw data from the “Observe” phase into  durable improvements in your agent’s architecture, logic, and behavior.</p>
<p>这是你从对生产事件做出反应转变为主动使你的智能体更智能、更高效、更安全的地方。你将”观察”阶段的原始数据转化为智能体架构、逻辑和行为的持久改进。</p>
<p><strong>The Engine of Evolution: An Automated Path to Production</strong></p>
<p><strong>演进的引擎：通往生产的自动化路径</strong></p>
<p>An insight from production is only valuable if you can act on it quickly. Observing that 30% of  your users fail at a specific task is useless if it takes your team six months to deploy a fix.</p>
<p>来自生产的洞察只有在你能快速采取行动时才有价值。如果你的团队需要六个月才能部署修复，那么观察到 30% 的用户在特定任务上失败是没用的。</p>
<p>This is where the <strong>automated CI&#x2F;CD pipeline</strong> you built in pre-production (Section 3)  becomes the most critical component of your operational loop. It is the engine that powers  rapid evolution. A fast, reliable path to production allows you to close the loop between  observation and improvement in hours or days, not weeks or months.</p>
<p>这就是你在预生产中构建的<strong>自动化 CI&#x2F;CD 管道</strong>（第 3 节）成为你运营循环中最关键组件的地方。它是驱动快速演进的引擎。快速、可靠的生产路径允许你在数小时或数天内（而非数周或数月）关闭观察和改进之间的循环。</p>
<p>When you identify a potential improvement—whether it’s a refined prompt, a new tool, or an  updated safety guardrail—the process should be:</p>
<p>当你识别出潜在的改进——无论是精炼的提示、新工具还是更新的安全护栏——流程应该是：</p>
<p><strong>1. Commit the Change:</strong> The proposed improvement is committed to your  version-controlled repository.</p>
<p><strong>1. 提交更改：</strong> 将提议的改进提交到你的版本控制存储库。</p>
<p><strong>2. Trigger Automation:</strong> The commit automatically triggers your CI&#x2F;CD pipeline.</p>
<p><strong>2. 触发自动化：</strong> 提交自动触发你的 CI&#x2F;CD 管道。</p>
<p><strong>3. Validate Rigorously:</strong> The pipeline runs the full suite of unit tests, security scans, and the  agent quality evaluation suite against your updated datasets.</p>
<p><strong>3. 严格验证：</strong> 管道针对你更新的数据集运行完整的单元测试、安全扫描和智能体质量评估套件。</p>
<p><strong>4. Deploy Safely:</strong> Once validated, the change is deployed to production using a safe  rollout strategy.</p>
<p><strong>4. 安全部署：</strong> 一旦验证，更改将使用安全发布策略部署到生产。</p>
<p>This automated workflow transforms evolution from a slow, high-risk manual project into a  fast, repeatable, and data-driven process.</p>
<p>这种自动化工作流将演进从缓慢的、高风险的手动项目转变为快速的、可重复的、数据驱动的过程。</p>
<p><strong>The Evolution Workflow: From Insight to Deployed Improvement</strong></p>
<p><strong>演进工作流：从洞察到部署改进</strong></p>
<p><strong>1. Analyze Production Data:</strong> Identify trends in user behavior, task success rates, and  security incidents from production logs.</p>
<p><strong>1. 分析生产数据：</strong> 从生产日志中识别用户行为、任务成功率和安全事件的趋势。</p>
<p><strong>2. Update Evaluation Datasets:</strong> Transform production failures into tomorrow’s test cases,  augmenting your golden dataset.</p>
<p><strong>2. 更新评估数据集：</strong> 将生产失败转化为明天的测试用例，增强你的黄金数据集。</p>
<p><strong>3. Refine and Deploy:</strong> Commit improvements to trigger the automated pipeline—whether  refining prompts, adding tools, or updating guardrails.</p>
<p><strong>3. 精炼和部署：</strong> 提交改进以触发自动化管道——无论是精炼提示、添加工具还是更新护栏。</p>
<p>This creates a virtuous cycle where your agent continuously improves with every  user interaction.</p>
<p>这创造了一个良性循环，你的智能体随着每次用户交互不断改进。</p>
<p>![][image5] <strong>An Evolve Loop in Action</strong></p>
<p><strong>演进循环实战案例</strong></p>
<p>A retail agent’s logs (<strong>Observe</strong>) show that 15% of users receive an error when asking  for ‘similar products.’ The product team <strong>Acts</strong> by creating a high-priority ticket. The  <strong>Evolve</strong> phase begins: production logs are used to create a new, failing test case for  the evaluation dataset. An <strong>AI Engineer</strong> refines the agent’s prompt and adds a new,  more robust tool for similarity search. The change is committed, passes the now updated evaluation suite in the CI&#x2F;CD pipeline, and is safely rolled out via a canary  deployment, resolving the user issue in under 48 hours.</p>
<p>一个零售智能体的日志（<strong>观察</strong>）显示，15% 的用户在询问”类似产品”时收到错误。产品团队通过创建高优先级工单来<strong>行动</strong>。<strong>演进</strong>阶段开始：使用生产日志为评估数据集创建一个新的失败测试用例。<strong>AI 工程师</strong>精炼智能体的提示并添加一个新的、更强大的相似性搜索工具。更改被提交，通过 CI&#x2F;CD 管道中现在更新的评估套件，并通过金丝雀部署安全发布，在 48 小时内解决了用户问题。</p>
<p><strong>Evolving Security: The Production Feedback Loop</strong></p>
<p><strong>演进安全：生产反馈循环</strong></p>
<p>While the foundational security and responsibility framework is established in pre-production  (Section 3.4), the work is never truly finished. Security is not a static checklist; it is a dynamic,  continuous process of adaptation. The production environment is the ultimate testing  ground, and the insights gathered there are essential for hardening your agent against  real-world threats.</p>
<p>虽然基础安全和责任框架在预生产中建立（第 3.4 节），但工作从未真正完成。安全不是静态检查清单；它是一个动态的、持续的适应过程。生产环境是最终的测试场，在那里收集的洞察对于强化你的智能体以应对真实世界的威胁至关重要。</p>
<p>This is where the <strong>Observe</strong> → <strong>Act</strong> → <strong>Evolve</strong> loop becomes critical for security. The process  is a direct extension of the evolution workflow:</p>
<p>这就是<strong>观察</strong> → <strong>行动</strong> → <strong>演进</strong>循环对安全变得至关重要的地方。该过程是演进工作流的直接扩展：</p>
<p><strong>1. Observe:</strong> Your monitoring and logging systems detect a new threat vector. This could be  a novel prompt injection technique that bypasses your current filters, or an unexpected  interaction that leads to a minor data leak.</p>
<p><strong>1. 观察：</strong> 你的监控和日志系统检测到新的威胁向量。这可能是绕过你当前过滤器的新型提示注入技术，或者导致轻微数据泄露的意外交互。</p>
<p><strong>2. Act:</strong> The immediate security response team contains the threat (as discussed in  Section 4.2).</p>
<p><strong>2. 行动：</strong> 立即安全响应团队遏制威胁（如第 4.2 节所述）。</p>
<p><strong>3. Evolve:</strong> This is the crucial step for long-term resilience. The security insight is fed back  into your development lifecycle:</p>
<p><strong>3. 演进：</strong> 这是长期弹性的关键步骤。安全洞察被反馈到你的开发生命周期中：</p>
<p><strong>• Update Evaluation Datasets:</strong> The new prompt injection attack is added as a  permanent test case to your evaluation suite.</p>
<p><strong>• 更新评估数据集：</strong> 新的提示注入攻击作为永久测试用例添加到你的评估套件中。</p>
<p><strong>• Refine Guardrails:</strong> A <strong>Prompt Engineer</strong> or <strong>AI Engineer</strong> refines the agent’s system  prompt, input filters, or tool-use policies to block the new attack vector.</p>
<p><strong>• 精炼护栏：</strong> <strong>提示工程师</strong>或 <strong>AI 工程师</strong>精炼智能体的系统提示、输入过滤器或工具使用策略以阻止新的攻击向量。</p>
<p><strong>• Automate and Deploy:</strong> The engineer commits the change, which triggers the full CI&#x2F; CD pipeline. The updated agent is rigorously validated against the newly expanded  evaluation set and deployed to production, closing the vulnerability.</p>
<p><strong>• 自动化和部署：</strong> 工程师提交更改，触发完整的 CI&#x2F;CD 管道。更新的智能体针对新扩展的评估集进行严格验证并部署到生产，关闭漏洞。</p>
<p>This creates a powerful feedback loop where every production incident makes your agent  stronger and more resilient, transforming your security posture from a defensive stance to  one of continuous, proactive improvement.</p>
<p>这创造了一个强大的反馈循环，每个生产事件都使你的智能体更强大、更有弹性，将你的安全态势从防御姿态转变为持续主动改进的姿态。</p>
<p>To learn more about Responsible AI and securing AI Agentic Systems, please consult  the whitepaper Google’s Approach for Secure AI Agents12 and the Google Secure AI  Framework (SAIF)13.</p>
<p>要了解更多关于负责任 AI 和保护 AI 智能体系统的信息，请参阅白皮书《Google 安全 AI 智能体方法》¹² 和《Google 安全 AI 框架（SAIF）》¹³。</p>
<p><strong>Beyond Single-Agent Operations</strong></p>
<p><strong>超越单智能体运营</strong></p>
<p>You’ve mastered operating individual agents in production and can ship them at high velocity.  But as organizations scale to dozens of specialized agents—each built by different teams  with different frameworks—a new challenge emerges: these agents can’t collaborate. The  next section explores how standardized protocols can transform these isolated agents into  an interoperable ecosystem, unlocking exponential value through agent collaboration.</p>
<p>你已经掌握了在生产中运营单个智能体，并且可以高速交付它们。但随着组织扩展到数十个专门的智能体——每个都由不同团队使用不同框架构建——一个新的挑战出现了：这些智能体无法协作。下一节探讨标准化协议如何将这些孤立的智能体转变为可互操作的生态系统，通过智能体协作释放指数级价值。</p>
<p><strong>A2A - Reusability and Standardization</strong></p>
<p><strong>A2A——可重用性与标准化</strong></p>
<p>You’ve built dozens of specialized agents across your organization. The customer service  team has their support agent. Analytics built a forecasting system. Risk management  created fraud detection. But here’s the problem: these agents can’t talk to each other -  whether that be because they were created in different frameworks, projects or different  clouds altogether.</p>
<p>你已经在组织中构建了数十个专门的智能体。客服团队有他们的支持智能体。分析团队构建了预测系统。风险管理创建了欺诈检测。但问题是：这些智能体无法相互交流——无论是因为它们是在不同的框架、项目中创建的，还是完全在不同的云上创建的。</p>
<p>This isolation creates massive inefficiency. Every team rebuilds the same capabilities. Critical  insights stay trapped in silos. What you need is interoperability—the ability for any agent  to leverage any other agent’s capabilities, regardless of who built it or what framework  they used.</p>
<p>这种孤立造成了巨大的低效率。每个团队都在重建相同的功能。关键洞察被困在孤岛中。你需要的是互操作性——任何智能体都能利用任何其他智能体的能力，无论谁构建了它或使用了什么框架。</p>
<p>To solve this, a principled approach to standardization is required, built on two distinct but  complementary protocols. While the <strong>Model Context Protocol (<strong>MCP22</strong>)</strong>, which we covered  in detail on <strong>Agent Tools and Interoperability with MCP</strong>, provides a universal standard for  tool integration, it is not sufficient for the complex, stateful collaboration required between</p>
<p>intelligent agents. This is the problem the <strong>Agent2Agent (<strong>A2A23</strong>)</strong> protocol, now governed by  the Linux Foundation, was designed to solve.</p>
<p>为了解决这个问题，需要一种基于原则的标准化方法，建立在两个不同但互补的协议之上。虽然<strong>模型上下文协议（MCP²²）</strong>——我们在<strong>智能体工具和与 MCP 的互操作性</strong>中详细介绍过——为工具集成提供了通用标准，但它不足以满足智能体之间所需的复杂、有状态协作。这就是**Agent2Agent（A2A²³）**协议旨在解决的问题，该协议现在由 Linux 基金会管理。</p>
<p>The distinction is critical. When you need a simple, stateless function like fetching weather  data or querying a database, you need a tool that speaks MCP. But when you need to  delegate a complex goal, such as “analyze last quarter’s customer churn and recommend  three intervention strategies,” you need an intelligent partner that can reason, plan, and act  autonomously via A2A. In short, MCP lets you say, “Do this specific thing,” while A2A lets you  say, “Achieve this complex goal.”</p>
<p>这种区别至关重要。当你需要一个简单的无状态函数（如获取天气数据或查询数据库）时，你需要一个使用 MCP 的工具。但当你需要委托一个复杂目标（如”分析上季度的客户流失并推荐三种干预策略”）时，你需要一个能够通过 A2A 自主推理、规划和行动的智能伙伴。简而言之，MCP 让你说”做这个具体的事情”，而 A2A 让你说”实现这个复杂目标”。</p>
<p><strong>A2A Protocol: From Concept to Implementation</strong></p>
<p><strong>A2A 协议：从概念到实现</strong></p>
<p>The A2A protocol is designed to break down organizational silos and enable seamless  collaboration between agents. Consider a scenario where a fraud detection agent spots  suspicious activity. To understand the full context, it needs data from a separate transaction  analysis agent. Without A2A, a human analyst must manually bridge this gap—a process  that could take hours. With A2A, the agents collaborate automatically, resolving the issue  in minutes.</p>
<p>A2A 协议旨在打破组织孤岛并实现智能体之间的无缝协作。考虑这样一个场景：欺诈检测智能体发现可疑活动。为了了解完整的上下文，它需要来自单独的交易分析智能体的数据。没有 A2A，人类分析师必须手动弥合这一差距——这个过程可能需要数小时。有了 A2A，智能体自动协作，在几分钟内解决问题。</p>
<p>The first step of the collaboration is discovering the right agent to delegate to - this is made  possible through Agent Cards,24 which are standardized JSON specifications that act as a  business card for each agent. An Agent Card describes what an agent can do, its security  requirements, its skills, and how to reach out to it (url), allowing any other agent in the  ecosystem to dynamically discover its peers. See example Agent Card below:</p>
<p>协作的第一步是发现要委托的正确智能体——这是通过 Agent Cards²⁴ 实现的，它们是标准化的 JSON 规范，充当每个智能体的名片。Agent Card 描述了智能体可以做什么、其安全要求、技能以及如何联系它（url），允许生态系统中的任何其他智能体动态发现其同行。请参见下面的示例 Agent Card：</p>
<blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;check_prime_agent&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;An agent specialized in checking whether numbers are prime&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;securitySchemes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;agent_oauth_2_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oauth2&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;defaultInputModes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;text/plain&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;defaultOutputModes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;application/json&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;skills&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prime_checking&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Prime Number Checking&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Check if numbers are prime using efficient algorithms&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;mathematical&quot;</span><span class="punctuation">,</span> <span class="string">&quot;computation&quot;</span><span class="punctuation">,</span> <span class="string">&quot;prime&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:8001/a2a/check_prime_agent&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></blockquote>
<p>Snippet 1: A sample agent card for the check_prime_agent</p>
<p>代码片段 1：check_prime_agent 的示例智能体卡片</p>
<p>Adopting this protocol doesn’t require an architectural overhaul. Frameworks like the ADK  simplify this process significantly (docs25). You can make an existing agent A2A-compatible  with a single function call, which automatically generates its AgentCard and makes it  available on the network.</p>
<p>采用此协议不需要架构大修。像 ADK 这样的框架显著简化了这个过程（文档²⁵）。你可以通过单个函数调用使现有智能体兼容 A2A，这会自动生成其 AgentCard 并使其在网络上可用。</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example using ADK: Exposing an agent via A2A</span></span><br><span class="line"><span class="comment"># 使用 ADK 的示例：通过 A2A 暴露智能体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> google.adk.a2a.utils.agent_to_a2a <span class="keyword">import</span> to_a2a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your existing agent</span></span><br><span class="line"><span class="comment"># 你现有的智能体</span></span><br><span class="line">root_agent = Agent(</span><br><span class="line">    name=<span class="string">&#x27;hello_world_agent&#x27;</span>,</span><br><span class="line">    <span class="comment"># ... your agent code ...</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make it A2A-compatible</span></span><br><span class="line"><span class="comment"># 使其兼容 A2A</span></span><br><span class="line">a2a_app = to_a2a(root_agent, port=<span class="number">8001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Serve with uvicorn</span></span><br><span class="line"><span class="comment"># uvicorn agent:a2a_app --host localhost --port 8001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Or serve with Agent Engine</span></span><br><span class="line"><span class="comment"># from vertexai.preview.reasoning_engines import A2aAgent</span></span><br><span class="line"><span class="comment"># from google.adk.a2a.executor.a2a_agent_executor import A2aAgentExecutor</span></span><br><span class="line"><span class="comment"># a2a_agent = A2aAgent(</span></span><br><span class="line"><span class="comment">#     agent_executor_builder=lambda: A2aAgentExecutor(agent=root_agent)</span></span><br><span class="line"><span class="comment"># )</span></span><br></pre></td></tr></table></figure></blockquote>
<p>Snippet 2: Using the ADK’s to_a2a utility to wrap an existing agent and expose it for A2A communication</p>
<p>代码片段 2：使用 ADK 的 to_a2a 实用程序包装现有智能体并将其暴露用于 A2A 通信</p>
<p>Once an agent is exposed, any other agent can consume it by referencing its AgentCard. For  example, a customer service agent can now query a remote product catalog agent without  needing to know its internal workings.</p>
<p>一旦智能体被暴露，任何其他智能体都可以通过引用其 AgentCard 来消费它。例如，客服智能体现在可以查询远程产品目录智能体，而无需了解其内部工作原理。</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example using ADK: Consuming a remote agent via A2A</span></span><br><span class="line"><span class="comment"># 使用 ADK 的示例：通过 A2A 消费远程智能体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> google.adk.agents.remote_a2a_agent <span class="keyword">import</span> RemoteA2aAgent</span><br><span class="line"></span><br><span class="line">prime_agent = RemoteA2aAgent(</span><br><span class="line">    name=<span class="string">&quot;prime_agent&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;Agent that handles checking if numbers are prime.&quot;</span>,</span><br><span class="line">    agent_card=<span class="string">&quot;http://localhost:8001/a2a/check_prime_agent/.well-known/agent-card.json&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></blockquote>
<p>Snippet 3: Using the ADK’s RemoteA2aAgent class to connect to and consume a remote agent</p>
<p>代码片段 3：使用 ADK 的 RemoteA2aAgent 类连接并消费远程智能体</p>
<p>This unlocks powerful, hierarchical compositions. A root agent can be configured to  orchestrate both a local sub-agent for a simple task and a remote, specialized agent via A2A,  creating a more capable system.</p>
<p>这解锁了强大的层次化组合。根智能体可以配置为同时编排用于简单任务的本地子智能体和通过 A2A 的远程专门智能体，创建更有能力的系统。</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example using ADK: Hierarchical agent composition</span></span><br><span class="line"><span class="comment"># 使用 ADK 的示例：层次化智能体组合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ADK Local sub-agent for dice rolling</span></span><br><span class="line"><span class="comment"># 用于掷骰子的 ADK 本地子智能体</span></span><br><span class="line">roll_agent = Agent(</span><br><span class="line">    name=<span class="string">&quot;roll_agent&quot;</span>,</span><br><span class="line">    instruction=<span class="string">&quot;You are an expert at rolling dice.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ADK Remote A2A agent for prime checking</span></span><br><span class="line"><span class="comment"># 用于质数检查的 ADK 远程 A2A 智能体</span></span><br><span class="line">prime_agent = RemoteA2aAgent(</span><br><span class="line">    name=<span class="string">&quot;prime_agent&quot;</span>,</span><br><span class="line">    agent_card=<span class="string">&quot;http://localhost:8001/.well-known/agent-card.json&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ADK Root orchestrator combining both</span></span><br><span class="line"><span class="comment"># 组合两者的 ADK 根编排器</span></span><br><span class="line">root_agent = Agent(</span><br><span class="line">    name=<span class="string">&quot;root_agent&quot;</span>,</span><br><span class="line">    instruction=<span class="string">&quot;&quot;&quot;Delegate rolling dice to roll_agent, prime checking to prime_agent.&quot;&quot;&quot;</span>,</span><br><span class="line">    sub_agents=[roll_agent, prime_agent]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></blockquote>
<p>Snippet 4: Using a remote A2A agent (prime_agent) as a sub-agent within a hierarchical agent structure in  the ADK</p>
<p>代码片段 4：在 ADK 的层次化智能体结构中使用远程 A2A 智能体（prime_agent）作为子智能体</p>
<p>However, enabling this level of autonomous collaboration introduces two non-negotiable  technical requirements. First is <strong>distributed tracing</strong>, where every request carries a unique  trace ID, which is essential for debugging and maintaining a coherent audit trail across  multiple agents. Second is robust <strong>state management</strong>. A2A interactions are inherently  stateful, requiring a sophisticated persistence layer for tracking progress and ensuring  transactional integrity.</p>
<p>然而，启用这种级别的自主协作引入了两个不可妥协的技术要求。首先是<strong>分布式追踪</strong>，每个请求都携带唯一的追踪 ID，这对于调试和维护跨多个智能体的连贯审计跟踪至关重要。其次是强大的<strong>状态管理</strong>。A2A 交互本质上是有状态的，需要一个复杂的持久层来跟踪进度并确保事务完整性。</p>
<p><strong>A2A is best suited for formal, cross-team integrations</strong> that require a durable service  contract. For tightly coupled tasks within a single application, <strong>lightweight local sub-agents  often remain a more efficient choice</strong>. As the ecosystem matures, new agents should be  built with native support for both protocols, ensuring every new component is immediately  discoverable, interoperable, and reusable, compounding the value of the whole system.</p>
<p><strong>A2A 最适合需要持久服务契约的正式跨团队集成</strong>。对于单个应用程序内紧密耦合的任务，<strong>轻量级本地子智能体通常仍是更高效的选择</strong>。随着生态系统的成熟，新智能体应该内置对两种协议的原生支持，确保每个新组件都能立即被发现、可互操作和可重用，从而复合整个系统的价值。</p>
<p><strong>How A2A and MCP Work Together</strong></p>
<p><strong>A2A 与 MCP 如何协同工作</strong></p>
<p>**![][image6]**Figure 4: A2A and MCP collaboration with a single glance</p>
<p>图 4：一目了然的 A2A 和 MCP 协作</p>
<p>A2A and MCP are not competing standards; they are complementary protocols designed  to operate at different levels of abstraction. The distinction depends on what an agent is  interacting with. MCP is the domain of <strong>tools and resources</strong>—primitives with well-defined,  structured inputs and outputs, like a calculator or a database API. A2A is the domain of other  <strong>agents</strong>—autonomous systems that can reason, plan, use multiple tools, and maintain state to  achieve complex goals.</p>
<p>A2A 和 MCP 不是竞争标准；它们是设计用于在不同抽象级别运行的互补协议。区别取决于智能体与什么交互。MCP 是<strong>工具和资源</strong>的领域——具有明确定义的结构化输入和输出的原语，如计算器或数据库 API。A2A 是其他<strong>智能体</strong>的领域——可以推理、规划、使用多个工具并维护状态以实现复杂目标的自主系统。</p>
<p>The most powerful agentic systems use both protocols in a layered architecture. An  application might primarily use A2A to orchestrate high-level collaboration between multiple  intelligent agents, while each of those agents internally uses MCP to interact with its own  specific set of tools and resources.</p>
<p>最强大的智能体系统在分层架构中使用这两种协议。应用程序可能主要使用 A2A 来编排多个智能智能体之间的高级协作，而这些智能体中的每一个都在内部使用 MCP 与其自己的特定工具和资源集交互。</p>
<p>A practical analogy is an auto repair shop staffed by autonomous AI agents.</p>
<p>一个实际的类比是由自主 AI 智能体组成的汽车维修店。</p>
<p><strong>1. User-to-Agent (A2A):</strong> A customer uses A2A to communicate with the “Shop Manager”  agent to describe a high-level problem: “My car is making a rattling noise.”</p>
<p><strong>1. 用户到智能体（A2A）：</strong> 客户使用 A2A 与”店长”智能体通信来描述一个高级问题：”我的车发出咔嗒声。”</p>
<p><strong>2. Agent-to-Agent (A2A):</strong> The Shop Manager engages in a multi-turn diagnostic  conversation and then delegates the task to a specialized “Mechanic” agent, again  using A2A.</p>
<p><strong>2. 智能体到智能体（A2A）：</strong> 店长进行多轮诊断对话，然后再次使用 A2A 将任务委托给专门的”机械师”智能体。</p>
<p><strong>3. Agent-to-Tool (MCP):</strong> The Mechanic agent now needs to perform specific actions. It  uses MCP to call its specialized tools: it runs <code>scan_vehicle_for_error_codes()</code> on a  diagnostic scanner, queries a repair manual database with <code>get_repair_procedure()</code>,  and operates a platform lift with <code>raise_platform()</code>.</p>
<p><strong>3. 智能体到工具（MCP）：</strong> 机械师智能体现在需要执行具体操作。它使用 MCP 调用其专门工具：在诊断扫描仪上运行 <code>scan_vehicle_for_error_codes()</code>，用 <code>get_repair_procedure()</code> 查询维修手册数据库，并用 <code>raise_platform()</code> 操作平台升降机。</p>
<p><strong>4. Agent-to-Agent (A2A):</strong> After diagnosing the issue, the Mechanic agent determines a part  is needed. It uses A2A to communicate with an external “Parts Supplier” agent to inquire  about availability and place an order.</p>
<p><strong>4. 智能体到智能体（A2A）：</strong> 诊断问题后，机械师智能体确定需要一个零件。它使用 A2A 与外部”零件供应商”智能体通信，询问可用性并下订单。</p>
<p>In this workflow, A2A facilitates the higher-level, conversational, and task-oriented  interactions between the customer, the shop’s agents, and external suppliers. Meanwhile,  MCP provides the standardized plumbing that enables the mechanic agent to reliably use its  specific, structured tools to do its job.</p>
<p>在这个工作流中，A2A 促进了客户、店铺智能体和外部供应商之间更高级别的、对话式的、面向任务的交互。同时，MCP 提供了标准化的管道，使机械师智能体能够可靠地使用其特定的结构化工具来完成工作。</p>
<p><strong>Registry Architectures: When and How to Build Them</strong></p>
<p><strong>注册表架构：何时及如何构建</strong></p>
<p>Why do some organizations build registries while others don’t need them? The answer lies in  scale and complexity. When you have fifty tools, manual configuration works fine. But when  you reach five thousand tools distributed across different teams and environments, you face  a discovery problem that demands a systematic solution.</p>
<p>为什么有些组织构建注册表而其他组织不需要？答案在于规模和复杂性。当你有五十个工具时，手动配置就足够了。但当你有五千个分布在不同团队和环境中的工具时，你面临的发现问题需要系统性的解决方案。</p>
<p>A <strong>Tool Registry</strong> uses a protocol like MCP to catalog all assets, from functions to APIs.  Instead of giving agents access to thousands of tools, you create curated lists, leading to  three common patterns:</p>
<p><strong>工具注册表</strong>使用像 MCP 这样的协议来编目所有资产，从函数到 API。与其让智能体访问数千个工具，不如创建精选列表，从而产生三种常见模式：</p>
<p><strong>• Generalist agents:</strong> Access the full catalog, trading speed and accuracy for scope. <strong>• Specialist agents:</strong> Use predefined subsets for higher performance. <strong>• Dynamic agents:</strong> Query the registry at runtime to adapt to new tools.</p>
<p><strong>• 通用智能体：</strong> 访问完整目录，用速度和准确性换取范围。<strong>• 专家智能体：</strong> 使用预定义的子集以获得更高的性能。<strong>• 动态智能体：</strong> 在运行时查询注册表以适应新工具。</p>
<p>The primary benefit is human discovery—developers can search for existing tools before  building duplicates, security teams can audit tool access, and product owners can  understand their agents’ capabilities.</p>
<p>主要好处是人工发现——开发人员可以在构建重复项之前搜索现有工具，安全团队可以审计工具访问，产品负责人可以了解其智能体的能力。</p>
<p>An <strong>Agent Registry</strong> applies the same concept to agents, using formats like A2A’s  AgentCards. It helps teams discover and reuse existing agents, reducing redundant work.  This also lays the groundwork for automated agent-to-agent delegation, though this remains  an emerging pattern.</p>
<p><strong>智能体注册表</strong>将相同的概念应用于智能体，使用像 A2A 的 AgentCards 这样的格式。它帮助团队发现和重用现有智能体，减少冗余工作。这也为自动化智能体到智能体委托奠定了基础，尽管这仍然是一种新兴模式。</p>
<p>Registries offer discovery and governance at the cost of maintenance. You can  consider starting without one and only build it when your ecosystem’s scale demands  centralized management!</p>
<p>注册表以维护成本为代价提供发现和治理。你可以考虑在没有注册表的情况下开始，只有在你的生态系统规模需要集中管理时才构建它！</p>
<p>Decision Framework for Registries</p>
<p>注册表决策框架</p>
<p><strong>Tool Registry:</strong> Build when tool discovery becomes a bottleneck or security requires  centralized auditing.</p>
<p><strong>工具注册表：</strong> 当工具发现成为瓶颈或安全需要集中审计时构建。</p>
<p><strong>Agent Registry:</strong> Build when multiple teams need to discover and reuse specialized  agents without tight coupling.</p>
<p><strong>智能体注册表：</strong> 当多个团队需要发现和重用专门智能体而不需要紧密耦合时构建。</p>
<p><strong>Putting It All Together: The</strong><br><strong>AgentOps Lifecycle</strong></p>
<p><strong>整合一切：AgentOps 生命周期</strong></p>
<p>We can now assemble these pillars into a single, cohesive reference architecture! The life  cycle begins in the <strong>developer’s inner loop</strong>—a phase of rapid local testing and prototyping  to shape the agent’s core logic. Once a change is ready, it enters the formal pre-production  engine, where automated evaluation gates validate its quality and safety against a  golden dataset. From there, safe rollouts release it to production, where comprehensive  observability captures the real-world data needed to fuel the continuous evolution loop,  turning every insight into the next improvement.</p>
<p>我们现在可以将这些支柱组装成一个单一的、连贯的参考架构！生命周期从<strong>开发者的内部循环</strong>开始——一个快速本地测试和原型设计阶段，以塑造智能体的核心逻辑。一旦更改准备就绪，它就进入正式的预生产引擎，自动化评估门控根据黄金数据集验证其质量和安全性。从那里，安全发布将其发布到生产，全面的可观测性捕获为持续演进循环提供动力所需的真实世界数据，将每个洞察转化为下一个改进。</p>
<p>For a comprehensive walkthrough of operationalizing AI agents, including evaluation,  tool management, CI&#x2F;CD standardization, and effective architecture designs, watch the  AgentOps: Operationalize AI Agents video26 on the official Google Cloud YouTube channel.</p>
<p>有关将 AI 智能体投入运营的全面演练，包括评估、工具管理、CI&#x2F;CD 标准化和有效的架构设计，请观看 Google Cloud 官方 YouTube 频道上的 AgentOps: Operationalize AI Agents 视频²⁶。</p>
<p>![][image7]Figure 5: AgentOps core capabilities, environments, and processes</p>
<p>图 5：AgentOps 核心能力、环境和流程</p>
<p><strong>Conclusion: Bridging the Last Mile  with AgentOps</strong></p>
<p><strong>结论：用 AgentOps 跨越最后一公里</strong></p>
<p>Moving an AI prototype to a production system is an organizational transformation that  requires a new operational discipline: <strong>AgentOps</strong>.</p>
<p>将 AI 原型转移到生产系统是一种需要新运营纪律的组织转型：<strong>AgentOps</strong>。</p>
<p>Most agent projects fail in the “last mile” not due to technology, but because the operational  complexity of autonomous systems is underestimated. This guide maps the path to bridge  that gap. It begins with establishing <strong>People and Process</strong> as the foundation for governance.  Next, a <strong>Pre-Production</strong> strategy built on evaluation-gated deployment automates high stakes releases. Once live, a continuous <strong>Observe</strong> → <strong>Act</strong> → <strong>Evolve</strong> loop turns every user  interaction into a potential insight. Finally, <strong>Interoperability</strong> protocols scale the system by  transforming isolated agents into a collaborative, intelligent ecosystem.</p>
<p>大多数智能体项目在”最后一公里”失败不是因为技术，而是因为低估了自主系统的运营复杂性。本指南绘制了弥合这一差距的路径。它从建立<strong>人员和流程</strong>作为治理基础开始。接下来，基于评估门控部署的<strong>预生产</strong>策略自动化高风险发布。一旦上线，持续的<strong>观察</strong> → <strong>行动</strong> → <strong>演进</strong>循环将每次用户交互转化为潜在的洞察。最后，<strong>互操作性</strong>协议通过将孤立的智能体转变为协作的智能生态系统来扩展系统。</p>
<p>The immediate benefits—like preventing a security breach or enabling a rapid rollback— justify the investment. But the real value is velocity. Mature AgentOps practices allow teams  to deploy improvements in hours, not weeks, turning static deployments into continuously  evolving products.</p>
<p>直接好处——如防止安全漏洞或启用快速回滚——证明了投资的合理性。但真正的价值是速度。成熟的 AgentOps 实践允许团队在数小时而非数周内部署改进，将静态部署转变为持续演进的产品。</p>
<p><strong>Your Path Forward</strong></p>
<p><strong>你的前进之路</strong></p>
<p><strong>• If you’re starting out,</strong> focus on the fundamentals: build your first evaluation dataset,  implement a CI&#x2F;CD pipeline, and establish comprehensive monitoring. The Agent Starter  Pack is a great place to start—it creates a production-ready agent project in minutes with  these foundations already built-in.</p>
<p><strong>• 如果你刚开始，</strong> 专注于基础：构建你的第一个评估数据集，实施 CI&#x2F;CD 管道，并建立全面的监控。Agent Starter Pack 是一个很好的起点——它在几分钟内创建一个已内置这些基础的生产就绪智能体项目。</p>
<p><strong>• If you’re scaling</strong>, elevate your practice: automate the feedback loop from production  insight to deployed improvement and standardize on interoperable protocols to build a  cohesive ecosystem, not just point solutions.</p>
<p><strong>• 如果你正在扩展，</strong> 提升你的实践：自动化从生产洞察到部署改进的反馈循环，并在可互操作的协议上标准化，以构建一个有凝聚力的生态系统，而不仅仅是点解决方案。</p>
<p>The next frontier is not just building better individual agents, but orchestrating sophisticated  multi-agent systems that learn and collaborate. The operational discipline of AgentOps is the  foundation that makes this possible.</p>
<p>下一个前沿不仅仅是构建更好的个体智能体，而是编排学习和协作的复杂多智能体系统。AgentOps 的运营纪律是使这成为可能的基础。</p>
<p>We hope this playbook empowers you to build the next generation of intelligent, reliable, and  trustworthy AI. Bridging the last mile is therefore not the final step in a project, but the first  step in creating value!</p>
<p>我们希望这本指南能帮助你构建下一代智能、可靠和值得信赖的 AI。因此，跨越最后一公里不是项目的最后一步，而是创造价值的第一步！</p>
<p><strong>Endnotes</strong></p>
<p><strong>尾注</strong></p>
<p>1. <a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/agent-starter-pack">https://github.com/GoogleCloudPlatform/agent-starter-pack</a></p>
<p>2. <a target="_blank" rel="noopener" href="https://cloud.google.com/vertex-ai/docs/evaluation/introduction">https://cloud.google.com/vertex-ai/docs/evaluation/introduction</a></p>
<p>3. <a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent">https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent</a> &#x2F;.cloudbuild&#x2F;pr_checks.yaml</p>
<p>4. <a target="_blank" rel="noopener" href="https://cloud.google.com/build">https://cloud.google.com/build</a></p>
<p>5. <a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent">https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent</a> &#x2F;.cloudbuild&#x2F;staging.yaml</p>
<p>6. <a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent">https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent</a> &#x2F;.cloudbuild&#x2F;deploy-to-prod.yaml</p>
<p>7. <a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent">https://github.com/GoogleCloudPlatform/agent-starter-pack/blob/example-agent/example-agent</a> &#x2F;terraform</p>
<p>8. <a target="_blank" rel="noopener" href="https://cloud.google.com/secret-manager">https://cloud.google.com/secret-manager</a></p>
<p>9. <a target="_blank" rel="noopener" href="https://cloud.google.com/agent-builder/agent-engine/overview">https://cloud.google.com/agent-builder/agent-engine/overview</a></p>
<p>10. <a target="_blank" rel="noopener" href="https://cloud.google.com/run">https://cloud.google.com/run</a></p>
<p>11. <a target="_blank" rel="noopener" href="https://cloud.google.com/load-balancing/docs/https/traffic-management">https://cloud.google.com/load-balancing/docs/https/traffic-management</a> 12. <a target="_blank" rel="noopener" href="https://research.google/pubs/an-introduction-to-googles-approach-for-secure-ai-agents/">https://research.google/pubs/an-introduction-to-googles-approach-for-secure-ai-agents/</a> 13. <a target="_blank" rel="noopener" href="https://safety.google/cybersecurity-advancements/saif/">https://safety.google/cybersecurity-advancements/saif/</a></p>
<p>14. <a target="_blank" rel="noopener" href="https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/configure-safety-attributes">https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/configure-safety-attributes</a> 15. <a target="_blank" rel="noopener" href="https://cloud.google.com/trace">https://cloud.google.com/trace</a></p>
<p>16. <a target="_blank" rel="noopener" href="https://cloud.google.com/logging">https://cloud.google.com/logging</a></p>
<p>17. <a target="_blank" rel="noopener" href="https://cloud.google.com/monitoring">https://cloud.google.com/monitoring</a></p>
<p>18. <a target="_blank" rel="noopener" href="https://google.github.io/adk-docs/observability/cloud-trace/">https://google.github.io/adk-docs/observability/cloud-trace/</a></p>
<p>19. <a target="_blank" rel="noopener" href="https://cloud.google.com/pubsub">https://cloud.google.com/pubsub</a></p>
<p>20. <a target="_blank" rel="noopener" href="https://cloud.google.com/alloydb">https://cloud.google.com/alloydb</a></p>
<p>21. <a target="_blank" rel="noopener" href="https://cloud.google.com/sql">https://cloud.google.com/sql</a></p>
<p>22. <a target="_blank" rel="noopener" href="https://modelcontextprotocol.io/">https://modelcontextprotocol.io/</a></p>
<p>23. <a target="_blank" rel="noopener" href="https://a2a-protocol.org/latest/specification/">https://a2a-protocol.org/latest/specification/</a></p>
<p>24. <a target="_blank" rel="noopener" href="https://a2a-protocol.org/latest/specification//#5-agent-discovery-the-agent-card">https://a2a-protocol.org/latest/specification/\#5-agent-discovery-the-agent-card</a> 25. <a target="_blank" rel="noopener" href="https://google.github.io/adk-docs/a2a/">https://google.github.io/adk-docs/a2a/</a></p>
<p>26. <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=kJRgj58ujEk">https://www.youtube.com/watch?v=kJRgj58ujEk</a></p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left  disabled "
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2025/12/21/Agent-4%20%20Agent%20Quality/"
      title="AI-Agent 白皮书 4 - Agent Quality"
     >

    <p class="title-text">
      
        AI-Agent 白皮书 4 - Agent Quality
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>





    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2025 bruin<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
